
/**
 * Client
**/

import * as runtime from '@prisma/client/runtime/library.js';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions
import $Result = runtime.Types.Result

export type PrismaPromise<T> = $Public.PrismaPromise<T>


/**
 * Model Empresa
 * 
 */
export type Empresa = $Result.DefaultSelection<Prisma.$EmpresaPayload>
/**
 * Model Cliente
 * 
 */
export type Cliente = $Result.DefaultSelection<Prisma.$ClientePayload>
/**
 * Model Filial
 * 
 */
export type Filial = $Result.DefaultSelection<Prisma.$FilialPayload>
/**
 * Model Vendedor
 * 
 */
export type Vendedor = $Result.DefaultSelection<Prisma.$VendedorPayload>
/**
 * Model Produto
 * 
 */
export type Produto = $Result.DefaultSelection<Prisma.$ProdutoPayload>
/**
 * Model MaquinaEstoque
 * 
 */
export type MaquinaEstoque = $Result.DefaultSelection<Prisma.$MaquinaEstoquePayload>
/**
 * Model NotasFiscalCabecalho
 * 
 */
export type NotasFiscalCabecalho = $Result.DefaultSelection<Prisma.$NotasFiscalCabecalhoPayload>
/**
 * Model NotaFiscalItem
 * 
 */
export type NotaFiscalItem = $Result.DefaultSelection<Prisma.$NotaFiscalItemPayload>
/**
 * Model User
 * 
 */
export type User = $Result.DefaultSelection<Prisma.$UserPayload>
/**
 * Model RfvParameterSet
 * 
 */
export type RfvParameterSet = $Result.DefaultSelection<Prisma.$RfvParameterSetPayload>
/**
 * Model RfvSegment
 * 
 */
export type RfvSegment = $Result.DefaultSelection<Prisma.$RfvSegmentPayload>

/**
 * Enums
 */
export namespace $Enums {
  export const RfvStrategy: {
  threshold: 'threshold',
  quantile: 'quantile'
};

export type RfvStrategy = (typeof RfvStrategy)[keyof typeof RfvStrategy]


export const CalculationStrategy: {
  automatic: 'automatic',
  manual: 'manual'
};

export type CalculationStrategy = (typeof CalculationStrategy)[keyof typeof CalculationStrategy]

}

export type RfvStrategy = $Enums.RfvStrategy

export const RfvStrategy: typeof $Enums.RfvStrategy

export type CalculationStrategy = $Enums.CalculationStrategy

export const CalculationStrategy: typeof $Enums.CalculationStrategy

/**
 * ##  Prisma Client ʲˢ
 * 
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Empresas
 * const empresas = await prisma.empresa.findMany()
 * ```
 *
 * 
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  ClientOptions extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  U = 'log' extends keyof ClientOptions ? ClientOptions['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<ClientOptions['log']> : never : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   * 
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Empresas
   * const empresas = await prisma.empresa.findMany()
   * ```
   *
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<ClientOptions, Prisma.PrismaClientOptions>);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): void;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

  /**
   * Add a middleware
   * @deprecated since 4.16.0. For new code, prefer client extensions instead.
   * @see https://pris.ly/d/extensions
   */
  $use(cb: Prisma.Middleware): void

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;


  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<R>


  $extends: $Extensions.ExtendsHook<"extends", Prisma.TypeMapCb, ExtArgs>

      /**
   * `prisma.empresa`: Exposes CRUD operations for the **Empresa** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Empresas
    * const empresas = await prisma.empresa.findMany()
    * ```
    */
  get empresa(): Prisma.EmpresaDelegate<ExtArgs>;

  /**
   * `prisma.cliente`: Exposes CRUD operations for the **Cliente** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Clientes
    * const clientes = await prisma.cliente.findMany()
    * ```
    */
  get cliente(): Prisma.ClienteDelegate<ExtArgs>;

  /**
   * `prisma.filial`: Exposes CRUD operations for the **Filial** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Filials
    * const filials = await prisma.filial.findMany()
    * ```
    */
  get filial(): Prisma.FilialDelegate<ExtArgs>;

  /**
   * `prisma.vendedor`: Exposes CRUD operations for the **Vendedor** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Vendedors
    * const vendedors = await prisma.vendedor.findMany()
    * ```
    */
  get vendedor(): Prisma.VendedorDelegate<ExtArgs>;

  /**
   * `prisma.produto`: Exposes CRUD operations for the **Produto** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Produtos
    * const produtos = await prisma.produto.findMany()
    * ```
    */
  get produto(): Prisma.ProdutoDelegate<ExtArgs>;

  /**
   * `prisma.maquinaEstoque`: Exposes CRUD operations for the **MaquinaEstoque** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more MaquinaEstoques
    * const maquinaEstoques = await prisma.maquinaEstoque.findMany()
    * ```
    */
  get maquinaEstoque(): Prisma.MaquinaEstoqueDelegate<ExtArgs>;

  /**
   * `prisma.notasFiscalCabecalho`: Exposes CRUD operations for the **NotasFiscalCabecalho** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more NotasFiscalCabecalhos
    * const notasFiscalCabecalhos = await prisma.notasFiscalCabecalho.findMany()
    * ```
    */
  get notasFiscalCabecalho(): Prisma.NotasFiscalCabecalhoDelegate<ExtArgs>;

  /**
   * `prisma.notaFiscalItem`: Exposes CRUD operations for the **NotaFiscalItem** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more NotaFiscalItems
    * const notaFiscalItems = await prisma.notaFiscalItem.findMany()
    * ```
    */
  get notaFiscalItem(): Prisma.NotaFiscalItemDelegate<ExtArgs>;

  /**
   * `prisma.user`: Exposes CRUD operations for the **User** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Users
    * const users = await prisma.user.findMany()
    * ```
    */
  get user(): Prisma.UserDelegate<ExtArgs>;

  /**
   * `prisma.rfvParameterSet`: Exposes CRUD operations for the **RfvParameterSet** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more RfvParameterSets
    * const rfvParameterSets = await prisma.rfvParameterSet.findMany()
    * ```
    */
  get rfvParameterSet(): Prisma.RfvParameterSetDelegate<ExtArgs>;

  /**
   * `prisma.rfvSegment`: Exposes CRUD operations for the **RfvSegment** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more RfvSegments
    * const rfvSegments = await prisma.rfvSegment.findMany()
    * ```
    */
  get rfvSegment(): Prisma.RfvSegmentDelegate<ExtArgs>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError
  export import NotFoundError = runtime.NotFoundError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql



  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics 
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket

  /**
  * Extensions
  */
  export import Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export import Args = $Public.Args
  export import Payload = $Public.Payload
  export import Result = $Public.Result
  export import Exact = $Public.Exact

  /**
   * Prisma Client JS version: 5.22.0
   * Query Engine version: 605197351a3c8bdd595af2d2a9bc3025bca48ea2
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion 

  /**
   * Utility Types
   */


  export import JsonObject = runtime.JsonObject
  export import JsonArray = runtime.JsonArray
  export import JsonValue = runtime.JsonValue
  export import InputJsonObject = runtime.InputJsonObject
  export import InputJsonArray = runtime.InputJsonArray
  export import InputJsonValue = runtime.InputJsonValue

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }

  type SelectAndOmit = {
    select: any
    omit: any
  }

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : T extends SelectAndOmit
        ? 'Please either choose `select` or `omit`.'
        : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? K : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    Empresa: 'Empresa',
    Cliente: 'Cliente',
    Filial: 'Filial',
    Vendedor: 'Vendedor',
    Produto: 'Produto',
    MaquinaEstoque: 'MaquinaEstoque',
    NotasFiscalCabecalho: 'NotasFiscalCabecalho',
    NotaFiscalItem: 'NotaFiscalItem',
    User: 'User',
    RfvParameterSet: 'RfvParameterSet',
    RfvSegment: 'RfvSegment'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }

  interface TypeMapCb extends $Utils.Fn<{extArgs: $Extensions.InternalArgs, clientOptions: PrismaClientOptions }, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs'], this['params']['clientOptions']>
  }

  export type TypeMap<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> = {
    meta: {
      modelProps: "empresa" | "cliente" | "filial" | "vendedor" | "produto" | "maquinaEstoque" | "notasFiscalCabecalho" | "notaFiscalItem" | "user" | "rfvParameterSet" | "rfvSegment"
      txIsolationLevel: Prisma.TransactionIsolationLevel
    }
    model: {
      Empresa: {
        payload: Prisma.$EmpresaPayload<ExtArgs>
        fields: Prisma.EmpresaFieldRefs
        operations: {
          findUnique: {
            args: Prisma.EmpresaFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmpresaPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.EmpresaFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmpresaPayload>
          }
          findFirst: {
            args: Prisma.EmpresaFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmpresaPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.EmpresaFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmpresaPayload>
          }
          findMany: {
            args: Prisma.EmpresaFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmpresaPayload>[]
          }
          create: {
            args: Prisma.EmpresaCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmpresaPayload>
          }
          createMany: {
            args: Prisma.EmpresaCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.EmpresaDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmpresaPayload>
          }
          update: {
            args: Prisma.EmpresaUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmpresaPayload>
          }
          deleteMany: {
            args: Prisma.EmpresaDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.EmpresaUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.EmpresaUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmpresaPayload>
          }
          aggregate: {
            args: Prisma.EmpresaAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateEmpresa>
          }
          groupBy: {
            args: Prisma.EmpresaGroupByArgs<ExtArgs>
            result: $Utils.Optional<EmpresaGroupByOutputType>[]
          }
          count: {
            args: Prisma.EmpresaCountArgs<ExtArgs>
            result: $Utils.Optional<EmpresaCountAggregateOutputType> | number
          }
        }
      }
      Cliente: {
        payload: Prisma.$ClientePayload<ExtArgs>
        fields: Prisma.ClienteFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ClienteFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClientePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ClienteFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClientePayload>
          }
          findFirst: {
            args: Prisma.ClienteFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClientePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ClienteFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClientePayload>
          }
          findMany: {
            args: Prisma.ClienteFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClientePayload>[]
          }
          create: {
            args: Prisma.ClienteCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClientePayload>
          }
          createMany: {
            args: Prisma.ClienteCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.ClienteDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClientePayload>
          }
          update: {
            args: Prisma.ClienteUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClientePayload>
          }
          deleteMany: {
            args: Prisma.ClienteDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ClienteUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ClienteUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClientePayload>
          }
          aggregate: {
            args: Prisma.ClienteAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCliente>
          }
          groupBy: {
            args: Prisma.ClienteGroupByArgs<ExtArgs>
            result: $Utils.Optional<ClienteGroupByOutputType>[]
          }
          count: {
            args: Prisma.ClienteCountArgs<ExtArgs>
            result: $Utils.Optional<ClienteCountAggregateOutputType> | number
          }
        }
      }
      Filial: {
        payload: Prisma.$FilialPayload<ExtArgs>
        fields: Prisma.FilialFieldRefs
        operations: {
          findUnique: {
            args: Prisma.FilialFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FilialPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.FilialFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FilialPayload>
          }
          findFirst: {
            args: Prisma.FilialFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FilialPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.FilialFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FilialPayload>
          }
          findMany: {
            args: Prisma.FilialFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FilialPayload>[]
          }
          create: {
            args: Prisma.FilialCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FilialPayload>
          }
          createMany: {
            args: Prisma.FilialCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.FilialDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FilialPayload>
          }
          update: {
            args: Prisma.FilialUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FilialPayload>
          }
          deleteMany: {
            args: Prisma.FilialDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.FilialUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.FilialUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FilialPayload>
          }
          aggregate: {
            args: Prisma.FilialAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateFilial>
          }
          groupBy: {
            args: Prisma.FilialGroupByArgs<ExtArgs>
            result: $Utils.Optional<FilialGroupByOutputType>[]
          }
          count: {
            args: Prisma.FilialCountArgs<ExtArgs>
            result: $Utils.Optional<FilialCountAggregateOutputType> | number
          }
        }
      }
      Vendedor: {
        payload: Prisma.$VendedorPayload<ExtArgs>
        fields: Prisma.VendedorFieldRefs
        operations: {
          findUnique: {
            args: Prisma.VendedorFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VendedorPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.VendedorFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VendedorPayload>
          }
          findFirst: {
            args: Prisma.VendedorFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VendedorPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.VendedorFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VendedorPayload>
          }
          findMany: {
            args: Prisma.VendedorFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VendedorPayload>[]
          }
          create: {
            args: Prisma.VendedorCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VendedorPayload>
          }
          createMany: {
            args: Prisma.VendedorCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.VendedorDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VendedorPayload>
          }
          update: {
            args: Prisma.VendedorUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VendedorPayload>
          }
          deleteMany: {
            args: Prisma.VendedorDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.VendedorUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.VendedorUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VendedorPayload>
          }
          aggregate: {
            args: Prisma.VendedorAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateVendedor>
          }
          groupBy: {
            args: Prisma.VendedorGroupByArgs<ExtArgs>
            result: $Utils.Optional<VendedorGroupByOutputType>[]
          }
          count: {
            args: Prisma.VendedorCountArgs<ExtArgs>
            result: $Utils.Optional<VendedorCountAggregateOutputType> | number
          }
        }
      }
      Produto: {
        payload: Prisma.$ProdutoPayload<ExtArgs>
        fields: Prisma.ProdutoFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ProdutoFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProdutoPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ProdutoFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProdutoPayload>
          }
          findFirst: {
            args: Prisma.ProdutoFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProdutoPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ProdutoFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProdutoPayload>
          }
          findMany: {
            args: Prisma.ProdutoFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProdutoPayload>[]
          }
          create: {
            args: Prisma.ProdutoCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProdutoPayload>
          }
          createMany: {
            args: Prisma.ProdutoCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.ProdutoDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProdutoPayload>
          }
          update: {
            args: Prisma.ProdutoUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProdutoPayload>
          }
          deleteMany: {
            args: Prisma.ProdutoDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ProdutoUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ProdutoUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProdutoPayload>
          }
          aggregate: {
            args: Prisma.ProdutoAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateProduto>
          }
          groupBy: {
            args: Prisma.ProdutoGroupByArgs<ExtArgs>
            result: $Utils.Optional<ProdutoGroupByOutputType>[]
          }
          count: {
            args: Prisma.ProdutoCountArgs<ExtArgs>
            result: $Utils.Optional<ProdutoCountAggregateOutputType> | number
          }
        }
      }
      MaquinaEstoque: {
        payload: Prisma.$MaquinaEstoquePayload<ExtArgs>
        fields: Prisma.MaquinaEstoqueFieldRefs
        operations: {
          findUnique: {
            args: Prisma.MaquinaEstoqueFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MaquinaEstoquePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.MaquinaEstoqueFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MaquinaEstoquePayload>
          }
          findFirst: {
            args: Prisma.MaquinaEstoqueFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MaquinaEstoquePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.MaquinaEstoqueFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MaquinaEstoquePayload>
          }
          findMany: {
            args: Prisma.MaquinaEstoqueFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MaquinaEstoquePayload>[]
          }
          create: {
            args: Prisma.MaquinaEstoqueCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MaquinaEstoquePayload>
          }
          createMany: {
            args: Prisma.MaquinaEstoqueCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.MaquinaEstoqueDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MaquinaEstoquePayload>
          }
          update: {
            args: Prisma.MaquinaEstoqueUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MaquinaEstoquePayload>
          }
          deleteMany: {
            args: Prisma.MaquinaEstoqueDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.MaquinaEstoqueUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.MaquinaEstoqueUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MaquinaEstoquePayload>
          }
          aggregate: {
            args: Prisma.MaquinaEstoqueAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateMaquinaEstoque>
          }
          groupBy: {
            args: Prisma.MaquinaEstoqueGroupByArgs<ExtArgs>
            result: $Utils.Optional<MaquinaEstoqueGroupByOutputType>[]
          }
          count: {
            args: Prisma.MaquinaEstoqueCountArgs<ExtArgs>
            result: $Utils.Optional<MaquinaEstoqueCountAggregateOutputType> | number
          }
        }
      }
      NotasFiscalCabecalho: {
        payload: Prisma.$NotasFiscalCabecalhoPayload<ExtArgs>
        fields: Prisma.NotasFiscalCabecalhoFieldRefs
        operations: {
          findUnique: {
            args: Prisma.NotasFiscalCabecalhoFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotasFiscalCabecalhoPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.NotasFiscalCabecalhoFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotasFiscalCabecalhoPayload>
          }
          findFirst: {
            args: Prisma.NotasFiscalCabecalhoFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotasFiscalCabecalhoPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.NotasFiscalCabecalhoFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotasFiscalCabecalhoPayload>
          }
          findMany: {
            args: Prisma.NotasFiscalCabecalhoFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotasFiscalCabecalhoPayload>[]
          }
          create: {
            args: Prisma.NotasFiscalCabecalhoCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotasFiscalCabecalhoPayload>
          }
          createMany: {
            args: Prisma.NotasFiscalCabecalhoCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.NotasFiscalCabecalhoDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotasFiscalCabecalhoPayload>
          }
          update: {
            args: Prisma.NotasFiscalCabecalhoUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotasFiscalCabecalhoPayload>
          }
          deleteMany: {
            args: Prisma.NotasFiscalCabecalhoDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.NotasFiscalCabecalhoUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.NotasFiscalCabecalhoUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotasFiscalCabecalhoPayload>
          }
          aggregate: {
            args: Prisma.NotasFiscalCabecalhoAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateNotasFiscalCabecalho>
          }
          groupBy: {
            args: Prisma.NotasFiscalCabecalhoGroupByArgs<ExtArgs>
            result: $Utils.Optional<NotasFiscalCabecalhoGroupByOutputType>[]
          }
          count: {
            args: Prisma.NotasFiscalCabecalhoCountArgs<ExtArgs>
            result: $Utils.Optional<NotasFiscalCabecalhoCountAggregateOutputType> | number
          }
        }
      }
      NotaFiscalItem: {
        payload: Prisma.$NotaFiscalItemPayload<ExtArgs>
        fields: Prisma.NotaFiscalItemFieldRefs
        operations: {
          findUnique: {
            args: Prisma.NotaFiscalItemFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotaFiscalItemPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.NotaFiscalItemFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotaFiscalItemPayload>
          }
          findFirst: {
            args: Prisma.NotaFiscalItemFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotaFiscalItemPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.NotaFiscalItemFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotaFiscalItemPayload>
          }
          findMany: {
            args: Prisma.NotaFiscalItemFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotaFiscalItemPayload>[]
          }
          create: {
            args: Prisma.NotaFiscalItemCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotaFiscalItemPayload>
          }
          createMany: {
            args: Prisma.NotaFiscalItemCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.NotaFiscalItemDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotaFiscalItemPayload>
          }
          update: {
            args: Prisma.NotaFiscalItemUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotaFiscalItemPayload>
          }
          deleteMany: {
            args: Prisma.NotaFiscalItemDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.NotaFiscalItemUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.NotaFiscalItemUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotaFiscalItemPayload>
          }
          aggregate: {
            args: Prisma.NotaFiscalItemAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateNotaFiscalItem>
          }
          groupBy: {
            args: Prisma.NotaFiscalItemGroupByArgs<ExtArgs>
            result: $Utils.Optional<NotaFiscalItemGroupByOutputType>[]
          }
          count: {
            args: Prisma.NotaFiscalItemCountArgs<ExtArgs>
            result: $Utils.Optional<NotaFiscalItemCountAggregateOutputType> | number
          }
        }
      }
      User: {
        payload: Prisma.$UserPayload<ExtArgs>
        fields: Prisma.UserFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findFirst: {
            args: Prisma.UserFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findMany: {
            args: Prisma.UserFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          create: {
            args: Prisma.UserCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          createMany: {
            args: Prisma.UserCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.UserDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          update: {
            args: Prisma.UserUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          deleteMany: {
            args: Prisma.UserDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.UserUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          aggregate: {
            args: Prisma.UserAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUser>
          }
          groupBy: {
            args: Prisma.UserGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserCountArgs<ExtArgs>
            result: $Utils.Optional<UserCountAggregateOutputType> | number
          }
        }
      }
      RfvParameterSet: {
        payload: Prisma.$RfvParameterSetPayload<ExtArgs>
        fields: Prisma.RfvParameterSetFieldRefs
        operations: {
          findUnique: {
            args: Prisma.RfvParameterSetFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RfvParameterSetPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.RfvParameterSetFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RfvParameterSetPayload>
          }
          findFirst: {
            args: Prisma.RfvParameterSetFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RfvParameterSetPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.RfvParameterSetFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RfvParameterSetPayload>
          }
          findMany: {
            args: Prisma.RfvParameterSetFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RfvParameterSetPayload>[]
          }
          create: {
            args: Prisma.RfvParameterSetCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RfvParameterSetPayload>
          }
          createMany: {
            args: Prisma.RfvParameterSetCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.RfvParameterSetDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RfvParameterSetPayload>
          }
          update: {
            args: Prisma.RfvParameterSetUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RfvParameterSetPayload>
          }
          deleteMany: {
            args: Prisma.RfvParameterSetDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.RfvParameterSetUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.RfvParameterSetUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RfvParameterSetPayload>
          }
          aggregate: {
            args: Prisma.RfvParameterSetAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateRfvParameterSet>
          }
          groupBy: {
            args: Prisma.RfvParameterSetGroupByArgs<ExtArgs>
            result: $Utils.Optional<RfvParameterSetGroupByOutputType>[]
          }
          count: {
            args: Prisma.RfvParameterSetCountArgs<ExtArgs>
            result: $Utils.Optional<RfvParameterSetCountAggregateOutputType> | number
          }
        }
      }
      RfvSegment: {
        payload: Prisma.$RfvSegmentPayload<ExtArgs>
        fields: Prisma.RfvSegmentFieldRefs
        operations: {
          findUnique: {
            args: Prisma.RfvSegmentFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RfvSegmentPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.RfvSegmentFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RfvSegmentPayload>
          }
          findFirst: {
            args: Prisma.RfvSegmentFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RfvSegmentPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.RfvSegmentFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RfvSegmentPayload>
          }
          findMany: {
            args: Prisma.RfvSegmentFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RfvSegmentPayload>[]
          }
          create: {
            args: Prisma.RfvSegmentCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RfvSegmentPayload>
          }
          createMany: {
            args: Prisma.RfvSegmentCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.RfvSegmentDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RfvSegmentPayload>
          }
          update: {
            args: Prisma.RfvSegmentUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RfvSegmentPayload>
          }
          deleteMany: {
            args: Prisma.RfvSegmentDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.RfvSegmentUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.RfvSegmentUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RfvSegmentPayload>
          }
          aggregate: {
            args: Prisma.RfvSegmentAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateRfvSegment>
          }
          groupBy: {
            args: Prisma.RfvSegmentGroupByArgs<ExtArgs>
            result: $Utils.Optional<RfvSegmentGroupByOutputType>[]
          }
          count: {
            args: Prisma.RfvSegmentCountArgs<ExtArgs>
            result: $Utils.Optional<RfvSegmentCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<"define", Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
  export interface PrismaClientOptions {
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasourceUrl?: string
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat
    /**
     * @example
     * ```
     * // Defaults to stdout
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events
     * log: [
     *   { emit: 'stdout', level: 'query' },
     *   { emit: 'stdout', level: 'info' },
     *   { emit: 'stdout', level: 'warn' }
     *   { emit: 'stdout', level: 'error' }
     * ]
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: (LogLevel | LogDefinition)[]
    /**
     * The default values for transactionOptions
     * maxWait ?= 2000
     * timeout ?= 5000
     */
    transactionOptions?: {
      maxWait?: number
      timeout?: number
      isolationLevel?: Prisma.TransactionIsolationLevel
    }
  }


  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type GetLogType<T extends LogLevel | LogDefinition> = T extends LogDefinition ? T['emit'] extends 'event' ? T['level'] : never : never
  export type GetEvents<T extends any> = T extends Array<LogLevel | LogDefinition> ?
    GetLogType<T[0]> | GetLogType<T[1]> | GetLogType<T[2]> | GetLogType<T[3]>
    : never

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'createManyAndReturn'
    | 'update'
    | 'updateMany'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy'

  /**
   * These options are being passed into the middleware as "params"
   */
  export type MiddlewareParams = {
    model?: ModelName
    action: PrismaAction
    args: any
    dataPath: string[]
    runInTransaction: boolean
  }

  /**
   * The `T` type makes sure, that the `return proceed` is not forgotten in the middleware implementation
   */
  export type Middleware<T = any> = (
    params: MiddlewareParams,
    next: (params: MiddlewareParams) => $Utils.JsPromise<T>,
  ) => $Utils.JsPromise<T>

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type EmpresaCountOutputType
   */

  export type EmpresaCountOutputType = {
    filiais: number
  }

  export type EmpresaCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    filiais?: boolean | EmpresaCountOutputTypeCountFiliaisArgs
  }

  // Custom InputTypes
  /**
   * EmpresaCountOutputType without action
   */
  export type EmpresaCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmpresaCountOutputType
     */
    select?: EmpresaCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * EmpresaCountOutputType without action
   */
  export type EmpresaCountOutputTypeCountFiliaisArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FilialWhereInput
  }


  /**
   * Count Type ClienteCountOutputType
   */

  export type ClienteCountOutputType = {
    notasFiscais: number
  }

  export type ClienteCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    notasFiscais?: boolean | ClienteCountOutputTypeCountNotasFiscaisArgs
  }

  // Custom InputTypes
  /**
   * ClienteCountOutputType without action
   */
  export type ClienteCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClienteCountOutputType
     */
    select?: ClienteCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ClienteCountOutputType without action
   */
  export type ClienteCountOutputTypeCountNotasFiscaisArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: NotasFiscalCabecalhoWhereInput
  }


  /**
   * Count Type FilialCountOutputType
   */

  export type FilialCountOutputType = {
    notasFiscais: number
    vendedores: number
    rfvParameterSets: number
    maquinasEstoque: number
  }

  export type FilialCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    notasFiscais?: boolean | FilialCountOutputTypeCountNotasFiscaisArgs
    vendedores?: boolean | FilialCountOutputTypeCountVendedoresArgs
    rfvParameterSets?: boolean | FilialCountOutputTypeCountRfvParameterSetsArgs
    maquinasEstoque?: boolean | FilialCountOutputTypeCountMaquinasEstoqueArgs
  }

  // Custom InputTypes
  /**
   * FilialCountOutputType without action
   */
  export type FilialCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FilialCountOutputType
     */
    select?: FilialCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * FilialCountOutputType without action
   */
  export type FilialCountOutputTypeCountNotasFiscaisArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: NotasFiscalCabecalhoWhereInput
  }

  /**
   * FilialCountOutputType without action
   */
  export type FilialCountOutputTypeCountVendedoresArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: VendedorWhereInput
  }

  /**
   * FilialCountOutputType without action
   */
  export type FilialCountOutputTypeCountRfvParameterSetsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RfvParameterSetWhereInput
  }

  /**
   * FilialCountOutputType without action
   */
  export type FilialCountOutputTypeCountMaquinasEstoqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MaquinaEstoqueWhereInput
  }


  /**
   * Count Type VendedorCountOutputType
   */

  export type VendedorCountOutputType = {
    notasFiscais: number
  }

  export type VendedorCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    notasFiscais?: boolean | VendedorCountOutputTypeCountNotasFiscaisArgs
  }

  // Custom InputTypes
  /**
   * VendedorCountOutputType without action
   */
  export type VendedorCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VendedorCountOutputType
     */
    select?: VendedorCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * VendedorCountOutputType without action
   */
  export type VendedorCountOutputTypeCountNotasFiscaisArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: NotasFiscalCabecalhoWhereInput
  }


  /**
   * Count Type ProdutoCountOutputType
   */

  export type ProdutoCountOutputType = {
    maquinasEstoque: number
    notasFiscaisItens: number
  }

  export type ProdutoCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    maquinasEstoque?: boolean | ProdutoCountOutputTypeCountMaquinasEstoqueArgs
    notasFiscaisItens?: boolean | ProdutoCountOutputTypeCountNotasFiscaisItensArgs
  }

  // Custom InputTypes
  /**
   * ProdutoCountOutputType without action
   */
  export type ProdutoCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProdutoCountOutputType
     */
    select?: ProdutoCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ProdutoCountOutputType without action
   */
  export type ProdutoCountOutputTypeCountMaquinasEstoqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MaquinaEstoqueWhereInput
  }

  /**
   * ProdutoCountOutputType without action
   */
  export type ProdutoCountOutputTypeCountNotasFiscaisItensArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: NotaFiscalItemWhereInput
  }


  /**
   * Count Type MaquinaEstoqueCountOutputType
   */

  export type MaquinaEstoqueCountOutputType = {
    Notas_Fiscais_Itens: number
  }

  export type MaquinaEstoqueCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Notas_Fiscais_Itens?: boolean | MaquinaEstoqueCountOutputTypeCountNotas_Fiscais_ItensArgs
  }

  // Custom InputTypes
  /**
   * MaquinaEstoqueCountOutputType without action
   */
  export type MaquinaEstoqueCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MaquinaEstoqueCountOutputType
     */
    select?: MaquinaEstoqueCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * MaquinaEstoqueCountOutputType without action
   */
  export type MaquinaEstoqueCountOutputTypeCountNotas_Fiscais_ItensArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: NotaFiscalItemWhereInput
  }


  /**
   * Count Type NotasFiscalCabecalhoCountOutputType
   */

  export type NotasFiscalCabecalhoCountOutputType = {
    itens: number
  }

  export type NotasFiscalCabecalhoCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    itens?: boolean | NotasFiscalCabecalhoCountOutputTypeCountItensArgs
  }

  // Custom InputTypes
  /**
   * NotasFiscalCabecalhoCountOutputType without action
   */
  export type NotasFiscalCabecalhoCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NotasFiscalCabecalhoCountOutputType
     */
    select?: NotasFiscalCabecalhoCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * NotasFiscalCabecalhoCountOutputType without action
   */
  export type NotasFiscalCabecalhoCountOutputTypeCountItensArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: NotaFiscalItemWhereInput
  }


  /**
   * Count Type RfvParameterSetCountOutputType
   */

  export type RfvParameterSetCountOutputType = {
    segments: number
  }

  export type RfvParameterSetCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    segments?: boolean | RfvParameterSetCountOutputTypeCountSegmentsArgs
  }

  // Custom InputTypes
  /**
   * RfvParameterSetCountOutputType without action
   */
  export type RfvParameterSetCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RfvParameterSetCountOutputType
     */
    select?: RfvParameterSetCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * RfvParameterSetCountOutputType without action
   */
  export type RfvParameterSetCountOutputTypeCountSegmentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RfvSegmentWhereInput
  }


  /**
   * Models
   */

  /**
   * Model Empresa
   */

  export type AggregateEmpresa = {
    _count: EmpresaCountAggregateOutputType | null
    _avg: EmpresaAvgAggregateOutputType | null
    _sum: EmpresaSumAggregateOutputType | null
    _min: EmpresaMinAggregateOutputType | null
    _max: EmpresaMaxAggregateOutputType | null
  }

  export type EmpresaAvgAggregateOutputType = {
    id: number | null
  }

  export type EmpresaSumAggregateOutputType = {
    id: number | null
  }

  export type EmpresaMinAggregateOutputType = {
    id: number | null
    razaoSocial: string | null
    nomeFantasia: string | null
    cnpjMatriz: string | null
    inscricaoEstadual: string | null
    cidade: string | null
    estado: string | null
    logradouro: string | null
    numero: string | null
    bairro: string | null
    cep: string | null
    telefone: string | null
    email: string | null
    ativo: boolean | null
    dataCriacao: Date | null
    dataAtualizacao: Date | null
  }

  export type EmpresaMaxAggregateOutputType = {
    id: number | null
    razaoSocial: string | null
    nomeFantasia: string | null
    cnpjMatriz: string | null
    inscricaoEstadual: string | null
    cidade: string | null
    estado: string | null
    logradouro: string | null
    numero: string | null
    bairro: string | null
    cep: string | null
    telefone: string | null
    email: string | null
    ativo: boolean | null
    dataCriacao: Date | null
    dataAtualizacao: Date | null
  }

  export type EmpresaCountAggregateOutputType = {
    id: number
    razaoSocial: number
    nomeFantasia: number
    cnpjMatriz: number
    inscricaoEstadual: number
    cidade: number
    estado: number
    logradouro: number
    numero: number
    bairro: number
    cep: number
    telefone: number
    email: number
    ativo: number
    dataCriacao: number
    dataAtualizacao: number
    _all: number
  }


  export type EmpresaAvgAggregateInputType = {
    id?: true
  }

  export type EmpresaSumAggregateInputType = {
    id?: true
  }

  export type EmpresaMinAggregateInputType = {
    id?: true
    razaoSocial?: true
    nomeFantasia?: true
    cnpjMatriz?: true
    inscricaoEstadual?: true
    cidade?: true
    estado?: true
    logradouro?: true
    numero?: true
    bairro?: true
    cep?: true
    telefone?: true
    email?: true
    ativo?: true
    dataCriacao?: true
    dataAtualizacao?: true
  }

  export type EmpresaMaxAggregateInputType = {
    id?: true
    razaoSocial?: true
    nomeFantasia?: true
    cnpjMatriz?: true
    inscricaoEstadual?: true
    cidade?: true
    estado?: true
    logradouro?: true
    numero?: true
    bairro?: true
    cep?: true
    telefone?: true
    email?: true
    ativo?: true
    dataCriacao?: true
    dataAtualizacao?: true
  }

  export type EmpresaCountAggregateInputType = {
    id?: true
    razaoSocial?: true
    nomeFantasia?: true
    cnpjMatriz?: true
    inscricaoEstadual?: true
    cidade?: true
    estado?: true
    logradouro?: true
    numero?: true
    bairro?: true
    cep?: true
    telefone?: true
    email?: true
    ativo?: true
    dataCriacao?: true
    dataAtualizacao?: true
    _all?: true
  }

  export type EmpresaAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Empresa to aggregate.
     */
    where?: EmpresaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Empresas to fetch.
     */
    orderBy?: EmpresaOrderByWithRelationInput | EmpresaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: EmpresaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Empresas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Empresas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Empresas
    **/
    _count?: true | EmpresaCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: EmpresaAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: EmpresaSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: EmpresaMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: EmpresaMaxAggregateInputType
  }

  export type GetEmpresaAggregateType<T extends EmpresaAggregateArgs> = {
        [P in keyof T & keyof AggregateEmpresa]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateEmpresa[P]>
      : GetScalarType<T[P], AggregateEmpresa[P]>
  }




  export type EmpresaGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EmpresaWhereInput
    orderBy?: EmpresaOrderByWithAggregationInput | EmpresaOrderByWithAggregationInput[]
    by: EmpresaScalarFieldEnum[] | EmpresaScalarFieldEnum
    having?: EmpresaScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: EmpresaCountAggregateInputType | true
    _avg?: EmpresaAvgAggregateInputType
    _sum?: EmpresaSumAggregateInputType
    _min?: EmpresaMinAggregateInputType
    _max?: EmpresaMaxAggregateInputType
  }

  export type EmpresaGroupByOutputType = {
    id: number
    razaoSocial: string
    nomeFantasia: string | null
    cnpjMatriz: string
    inscricaoEstadual: string | null
    cidade: string | null
    estado: string | null
    logradouro: string | null
    numero: string | null
    bairro: string | null
    cep: string | null
    telefone: string | null
    email: string | null
    ativo: boolean
    dataCriacao: Date
    dataAtualizacao: Date
    _count: EmpresaCountAggregateOutputType | null
    _avg: EmpresaAvgAggregateOutputType | null
    _sum: EmpresaSumAggregateOutputType | null
    _min: EmpresaMinAggregateOutputType | null
    _max: EmpresaMaxAggregateOutputType | null
  }

  type GetEmpresaGroupByPayload<T extends EmpresaGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<EmpresaGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof EmpresaGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], EmpresaGroupByOutputType[P]>
            : GetScalarType<T[P], EmpresaGroupByOutputType[P]>
        }
      >
    >


  export type EmpresaSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    razaoSocial?: boolean
    nomeFantasia?: boolean
    cnpjMatriz?: boolean
    inscricaoEstadual?: boolean
    cidade?: boolean
    estado?: boolean
    logradouro?: boolean
    numero?: boolean
    bairro?: boolean
    cep?: boolean
    telefone?: boolean
    email?: boolean
    ativo?: boolean
    dataCriacao?: boolean
    dataAtualizacao?: boolean
    filiais?: boolean | Empresa$filiaisArgs<ExtArgs>
    _count?: boolean | EmpresaCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["empresa"]>


  export type EmpresaSelectScalar = {
    id?: boolean
    razaoSocial?: boolean
    nomeFantasia?: boolean
    cnpjMatriz?: boolean
    inscricaoEstadual?: boolean
    cidade?: boolean
    estado?: boolean
    logradouro?: boolean
    numero?: boolean
    bairro?: boolean
    cep?: boolean
    telefone?: boolean
    email?: boolean
    ativo?: boolean
    dataCriacao?: boolean
    dataAtualizacao?: boolean
  }

  export type EmpresaInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    filiais?: boolean | Empresa$filiaisArgs<ExtArgs>
    _count?: boolean | EmpresaCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $EmpresaPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Empresa"
    objects: {
      filiais: Prisma.$FilialPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      razaoSocial: string
      nomeFantasia: string | null
      cnpjMatriz: string
      inscricaoEstadual: string | null
      cidade: string | null
      estado: string | null
      logradouro: string | null
      numero: string | null
      bairro: string | null
      cep: string | null
      telefone: string | null
      email: string | null
      ativo: boolean
      dataCriacao: Date
      dataAtualizacao: Date
    }, ExtArgs["result"]["empresa"]>
    composites: {}
  }

  type EmpresaGetPayload<S extends boolean | null | undefined | EmpresaDefaultArgs> = $Result.GetResult<Prisma.$EmpresaPayload, S>

  type EmpresaCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<EmpresaFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: EmpresaCountAggregateInputType | true
    }

  export interface EmpresaDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Empresa'], meta: { name: 'Empresa' } }
    /**
     * Find zero or one Empresa that matches the filter.
     * @param {EmpresaFindUniqueArgs} args - Arguments to find a Empresa
     * @example
     * // Get one Empresa
     * const empresa = await prisma.empresa.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends EmpresaFindUniqueArgs>(args: SelectSubset<T, EmpresaFindUniqueArgs<ExtArgs>>): Prisma__EmpresaClient<$Result.GetResult<Prisma.$EmpresaPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Empresa that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {EmpresaFindUniqueOrThrowArgs} args - Arguments to find a Empresa
     * @example
     * // Get one Empresa
     * const empresa = await prisma.empresa.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends EmpresaFindUniqueOrThrowArgs>(args: SelectSubset<T, EmpresaFindUniqueOrThrowArgs<ExtArgs>>): Prisma__EmpresaClient<$Result.GetResult<Prisma.$EmpresaPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Empresa that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmpresaFindFirstArgs} args - Arguments to find a Empresa
     * @example
     * // Get one Empresa
     * const empresa = await prisma.empresa.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends EmpresaFindFirstArgs>(args?: SelectSubset<T, EmpresaFindFirstArgs<ExtArgs>>): Prisma__EmpresaClient<$Result.GetResult<Prisma.$EmpresaPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Empresa that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmpresaFindFirstOrThrowArgs} args - Arguments to find a Empresa
     * @example
     * // Get one Empresa
     * const empresa = await prisma.empresa.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends EmpresaFindFirstOrThrowArgs>(args?: SelectSubset<T, EmpresaFindFirstOrThrowArgs<ExtArgs>>): Prisma__EmpresaClient<$Result.GetResult<Prisma.$EmpresaPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Empresas that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmpresaFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Empresas
     * const empresas = await prisma.empresa.findMany()
     * 
     * // Get first 10 Empresas
     * const empresas = await prisma.empresa.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const empresaWithIdOnly = await prisma.empresa.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends EmpresaFindManyArgs>(args?: SelectSubset<T, EmpresaFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EmpresaPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Empresa.
     * @param {EmpresaCreateArgs} args - Arguments to create a Empresa.
     * @example
     * // Create one Empresa
     * const Empresa = await prisma.empresa.create({
     *   data: {
     *     // ... data to create a Empresa
     *   }
     * })
     * 
     */
    create<T extends EmpresaCreateArgs>(args: SelectSubset<T, EmpresaCreateArgs<ExtArgs>>): Prisma__EmpresaClient<$Result.GetResult<Prisma.$EmpresaPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Empresas.
     * @param {EmpresaCreateManyArgs} args - Arguments to create many Empresas.
     * @example
     * // Create many Empresas
     * const empresa = await prisma.empresa.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends EmpresaCreateManyArgs>(args?: SelectSubset<T, EmpresaCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Empresa.
     * @param {EmpresaDeleteArgs} args - Arguments to delete one Empresa.
     * @example
     * // Delete one Empresa
     * const Empresa = await prisma.empresa.delete({
     *   where: {
     *     // ... filter to delete one Empresa
     *   }
     * })
     * 
     */
    delete<T extends EmpresaDeleteArgs>(args: SelectSubset<T, EmpresaDeleteArgs<ExtArgs>>): Prisma__EmpresaClient<$Result.GetResult<Prisma.$EmpresaPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Empresa.
     * @param {EmpresaUpdateArgs} args - Arguments to update one Empresa.
     * @example
     * // Update one Empresa
     * const empresa = await prisma.empresa.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends EmpresaUpdateArgs>(args: SelectSubset<T, EmpresaUpdateArgs<ExtArgs>>): Prisma__EmpresaClient<$Result.GetResult<Prisma.$EmpresaPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Empresas.
     * @param {EmpresaDeleteManyArgs} args - Arguments to filter Empresas to delete.
     * @example
     * // Delete a few Empresas
     * const { count } = await prisma.empresa.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends EmpresaDeleteManyArgs>(args?: SelectSubset<T, EmpresaDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Empresas.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmpresaUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Empresas
     * const empresa = await prisma.empresa.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends EmpresaUpdateManyArgs>(args: SelectSubset<T, EmpresaUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Empresa.
     * @param {EmpresaUpsertArgs} args - Arguments to update or create a Empresa.
     * @example
     * // Update or create a Empresa
     * const empresa = await prisma.empresa.upsert({
     *   create: {
     *     // ... data to create a Empresa
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Empresa we want to update
     *   }
     * })
     */
    upsert<T extends EmpresaUpsertArgs>(args: SelectSubset<T, EmpresaUpsertArgs<ExtArgs>>): Prisma__EmpresaClient<$Result.GetResult<Prisma.$EmpresaPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Empresas.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmpresaCountArgs} args - Arguments to filter Empresas to count.
     * @example
     * // Count the number of Empresas
     * const count = await prisma.empresa.count({
     *   where: {
     *     // ... the filter for the Empresas we want to count
     *   }
     * })
    **/
    count<T extends EmpresaCountArgs>(
      args?: Subset<T, EmpresaCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], EmpresaCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Empresa.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmpresaAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends EmpresaAggregateArgs>(args: Subset<T, EmpresaAggregateArgs>): Prisma.PrismaPromise<GetEmpresaAggregateType<T>>

    /**
     * Group by Empresa.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmpresaGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends EmpresaGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: EmpresaGroupByArgs['orderBy'] }
        : { orderBy?: EmpresaGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, EmpresaGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetEmpresaGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Empresa model
   */
  readonly fields: EmpresaFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Empresa.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__EmpresaClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    filiais<T extends Empresa$filiaisArgs<ExtArgs> = {}>(args?: Subset<T, Empresa$filiaisArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FilialPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Empresa model
   */ 
  interface EmpresaFieldRefs {
    readonly id: FieldRef<"Empresa", 'Int'>
    readonly razaoSocial: FieldRef<"Empresa", 'String'>
    readonly nomeFantasia: FieldRef<"Empresa", 'String'>
    readonly cnpjMatriz: FieldRef<"Empresa", 'String'>
    readonly inscricaoEstadual: FieldRef<"Empresa", 'String'>
    readonly cidade: FieldRef<"Empresa", 'String'>
    readonly estado: FieldRef<"Empresa", 'String'>
    readonly logradouro: FieldRef<"Empresa", 'String'>
    readonly numero: FieldRef<"Empresa", 'String'>
    readonly bairro: FieldRef<"Empresa", 'String'>
    readonly cep: FieldRef<"Empresa", 'String'>
    readonly telefone: FieldRef<"Empresa", 'String'>
    readonly email: FieldRef<"Empresa", 'String'>
    readonly ativo: FieldRef<"Empresa", 'Boolean'>
    readonly dataCriacao: FieldRef<"Empresa", 'DateTime'>
    readonly dataAtualizacao: FieldRef<"Empresa", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Empresa findUnique
   */
  export type EmpresaFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Empresa
     */
    select?: EmpresaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmpresaInclude<ExtArgs> | null
    /**
     * Filter, which Empresa to fetch.
     */
    where: EmpresaWhereUniqueInput
  }

  /**
   * Empresa findUniqueOrThrow
   */
  export type EmpresaFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Empresa
     */
    select?: EmpresaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmpresaInclude<ExtArgs> | null
    /**
     * Filter, which Empresa to fetch.
     */
    where: EmpresaWhereUniqueInput
  }

  /**
   * Empresa findFirst
   */
  export type EmpresaFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Empresa
     */
    select?: EmpresaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmpresaInclude<ExtArgs> | null
    /**
     * Filter, which Empresa to fetch.
     */
    where?: EmpresaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Empresas to fetch.
     */
    orderBy?: EmpresaOrderByWithRelationInput | EmpresaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Empresas.
     */
    cursor?: EmpresaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Empresas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Empresas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Empresas.
     */
    distinct?: EmpresaScalarFieldEnum | EmpresaScalarFieldEnum[]
  }

  /**
   * Empresa findFirstOrThrow
   */
  export type EmpresaFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Empresa
     */
    select?: EmpresaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmpresaInclude<ExtArgs> | null
    /**
     * Filter, which Empresa to fetch.
     */
    where?: EmpresaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Empresas to fetch.
     */
    orderBy?: EmpresaOrderByWithRelationInput | EmpresaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Empresas.
     */
    cursor?: EmpresaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Empresas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Empresas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Empresas.
     */
    distinct?: EmpresaScalarFieldEnum | EmpresaScalarFieldEnum[]
  }

  /**
   * Empresa findMany
   */
  export type EmpresaFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Empresa
     */
    select?: EmpresaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmpresaInclude<ExtArgs> | null
    /**
     * Filter, which Empresas to fetch.
     */
    where?: EmpresaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Empresas to fetch.
     */
    orderBy?: EmpresaOrderByWithRelationInput | EmpresaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Empresas.
     */
    cursor?: EmpresaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Empresas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Empresas.
     */
    skip?: number
    distinct?: EmpresaScalarFieldEnum | EmpresaScalarFieldEnum[]
  }

  /**
   * Empresa create
   */
  export type EmpresaCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Empresa
     */
    select?: EmpresaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmpresaInclude<ExtArgs> | null
    /**
     * The data needed to create a Empresa.
     */
    data: XOR<EmpresaCreateInput, EmpresaUncheckedCreateInput>
  }

  /**
   * Empresa createMany
   */
  export type EmpresaCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Empresas.
     */
    data: EmpresaCreateManyInput | EmpresaCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Empresa update
   */
  export type EmpresaUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Empresa
     */
    select?: EmpresaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmpresaInclude<ExtArgs> | null
    /**
     * The data needed to update a Empresa.
     */
    data: XOR<EmpresaUpdateInput, EmpresaUncheckedUpdateInput>
    /**
     * Choose, which Empresa to update.
     */
    where: EmpresaWhereUniqueInput
  }

  /**
   * Empresa updateMany
   */
  export type EmpresaUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Empresas.
     */
    data: XOR<EmpresaUpdateManyMutationInput, EmpresaUncheckedUpdateManyInput>
    /**
     * Filter which Empresas to update
     */
    where?: EmpresaWhereInput
  }

  /**
   * Empresa upsert
   */
  export type EmpresaUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Empresa
     */
    select?: EmpresaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmpresaInclude<ExtArgs> | null
    /**
     * The filter to search for the Empresa to update in case it exists.
     */
    where: EmpresaWhereUniqueInput
    /**
     * In case the Empresa found by the `where` argument doesn't exist, create a new Empresa with this data.
     */
    create: XOR<EmpresaCreateInput, EmpresaUncheckedCreateInput>
    /**
     * In case the Empresa was found with the provided `where` argument, update it with this data.
     */
    update: XOR<EmpresaUpdateInput, EmpresaUncheckedUpdateInput>
  }

  /**
   * Empresa delete
   */
  export type EmpresaDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Empresa
     */
    select?: EmpresaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmpresaInclude<ExtArgs> | null
    /**
     * Filter which Empresa to delete.
     */
    where: EmpresaWhereUniqueInput
  }

  /**
   * Empresa deleteMany
   */
  export type EmpresaDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Empresas to delete
     */
    where?: EmpresaWhereInput
  }

  /**
   * Empresa.filiais
   */
  export type Empresa$filiaisArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Filial
     */
    select?: FilialSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FilialInclude<ExtArgs> | null
    where?: FilialWhereInput
    orderBy?: FilialOrderByWithRelationInput | FilialOrderByWithRelationInput[]
    cursor?: FilialWhereUniqueInput
    take?: number
    skip?: number
    distinct?: FilialScalarFieldEnum | FilialScalarFieldEnum[]
  }

  /**
   * Empresa without action
   */
  export type EmpresaDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Empresa
     */
    select?: EmpresaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmpresaInclude<ExtArgs> | null
  }


  /**
   * Model Cliente
   */

  export type AggregateCliente = {
    _count: ClienteCountAggregateOutputType | null
    _avg: ClienteAvgAggregateOutputType | null
    _sum: ClienteSumAggregateOutputType | null
    _min: ClienteMinAggregateOutputType | null
    _max: ClienteMaxAggregateOutputType | null
  }

  export type ClienteAvgAggregateOutputType = {
    id: number | null
  }

  export type ClienteSumAggregateOutputType = {
    id: number | null
  }

  export type ClienteMinAggregateOutputType = {
    id: number | null
    nome: string | null
    cpfCnpj: string | null
    cidade: string | null
    estado: string | null
    logradouro: string | null
    numero: string | null
    bairro: string | null
    cep: string | null
    telefone: string | null
  }

  export type ClienteMaxAggregateOutputType = {
    id: number | null
    nome: string | null
    cpfCnpj: string | null
    cidade: string | null
    estado: string | null
    logradouro: string | null
    numero: string | null
    bairro: string | null
    cep: string | null
    telefone: string | null
  }

  export type ClienteCountAggregateOutputType = {
    id: number
    nome: number
    cpfCnpj: number
    cidade: number
    estado: number
    logradouro: number
    numero: number
    bairro: number
    cep: number
    telefone: number
    _all: number
  }


  export type ClienteAvgAggregateInputType = {
    id?: true
  }

  export type ClienteSumAggregateInputType = {
    id?: true
  }

  export type ClienteMinAggregateInputType = {
    id?: true
    nome?: true
    cpfCnpj?: true
    cidade?: true
    estado?: true
    logradouro?: true
    numero?: true
    bairro?: true
    cep?: true
    telefone?: true
  }

  export type ClienteMaxAggregateInputType = {
    id?: true
    nome?: true
    cpfCnpj?: true
    cidade?: true
    estado?: true
    logradouro?: true
    numero?: true
    bairro?: true
    cep?: true
    telefone?: true
  }

  export type ClienteCountAggregateInputType = {
    id?: true
    nome?: true
    cpfCnpj?: true
    cidade?: true
    estado?: true
    logradouro?: true
    numero?: true
    bairro?: true
    cep?: true
    telefone?: true
    _all?: true
  }

  export type ClienteAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Cliente to aggregate.
     */
    where?: ClienteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Clientes to fetch.
     */
    orderBy?: ClienteOrderByWithRelationInput | ClienteOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ClienteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Clientes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Clientes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Clientes
    **/
    _count?: true | ClienteCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ClienteAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ClienteSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ClienteMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ClienteMaxAggregateInputType
  }

  export type GetClienteAggregateType<T extends ClienteAggregateArgs> = {
        [P in keyof T & keyof AggregateCliente]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCliente[P]>
      : GetScalarType<T[P], AggregateCliente[P]>
  }




  export type ClienteGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ClienteWhereInput
    orderBy?: ClienteOrderByWithAggregationInput | ClienteOrderByWithAggregationInput[]
    by: ClienteScalarFieldEnum[] | ClienteScalarFieldEnum
    having?: ClienteScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ClienteCountAggregateInputType | true
    _avg?: ClienteAvgAggregateInputType
    _sum?: ClienteSumAggregateInputType
    _min?: ClienteMinAggregateInputType
    _max?: ClienteMaxAggregateInputType
  }

  export type ClienteGroupByOutputType = {
    id: number
    nome: string
    cpfCnpj: string
    cidade: string | null
    estado: string | null
    logradouro: string | null
    numero: string | null
    bairro: string | null
    cep: string | null
    telefone: string | null
    _count: ClienteCountAggregateOutputType | null
    _avg: ClienteAvgAggregateOutputType | null
    _sum: ClienteSumAggregateOutputType | null
    _min: ClienteMinAggregateOutputType | null
    _max: ClienteMaxAggregateOutputType | null
  }

  type GetClienteGroupByPayload<T extends ClienteGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ClienteGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ClienteGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ClienteGroupByOutputType[P]>
            : GetScalarType<T[P], ClienteGroupByOutputType[P]>
        }
      >
    >


  export type ClienteSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    nome?: boolean
    cpfCnpj?: boolean
    cidade?: boolean
    estado?: boolean
    logradouro?: boolean
    numero?: boolean
    bairro?: boolean
    cep?: boolean
    telefone?: boolean
    notasFiscais?: boolean | Cliente$notasFiscaisArgs<ExtArgs>
    _count?: boolean | ClienteCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["cliente"]>


  export type ClienteSelectScalar = {
    id?: boolean
    nome?: boolean
    cpfCnpj?: boolean
    cidade?: boolean
    estado?: boolean
    logradouro?: boolean
    numero?: boolean
    bairro?: boolean
    cep?: boolean
    telefone?: boolean
  }

  export type ClienteInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    notasFiscais?: boolean | Cliente$notasFiscaisArgs<ExtArgs>
    _count?: boolean | ClienteCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $ClientePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Cliente"
    objects: {
      notasFiscais: Prisma.$NotasFiscalCabecalhoPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      nome: string
      cpfCnpj: string
      cidade: string | null
      estado: string | null
      logradouro: string | null
      numero: string | null
      bairro: string | null
      cep: string | null
      telefone: string | null
    }, ExtArgs["result"]["cliente"]>
    composites: {}
  }

  type ClienteGetPayload<S extends boolean | null | undefined | ClienteDefaultArgs> = $Result.GetResult<Prisma.$ClientePayload, S>

  type ClienteCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ClienteFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ClienteCountAggregateInputType | true
    }

  export interface ClienteDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Cliente'], meta: { name: 'Cliente' } }
    /**
     * Find zero or one Cliente that matches the filter.
     * @param {ClienteFindUniqueArgs} args - Arguments to find a Cliente
     * @example
     * // Get one Cliente
     * const cliente = await prisma.cliente.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ClienteFindUniqueArgs>(args: SelectSubset<T, ClienteFindUniqueArgs<ExtArgs>>): Prisma__ClienteClient<$Result.GetResult<Prisma.$ClientePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Cliente that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {ClienteFindUniqueOrThrowArgs} args - Arguments to find a Cliente
     * @example
     * // Get one Cliente
     * const cliente = await prisma.cliente.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ClienteFindUniqueOrThrowArgs>(args: SelectSubset<T, ClienteFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ClienteClient<$Result.GetResult<Prisma.$ClientePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Cliente that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClienteFindFirstArgs} args - Arguments to find a Cliente
     * @example
     * // Get one Cliente
     * const cliente = await prisma.cliente.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ClienteFindFirstArgs>(args?: SelectSubset<T, ClienteFindFirstArgs<ExtArgs>>): Prisma__ClienteClient<$Result.GetResult<Prisma.$ClientePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Cliente that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClienteFindFirstOrThrowArgs} args - Arguments to find a Cliente
     * @example
     * // Get one Cliente
     * const cliente = await prisma.cliente.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ClienteFindFirstOrThrowArgs>(args?: SelectSubset<T, ClienteFindFirstOrThrowArgs<ExtArgs>>): Prisma__ClienteClient<$Result.GetResult<Prisma.$ClientePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Clientes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClienteFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Clientes
     * const clientes = await prisma.cliente.findMany()
     * 
     * // Get first 10 Clientes
     * const clientes = await prisma.cliente.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const clienteWithIdOnly = await prisma.cliente.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ClienteFindManyArgs>(args?: SelectSubset<T, ClienteFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ClientePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Cliente.
     * @param {ClienteCreateArgs} args - Arguments to create a Cliente.
     * @example
     * // Create one Cliente
     * const Cliente = await prisma.cliente.create({
     *   data: {
     *     // ... data to create a Cliente
     *   }
     * })
     * 
     */
    create<T extends ClienteCreateArgs>(args: SelectSubset<T, ClienteCreateArgs<ExtArgs>>): Prisma__ClienteClient<$Result.GetResult<Prisma.$ClientePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Clientes.
     * @param {ClienteCreateManyArgs} args - Arguments to create many Clientes.
     * @example
     * // Create many Clientes
     * const cliente = await prisma.cliente.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ClienteCreateManyArgs>(args?: SelectSubset<T, ClienteCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Cliente.
     * @param {ClienteDeleteArgs} args - Arguments to delete one Cliente.
     * @example
     * // Delete one Cliente
     * const Cliente = await prisma.cliente.delete({
     *   where: {
     *     // ... filter to delete one Cliente
     *   }
     * })
     * 
     */
    delete<T extends ClienteDeleteArgs>(args: SelectSubset<T, ClienteDeleteArgs<ExtArgs>>): Prisma__ClienteClient<$Result.GetResult<Prisma.$ClientePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Cliente.
     * @param {ClienteUpdateArgs} args - Arguments to update one Cliente.
     * @example
     * // Update one Cliente
     * const cliente = await prisma.cliente.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ClienteUpdateArgs>(args: SelectSubset<T, ClienteUpdateArgs<ExtArgs>>): Prisma__ClienteClient<$Result.GetResult<Prisma.$ClientePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Clientes.
     * @param {ClienteDeleteManyArgs} args - Arguments to filter Clientes to delete.
     * @example
     * // Delete a few Clientes
     * const { count } = await prisma.cliente.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ClienteDeleteManyArgs>(args?: SelectSubset<T, ClienteDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Clientes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClienteUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Clientes
     * const cliente = await prisma.cliente.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ClienteUpdateManyArgs>(args: SelectSubset<T, ClienteUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Cliente.
     * @param {ClienteUpsertArgs} args - Arguments to update or create a Cliente.
     * @example
     * // Update or create a Cliente
     * const cliente = await prisma.cliente.upsert({
     *   create: {
     *     // ... data to create a Cliente
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Cliente we want to update
     *   }
     * })
     */
    upsert<T extends ClienteUpsertArgs>(args: SelectSubset<T, ClienteUpsertArgs<ExtArgs>>): Prisma__ClienteClient<$Result.GetResult<Prisma.$ClientePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Clientes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClienteCountArgs} args - Arguments to filter Clientes to count.
     * @example
     * // Count the number of Clientes
     * const count = await prisma.cliente.count({
     *   where: {
     *     // ... the filter for the Clientes we want to count
     *   }
     * })
    **/
    count<T extends ClienteCountArgs>(
      args?: Subset<T, ClienteCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ClienteCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Cliente.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClienteAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ClienteAggregateArgs>(args: Subset<T, ClienteAggregateArgs>): Prisma.PrismaPromise<GetClienteAggregateType<T>>

    /**
     * Group by Cliente.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClienteGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ClienteGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ClienteGroupByArgs['orderBy'] }
        : { orderBy?: ClienteGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ClienteGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetClienteGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Cliente model
   */
  readonly fields: ClienteFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Cliente.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ClienteClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    notasFiscais<T extends Cliente$notasFiscaisArgs<ExtArgs> = {}>(args?: Subset<T, Cliente$notasFiscaisArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotasFiscalCabecalhoPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Cliente model
   */ 
  interface ClienteFieldRefs {
    readonly id: FieldRef<"Cliente", 'Int'>
    readonly nome: FieldRef<"Cliente", 'String'>
    readonly cpfCnpj: FieldRef<"Cliente", 'String'>
    readonly cidade: FieldRef<"Cliente", 'String'>
    readonly estado: FieldRef<"Cliente", 'String'>
    readonly logradouro: FieldRef<"Cliente", 'String'>
    readonly numero: FieldRef<"Cliente", 'String'>
    readonly bairro: FieldRef<"Cliente", 'String'>
    readonly cep: FieldRef<"Cliente", 'String'>
    readonly telefone: FieldRef<"Cliente", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Cliente findUnique
   */
  export type ClienteFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Cliente
     */
    select?: ClienteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClienteInclude<ExtArgs> | null
    /**
     * Filter, which Cliente to fetch.
     */
    where: ClienteWhereUniqueInput
  }

  /**
   * Cliente findUniqueOrThrow
   */
  export type ClienteFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Cliente
     */
    select?: ClienteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClienteInclude<ExtArgs> | null
    /**
     * Filter, which Cliente to fetch.
     */
    where: ClienteWhereUniqueInput
  }

  /**
   * Cliente findFirst
   */
  export type ClienteFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Cliente
     */
    select?: ClienteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClienteInclude<ExtArgs> | null
    /**
     * Filter, which Cliente to fetch.
     */
    where?: ClienteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Clientes to fetch.
     */
    orderBy?: ClienteOrderByWithRelationInput | ClienteOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Clientes.
     */
    cursor?: ClienteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Clientes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Clientes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Clientes.
     */
    distinct?: ClienteScalarFieldEnum | ClienteScalarFieldEnum[]
  }

  /**
   * Cliente findFirstOrThrow
   */
  export type ClienteFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Cliente
     */
    select?: ClienteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClienteInclude<ExtArgs> | null
    /**
     * Filter, which Cliente to fetch.
     */
    where?: ClienteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Clientes to fetch.
     */
    orderBy?: ClienteOrderByWithRelationInput | ClienteOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Clientes.
     */
    cursor?: ClienteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Clientes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Clientes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Clientes.
     */
    distinct?: ClienteScalarFieldEnum | ClienteScalarFieldEnum[]
  }

  /**
   * Cliente findMany
   */
  export type ClienteFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Cliente
     */
    select?: ClienteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClienteInclude<ExtArgs> | null
    /**
     * Filter, which Clientes to fetch.
     */
    where?: ClienteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Clientes to fetch.
     */
    orderBy?: ClienteOrderByWithRelationInput | ClienteOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Clientes.
     */
    cursor?: ClienteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Clientes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Clientes.
     */
    skip?: number
    distinct?: ClienteScalarFieldEnum | ClienteScalarFieldEnum[]
  }

  /**
   * Cliente create
   */
  export type ClienteCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Cliente
     */
    select?: ClienteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClienteInclude<ExtArgs> | null
    /**
     * The data needed to create a Cliente.
     */
    data: XOR<ClienteCreateInput, ClienteUncheckedCreateInput>
  }

  /**
   * Cliente createMany
   */
  export type ClienteCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Clientes.
     */
    data: ClienteCreateManyInput | ClienteCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Cliente update
   */
  export type ClienteUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Cliente
     */
    select?: ClienteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClienteInclude<ExtArgs> | null
    /**
     * The data needed to update a Cliente.
     */
    data: XOR<ClienteUpdateInput, ClienteUncheckedUpdateInput>
    /**
     * Choose, which Cliente to update.
     */
    where: ClienteWhereUniqueInput
  }

  /**
   * Cliente updateMany
   */
  export type ClienteUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Clientes.
     */
    data: XOR<ClienteUpdateManyMutationInput, ClienteUncheckedUpdateManyInput>
    /**
     * Filter which Clientes to update
     */
    where?: ClienteWhereInput
  }

  /**
   * Cliente upsert
   */
  export type ClienteUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Cliente
     */
    select?: ClienteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClienteInclude<ExtArgs> | null
    /**
     * The filter to search for the Cliente to update in case it exists.
     */
    where: ClienteWhereUniqueInput
    /**
     * In case the Cliente found by the `where` argument doesn't exist, create a new Cliente with this data.
     */
    create: XOR<ClienteCreateInput, ClienteUncheckedCreateInput>
    /**
     * In case the Cliente was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ClienteUpdateInput, ClienteUncheckedUpdateInput>
  }

  /**
   * Cliente delete
   */
  export type ClienteDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Cliente
     */
    select?: ClienteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClienteInclude<ExtArgs> | null
    /**
     * Filter which Cliente to delete.
     */
    where: ClienteWhereUniqueInput
  }

  /**
   * Cliente deleteMany
   */
  export type ClienteDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Clientes to delete
     */
    where?: ClienteWhereInput
  }

  /**
   * Cliente.notasFiscais
   */
  export type Cliente$notasFiscaisArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NotasFiscalCabecalho
     */
    select?: NotasFiscalCabecalhoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotasFiscalCabecalhoInclude<ExtArgs> | null
    where?: NotasFiscalCabecalhoWhereInput
    orderBy?: NotasFiscalCabecalhoOrderByWithRelationInput | NotasFiscalCabecalhoOrderByWithRelationInput[]
    cursor?: NotasFiscalCabecalhoWhereUniqueInput
    take?: number
    skip?: number
    distinct?: NotasFiscalCabecalhoScalarFieldEnum | NotasFiscalCabecalhoScalarFieldEnum[]
  }

  /**
   * Cliente without action
   */
  export type ClienteDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Cliente
     */
    select?: ClienteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClienteInclude<ExtArgs> | null
  }


  /**
   * Model Filial
   */

  export type AggregateFilial = {
    _count: FilialCountAggregateOutputType | null
    _avg: FilialAvgAggregateOutputType | null
    _sum: FilialSumAggregateOutputType | null
    _min: FilialMinAggregateOutputType | null
    _max: FilialMaxAggregateOutputType | null
  }

  export type FilialAvgAggregateOutputType = {
    id: number | null
    empresaId: number | null
  }

  export type FilialSumAggregateOutputType = {
    id: number | null
    empresaId: number | null
  }

  export type FilialMinAggregateOutputType = {
    id: number | null
    empresaId: number | null
    nome: string | null
    cnpj: string | null
    cidade: string | null
    estado: string | null
  }

  export type FilialMaxAggregateOutputType = {
    id: number | null
    empresaId: number | null
    nome: string | null
    cnpj: string | null
    cidade: string | null
    estado: string | null
  }

  export type FilialCountAggregateOutputType = {
    id: number
    empresaId: number
    nome: number
    cnpj: number
    cidade: number
    estado: number
    _all: number
  }


  export type FilialAvgAggregateInputType = {
    id?: true
    empresaId?: true
  }

  export type FilialSumAggregateInputType = {
    id?: true
    empresaId?: true
  }

  export type FilialMinAggregateInputType = {
    id?: true
    empresaId?: true
    nome?: true
    cnpj?: true
    cidade?: true
    estado?: true
  }

  export type FilialMaxAggregateInputType = {
    id?: true
    empresaId?: true
    nome?: true
    cnpj?: true
    cidade?: true
    estado?: true
  }

  export type FilialCountAggregateInputType = {
    id?: true
    empresaId?: true
    nome?: true
    cnpj?: true
    cidade?: true
    estado?: true
    _all?: true
  }

  export type FilialAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Filial to aggregate.
     */
    where?: FilialWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Filials to fetch.
     */
    orderBy?: FilialOrderByWithRelationInput | FilialOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: FilialWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Filials from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Filials.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Filials
    **/
    _count?: true | FilialCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: FilialAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: FilialSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: FilialMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: FilialMaxAggregateInputType
  }

  export type GetFilialAggregateType<T extends FilialAggregateArgs> = {
        [P in keyof T & keyof AggregateFilial]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateFilial[P]>
      : GetScalarType<T[P], AggregateFilial[P]>
  }




  export type FilialGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FilialWhereInput
    orderBy?: FilialOrderByWithAggregationInput | FilialOrderByWithAggregationInput[]
    by: FilialScalarFieldEnum[] | FilialScalarFieldEnum
    having?: FilialScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: FilialCountAggregateInputType | true
    _avg?: FilialAvgAggregateInputType
    _sum?: FilialSumAggregateInputType
    _min?: FilialMinAggregateInputType
    _max?: FilialMaxAggregateInputType
  }

  export type FilialGroupByOutputType = {
    id: number
    empresaId: number
    nome: string
    cnpj: string
    cidade: string | null
    estado: string | null
    _count: FilialCountAggregateOutputType | null
    _avg: FilialAvgAggregateOutputType | null
    _sum: FilialSumAggregateOutputType | null
    _min: FilialMinAggregateOutputType | null
    _max: FilialMaxAggregateOutputType | null
  }

  type GetFilialGroupByPayload<T extends FilialGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<FilialGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof FilialGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], FilialGroupByOutputType[P]>
            : GetScalarType<T[P], FilialGroupByOutputType[P]>
        }
      >
    >


  export type FilialSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    empresaId?: boolean
    nome?: boolean
    cnpj?: boolean
    cidade?: boolean
    estado?: boolean
    empresa?: boolean | EmpresaDefaultArgs<ExtArgs>
    notasFiscais?: boolean | Filial$notasFiscaisArgs<ExtArgs>
    vendedores?: boolean | Filial$vendedoresArgs<ExtArgs>
    rfvParameterSets?: boolean | Filial$rfvParameterSetsArgs<ExtArgs>
    maquinasEstoque?: boolean | Filial$maquinasEstoqueArgs<ExtArgs>
    _count?: boolean | FilialCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["filial"]>


  export type FilialSelectScalar = {
    id?: boolean
    empresaId?: boolean
    nome?: boolean
    cnpj?: boolean
    cidade?: boolean
    estado?: boolean
  }

  export type FilialInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    empresa?: boolean | EmpresaDefaultArgs<ExtArgs>
    notasFiscais?: boolean | Filial$notasFiscaisArgs<ExtArgs>
    vendedores?: boolean | Filial$vendedoresArgs<ExtArgs>
    rfvParameterSets?: boolean | Filial$rfvParameterSetsArgs<ExtArgs>
    maquinasEstoque?: boolean | Filial$maquinasEstoqueArgs<ExtArgs>
    _count?: boolean | FilialCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $FilialPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Filial"
    objects: {
      empresa: Prisma.$EmpresaPayload<ExtArgs>
      notasFiscais: Prisma.$NotasFiscalCabecalhoPayload<ExtArgs>[]
      vendedores: Prisma.$VendedorPayload<ExtArgs>[]
      rfvParameterSets: Prisma.$RfvParameterSetPayload<ExtArgs>[]
      maquinasEstoque: Prisma.$MaquinaEstoquePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      empresaId: number
      nome: string
      cnpj: string
      cidade: string | null
      estado: string | null
    }, ExtArgs["result"]["filial"]>
    composites: {}
  }

  type FilialGetPayload<S extends boolean | null | undefined | FilialDefaultArgs> = $Result.GetResult<Prisma.$FilialPayload, S>

  type FilialCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<FilialFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: FilialCountAggregateInputType | true
    }

  export interface FilialDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Filial'], meta: { name: 'Filial' } }
    /**
     * Find zero or one Filial that matches the filter.
     * @param {FilialFindUniqueArgs} args - Arguments to find a Filial
     * @example
     * // Get one Filial
     * const filial = await prisma.filial.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends FilialFindUniqueArgs>(args: SelectSubset<T, FilialFindUniqueArgs<ExtArgs>>): Prisma__FilialClient<$Result.GetResult<Prisma.$FilialPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Filial that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {FilialFindUniqueOrThrowArgs} args - Arguments to find a Filial
     * @example
     * // Get one Filial
     * const filial = await prisma.filial.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends FilialFindUniqueOrThrowArgs>(args: SelectSubset<T, FilialFindUniqueOrThrowArgs<ExtArgs>>): Prisma__FilialClient<$Result.GetResult<Prisma.$FilialPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Filial that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FilialFindFirstArgs} args - Arguments to find a Filial
     * @example
     * // Get one Filial
     * const filial = await prisma.filial.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends FilialFindFirstArgs>(args?: SelectSubset<T, FilialFindFirstArgs<ExtArgs>>): Prisma__FilialClient<$Result.GetResult<Prisma.$FilialPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Filial that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FilialFindFirstOrThrowArgs} args - Arguments to find a Filial
     * @example
     * // Get one Filial
     * const filial = await prisma.filial.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends FilialFindFirstOrThrowArgs>(args?: SelectSubset<T, FilialFindFirstOrThrowArgs<ExtArgs>>): Prisma__FilialClient<$Result.GetResult<Prisma.$FilialPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Filials that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FilialFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Filials
     * const filials = await prisma.filial.findMany()
     * 
     * // Get first 10 Filials
     * const filials = await prisma.filial.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const filialWithIdOnly = await prisma.filial.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends FilialFindManyArgs>(args?: SelectSubset<T, FilialFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FilialPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Filial.
     * @param {FilialCreateArgs} args - Arguments to create a Filial.
     * @example
     * // Create one Filial
     * const Filial = await prisma.filial.create({
     *   data: {
     *     // ... data to create a Filial
     *   }
     * })
     * 
     */
    create<T extends FilialCreateArgs>(args: SelectSubset<T, FilialCreateArgs<ExtArgs>>): Prisma__FilialClient<$Result.GetResult<Prisma.$FilialPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Filials.
     * @param {FilialCreateManyArgs} args - Arguments to create many Filials.
     * @example
     * // Create many Filials
     * const filial = await prisma.filial.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends FilialCreateManyArgs>(args?: SelectSubset<T, FilialCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Filial.
     * @param {FilialDeleteArgs} args - Arguments to delete one Filial.
     * @example
     * // Delete one Filial
     * const Filial = await prisma.filial.delete({
     *   where: {
     *     // ... filter to delete one Filial
     *   }
     * })
     * 
     */
    delete<T extends FilialDeleteArgs>(args: SelectSubset<T, FilialDeleteArgs<ExtArgs>>): Prisma__FilialClient<$Result.GetResult<Prisma.$FilialPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Filial.
     * @param {FilialUpdateArgs} args - Arguments to update one Filial.
     * @example
     * // Update one Filial
     * const filial = await prisma.filial.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends FilialUpdateArgs>(args: SelectSubset<T, FilialUpdateArgs<ExtArgs>>): Prisma__FilialClient<$Result.GetResult<Prisma.$FilialPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Filials.
     * @param {FilialDeleteManyArgs} args - Arguments to filter Filials to delete.
     * @example
     * // Delete a few Filials
     * const { count } = await prisma.filial.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends FilialDeleteManyArgs>(args?: SelectSubset<T, FilialDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Filials.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FilialUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Filials
     * const filial = await prisma.filial.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends FilialUpdateManyArgs>(args: SelectSubset<T, FilialUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Filial.
     * @param {FilialUpsertArgs} args - Arguments to update or create a Filial.
     * @example
     * // Update or create a Filial
     * const filial = await prisma.filial.upsert({
     *   create: {
     *     // ... data to create a Filial
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Filial we want to update
     *   }
     * })
     */
    upsert<T extends FilialUpsertArgs>(args: SelectSubset<T, FilialUpsertArgs<ExtArgs>>): Prisma__FilialClient<$Result.GetResult<Prisma.$FilialPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Filials.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FilialCountArgs} args - Arguments to filter Filials to count.
     * @example
     * // Count the number of Filials
     * const count = await prisma.filial.count({
     *   where: {
     *     // ... the filter for the Filials we want to count
     *   }
     * })
    **/
    count<T extends FilialCountArgs>(
      args?: Subset<T, FilialCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], FilialCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Filial.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FilialAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends FilialAggregateArgs>(args: Subset<T, FilialAggregateArgs>): Prisma.PrismaPromise<GetFilialAggregateType<T>>

    /**
     * Group by Filial.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FilialGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends FilialGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: FilialGroupByArgs['orderBy'] }
        : { orderBy?: FilialGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, FilialGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetFilialGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Filial model
   */
  readonly fields: FilialFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Filial.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__FilialClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    empresa<T extends EmpresaDefaultArgs<ExtArgs> = {}>(args?: Subset<T, EmpresaDefaultArgs<ExtArgs>>): Prisma__EmpresaClient<$Result.GetResult<Prisma.$EmpresaPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    notasFiscais<T extends Filial$notasFiscaisArgs<ExtArgs> = {}>(args?: Subset<T, Filial$notasFiscaisArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotasFiscalCabecalhoPayload<ExtArgs>, T, "findMany"> | Null>
    vendedores<T extends Filial$vendedoresArgs<ExtArgs> = {}>(args?: Subset<T, Filial$vendedoresArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VendedorPayload<ExtArgs>, T, "findMany"> | Null>
    rfvParameterSets<T extends Filial$rfvParameterSetsArgs<ExtArgs> = {}>(args?: Subset<T, Filial$rfvParameterSetsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RfvParameterSetPayload<ExtArgs>, T, "findMany"> | Null>
    maquinasEstoque<T extends Filial$maquinasEstoqueArgs<ExtArgs> = {}>(args?: Subset<T, Filial$maquinasEstoqueArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MaquinaEstoquePayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Filial model
   */ 
  interface FilialFieldRefs {
    readonly id: FieldRef<"Filial", 'Int'>
    readonly empresaId: FieldRef<"Filial", 'Int'>
    readonly nome: FieldRef<"Filial", 'String'>
    readonly cnpj: FieldRef<"Filial", 'String'>
    readonly cidade: FieldRef<"Filial", 'String'>
    readonly estado: FieldRef<"Filial", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Filial findUnique
   */
  export type FilialFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Filial
     */
    select?: FilialSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FilialInclude<ExtArgs> | null
    /**
     * Filter, which Filial to fetch.
     */
    where: FilialWhereUniqueInput
  }

  /**
   * Filial findUniqueOrThrow
   */
  export type FilialFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Filial
     */
    select?: FilialSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FilialInclude<ExtArgs> | null
    /**
     * Filter, which Filial to fetch.
     */
    where: FilialWhereUniqueInput
  }

  /**
   * Filial findFirst
   */
  export type FilialFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Filial
     */
    select?: FilialSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FilialInclude<ExtArgs> | null
    /**
     * Filter, which Filial to fetch.
     */
    where?: FilialWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Filials to fetch.
     */
    orderBy?: FilialOrderByWithRelationInput | FilialOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Filials.
     */
    cursor?: FilialWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Filials from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Filials.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Filials.
     */
    distinct?: FilialScalarFieldEnum | FilialScalarFieldEnum[]
  }

  /**
   * Filial findFirstOrThrow
   */
  export type FilialFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Filial
     */
    select?: FilialSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FilialInclude<ExtArgs> | null
    /**
     * Filter, which Filial to fetch.
     */
    where?: FilialWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Filials to fetch.
     */
    orderBy?: FilialOrderByWithRelationInput | FilialOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Filials.
     */
    cursor?: FilialWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Filials from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Filials.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Filials.
     */
    distinct?: FilialScalarFieldEnum | FilialScalarFieldEnum[]
  }

  /**
   * Filial findMany
   */
  export type FilialFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Filial
     */
    select?: FilialSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FilialInclude<ExtArgs> | null
    /**
     * Filter, which Filials to fetch.
     */
    where?: FilialWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Filials to fetch.
     */
    orderBy?: FilialOrderByWithRelationInput | FilialOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Filials.
     */
    cursor?: FilialWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Filials from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Filials.
     */
    skip?: number
    distinct?: FilialScalarFieldEnum | FilialScalarFieldEnum[]
  }

  /**
   * Filial create
   */
  export type FilialCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Filial
     */
    select?: FilialSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FilialInclude<ExtArgs> | null
    /**
     * The data needed to create a Filial.
     */
    data: XOR<FilialCreateInput, FilialUncheckedCreateInput>
  }

  /**
   * Filial createMany
   */
  export type FilialCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Filials.
     */
    data: FilialCreateManyInput | FilialCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Filial update
   */
  export type FilialUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Filial
     */
    select?: FilialSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FilialInclude<ExtArgs> | null
    /**
     * The data needed to update a Filial.
     */
    data: XOR<FilialUpdateInput, FilialUncheckedUpdateInput>
    /**
     * Choose, which Filial to update.
     */
    where: FilialWhereUniqueInput
  }

  /**
   * Filial updateMany
   */
  export type FilialUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Filials.
     */
    data: XOR<FilialUpdateManyMutationInput, FilialUncheckedUpdateManyInput>
    /**
     * Filter which Filials to update
     */
    where?: FilialWhereInput
  }

  /**
   * Filial upsert
   */
  export type FilialUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Filial
     */
    select?: FilialSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FilialInclude<ExtArgs> | null
    /**
     * The filter to search for the Filial to update in case it exists.
     */
    where: FilialWhereUniqueInput
    /**
     * In case the Filial found by the `where` argument doesn't exist, create a new Filial with this data.
     */
    create: XOR<FilialCreateInput, FilialUncheckedCreateInput>
    /**
     * In case the Filial was found with the provided `where` argument, update it with this data.
     */
    update: XOR<FilialUpdateInput, FilialUncheckedUpdateInput>
  }

  /**
   * Filial delete
   */
  export type FilialDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Filial
     */
    select?: FilialSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FilialInclude<ExtArgs> | null
    /**
     * Filter which Filial to delete.
     */
    where: FilialWhereUniqueInput
  }

  /**
   * Filial deleteMany
   */
  export type FilialDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Filials to delete
     */
    where?: FilialWhereInput
  }

  /**
   * Filial.notasFiscais
   */
  export type Filial$notasFiscaisArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NotasFiscalCabecalho
     */
    select?: NotasFiscalCabecalhoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotasFiscalCabecalhoInclude<ExtArgs> | null
    where?: NotasFiscalCabecalhoWhereInput
    orderBy?: NotasFiscalCabecalhoOrderByWithRelationInput | NotasFiscalCabecalhoOrderByWithRelationInput[]
    cursor?: NotasFiscalCabecalhoWhereUniqueInput
    take?: number
    skip?: number
    distinct?: NotasFiscalCabecalhoScalarFieldEnum | NotasFiscalCabecalhoScalarFieldEnum[]
  }

  /**
   * Filial.vendedores
   */
  export type Filial$vendedoresArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Vendedor
     */
    select?: VendedorSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VendedorInclude<ExtArgs> | null
    where?: VendedorWhereInput
    orderBy?: VendedorOrderByWithRelationInput | VendedorOrderByWithRelationInput[]
    cursor?: VendedorWhereUniqueInput
    take?: number
    skip?: number
    distinct?: VendedorScalarFieldEnum | VendedorScalarFieldEnum[]
  }

  /**
   * Filial.rfvParameterSets
   */
  export type Filial$rfvParameterSetsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RfvParameterSet
     */
    select?: RfvParameterSetSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RfvParameterSetInclude<ExtArgs> | null
    where?: RfvParameterSetWhereInput
    orderBy?: RfvParameterSetOrderByWithRelationInput | RfvParameterSetOrderByWithRelationInput[]
    cursor?: RfvParameterSetWhereUniqueInput
    take?: number
    skip?: number
    distinct?: RfvParameterSetScalarFieldEnum | RfvParameterSetScalarFieldEnum[]
  }

  /**
   * Filial.maquinasEstoque
   */
  export type Filial$maquinasEstoqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MaquinaEstoque
     */
    select?: MaquinaEstoqueSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MaquinaEstoqueInclude<ExtArgs> | null
    where?: MaquinaEstoqueWhereInput
    orderBy?: MaquinaEstoqueOrderByWithRelationInput | MaquinaEstoqueOrderByWithRelationInput[]
    cursor?: MaquinaEstoqueWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MaquinaEstoqueScalarFieldEnum | MaquinaEstoqueScalarFieldEnum[]
  }

  /**
   * Filial without action
   */
  export type FilialDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Filial
     */
    select?: FilialSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FilialInclude<ExtArgs> | null
  }


  /**
   * Model Vendedor
   */

  export type AggregateVendedor = {
    _count: VendedorCountAggregateOutputType | null
    _avg: VendedorAvgAggregateOutputType | null
    _sum: VendedorSumAggregateOutputType | null
    _min: VendedorMinAggregateOutputType | null
    _max: VendedorMaxAggregateOutputType | null
  }

  export type VendedorAvgAggregateOutputType = {
    id: number | null
    filialId: number | null
  }

  export type VendedorSumAggregateOutputType = {
    id: number | null
    filialId: number | null
  }

  export type VendedorMinAggregateOutputType = {
    id: number | null
    nome: string | null
    cpf: string | null
    filialId: number | null
  }

  export type VendedorMaxAggregateOutputType = {
    id: number | null
    nome: string | null
    cpf: string | null
    filialId: number | null
  }

  export type VendedorCountAggregateOutputType = {
    id: number
    nome: number
    cpf: number
    filialId: number
    _all: number
  }


  export type VendedorAvgAggregateInputType = {
    id?: true
    filialId?: true
  }

  export type VendedorSumAggregateInputType = {
    id?: true
    filialId?: true
  }

  export type VendedorMinAggregateInputType = {
    id?: true
    nome?: true
    cpf?: true
    filialId?: true
  }

  export type VendedorMaxAggregateInputType = {
    id?: true
    nome?: true
    cpf?: true
    filialId?: true
  }

  export type VendedorCountAggregateInputType = {
    id?: true
    nome?: true
    cpf?: true
    filialId?: true
    _all?: true
  }

  export type VendedorAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Vendedor to aggregate.
     */
    where?: VendedorWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Vendedors to fetch.
     */
    orderBy?: VendedorOrderByWithRelationInput | VendedorOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: VendedorWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Vendedors from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Vendedors.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Vendedors
    **/
    _count?: true | VendedorCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: VendedorAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: VendedorSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: VendedorMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: VendedorMaxAggregateInputType
  }

  export type GetVendedorAggregateType<T extends VendedorAggregateArgs> = {
        [P in keyof T & keyof AggregateVendedor]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateVendedor[P]>
      : GetScalarType<T[P], AggregateVendedor[P]>
  }




  export type VendedorGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: VendedorWhereInput
    orderBy?: VendedorOrderByWithAggregationInput | VendedorOrderByWithAggregationInput[]
    by: VendedorScalarFieldEnum[] | VendedorScalarFieldEnum
    having?: VendedorScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: VendedorCountAggregateInputType | true
    _avg?: VendedorAvgAggregateInputType
    _sum?: VendedorSumAggregateInputType
    _min?: VendedorMinAggregateInputType
    _max?: VendedorMaxAggregateInputType
  }

  export type VendedorGroupByOutputType = {
    id: number
    nome: string
    cpf: string
    filialId: number | null
    _count: VendedorCountAggregateOutputType | null
    _avg: VendedorAvgAggregateOutputType | null
    _sum: VendedorSumAggregateOutputType | null
    _min: VendedorMinAggregateOutputType | null
    _max: VendedorMaxAggregateOutputType | null
  }

  type GetVendedorGroupByPayload<T extends VendedorGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<VendedorGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof VendedorGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], VendedorGroupByOutputType[P]>
            : GetScalarType<T[P], VendedorGroupByOutputType[P]>
        }
      >
    >


  export type VendedorSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    nome?: boolean
    cpf?: boolean
    filialId?: boolean
    notasFiscais?: boolean | Vendedor$notasFiscaisArgs<ExtArgs>
    filial?: boolean | Vendedor$filialArgs<ExtArgs>
    _count?: boolean | VendedorCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["vendedor"]>


  export type VendedorSelectScalar = {
    id?: boolean
    nome?: boolean
    cpf?: boolean
    filialId?: boolean
  }

  export type VendedorInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    notasFiscais?: boolean | Vendedor$notasFiscaisArgs<ExtArgs>
    filial?: boolean | Vendedor$filialArgs<ExtArgs>
    _count?: boolean | VendedorCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $VendedorPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Vendedor"
    objects: {
      notasFiscais: Prisma.$NotasFiscalCabecalhoPayload<ExtArgs>[]
      filial: Prisma.$FilialPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      nome: string
      cpf: string
      filialId: number | null
    }, ExtArgs["result"]["vendedor"]>
    composites: {}
  }

  type VendedorGetPayload<S extends boolean | null | undefined | VendedorDefaultArgs> = $Result.GetResult<Prisma.$VendedorPayload, S>

  type VendedorCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<VendedorFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: VendedorCountAggregateInputType | true
    }

  export interface VendedorDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Vendedor'], meta: { name: 'Vendedor' } }
    /**
     * Find zero or one Vendedor that matches the filter.
     * @param {VendedorFindUniqueArgs} args - Arguments to find a Vendedor
     * @example
     * // Get one Vendedor
     * const vendedor = await prisma.vendedor.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends VendedorFindUniqueArgs>(args: SelectSubset<T, VendedorFindUniqueArgs<ExtArgs>>): Prisma__VendedorClient<$Result.GetResult<Prisma.$VendedorPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Vendedor that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {VendedorFindUniqueOrThrowArgs} args - Arguments to find a Vendedor
     * @example
     * // Get one Vendedor
     * const vendedor = await prisma.vendedor.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends VendedorFindUniqueOrThrowArgs>(args: SelectSubset<T, VendedorFindUniqueOrThrowArgs<ExtArgs>>): Prisma__VendedorClient<$Result.GetResult<Prisma.$VendedorPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Vendedor that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VendedorFindFirstArgs} args - Arguments to find a Vendedor
     * @example
     * // Get one Vendedor
     * const vendedor = await prisma.vendedor.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends VendedorFindFirstArgs>(args?: SelectSubset<T, VendedorFindFirstArgs<ExtArgs>>): Prisma__VendedorClient<$Result.GetResult<Prisma.$VendedorPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Vendedor that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VendedorFindFirstOrThrowArgs} args - Arguments to find a Vendedor
     * @example
     * // Get one Vendedor
     * const vendedor = await prisma.vendedor.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends VendedorFindFirstOrThrowArgs>(args?: SelectSubset<T, VendedorFindFirstOrThrowArgs<ExtArgs>>): Prisma__VendedorClient<$Result.GetResult<Prisma.$VendedorPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Vendedors that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VendedorFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Vendedors
     * const vendedors = await prisma.vendedor.findMany()
     * 
     * // Get first 10 Vendedors
     * const vendedors = await prisma.vendedor.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const vendedorWithIdOnly = await prisma.vendedor.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends VendedorFindManyArgs>(args?: SelectSubset<T, VendedorFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VendedorPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Vendedor.
     * @param {VendedorCreateArgs} args - Arguments to create a Vendedor.
     * @example
     * // Create one Vendedor
     * const Vendedor = await prisma.vendedor.create({
     *   data: {
     *     // ... data to create a Vendedor
     *   }
     * })
     * 
     */
    create<T extends VendedorCreateArgs>(args: SelectSubset<T, VendedorCreateArgs<ExtArgs>>): Prisma__VendedorClient<$Result.GetResult<Prisma.$VendedorPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Vendedors.
     * @param {VendedorCreateManyArgs} args - Arguments to create many Vendedors.
     * @example
     * // Create many Vendedors
     * const vendedor = await prisma.vendedor.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends VendedorCreateManyArgs>(args?: SelectSubset<T, VendedorCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Vendedor.
     * @param {VendedorDeleteArgs} args - Arguments to delete one Vendedor.
     * @example
     * // Delete one Vendedor
     * const Vendedor = await prisma.vendedor.delete({
     *   where: {
     *     // ... filter to delete one Vendedor
     *   }
     * })
     * 
     */
    delete<T extends VendedorDeleteArgs>(args: SelectSubset<T, VendedorDeleteArgs<ExtArgs>>): Prisma__VendedorClient<$Result.GetResult<Prisma.$VendedorPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Vendedor.
     * @param {VendedorUpdateArgs} args - Arguments to update one Vendedor.
     * @example
     * // Update one Vendedor
     * const vendedor = await prisma.vendedor.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends VendedorUpdateArgs>(args: SelectSubset<T, VendedorUpdateArgs<ExtArgs>>): Prisma__VendedorClient<$Result.GetResult<Prisma.$VendedorPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Vendedors.
     * @param {VendedorDeleteManyArgs} args - Arguments to filter Vendedors to delete.
     * @example
     * // Delete a few Vendedors
     * const { count } = await prisma.vendedor.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends VendedorDeleteManyArgs>(args?: SelectSubset<T, VendedorDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Vendedors.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VendedorUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Vendedors
     * const vendedor = await prisma.vendedor.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends VendedorUpdateManyArgs>(args: SelectSubset<T, VendedorUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Vendedor.
     * @param {VendedorUpsertArgs} args - Arguments to update or create a Vendedor.
     * @example
     * // Update or create a Vendedor
     * const vendedor = await prisma.vendedor.upsert({
     *   create: {
     *     // ... data to create a Vendedor
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Vendedor we want to update
     *   }
     * })
     */
    upsert<T extends VendedorUpsertArgs>(args: SelectSubset<T, VendedorUpsertArgs<ExtArgs>>): Prisma__VendedorClient<$Result.GetResult<Prisma.$VendedorPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Vendedors.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VendedorCountArgs} args - Arguments to filter Vendedors to count.
     * @example
     * // Count the number of Vendedors
     * const count = await prisma.vendedor.count({
     *   where: {
     *     // ... the filter for the Vendedors we want to count
     *   }
     * })
    **/
    count<T extends VendedorCountArgs>(
      args?: Subset<T, VendedorCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], VendedorCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Vendedor.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VendedorAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends VendedorAggregateArgs>(args: Subset<T, VendedorAggregateArgs>): Prisma.PrismaPromise<GetVendedorAggregateType<T>>

    /**
     * Group by Vendedor.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VendedorGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends VendedorGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: VendedorGroupByArgs['orderBy'] }
        : { orderBy?: VendedorGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, VendedorGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetVendedorGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Vendedor model
   */
  readonly fields: VendedorFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Vendedor.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__VendedorClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    notasFiscais<T extends Vendedor$notasFiscaisArgs<ExtArgs> = {}>(args?: Subset<T, Vendedor$notasFiscaisArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotasFiscalCabecalhoPayload<ExtArgs>, T, "findMany"> | Null>
    filial<T extends Vendedor$filialArgs<ExtArgs> = {}>(args?: Subset<T, Vendedor$filialArgs<ExtArgs>>): Prisma__FilialClient<$Result.GetResult<Prisma.$FilialPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Vendedor model
   */ 
  interface VendedorFieldRefs {
    readonly id: FieldRef<"Vendedor", 'Int'>
    readonly nome: FieldRef<"Vendedor", 'String'>
    readonly cpf: FieldRef<"Vendedor", 'String'>
    readonly filialId: FieldRef<"Vendedor", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * Vendedor findUnique
   */
  export type VendedorFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Vendedor
     */
    select?: VendedorSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VendedorInclude<ExtArgs> | null
    /**
     * Filter, which Vendedor to fetch.
     */
    where: VendedorWhereUniqueInput
  }

  /**
   * Vendedor findUniqueOrThrow
   */
  export type VendedorFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Vendedor
     */
    select?: VendedorSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VendedorInclude<ExtArgs> | null
    /**
     * Filter, which Vendedor to fetch.
     */
    where: VendedorWhereUniqueInput
  }

  /**
   * Vendedor findFirst
   */
  export type VendedorFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Vendedor
     */
    select?: VendedorSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VendedorInclude<ExtArgs> | null
    /**
     * Filter, which Vendedor to fetch.
     */
    where?: VendedorWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Vendedors to fetch.
     */
    orderBy?: VendedorOrderByWithRelationInput | VendedorOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Vendedors.
     */
    cursor?: VendedorWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Vendedors from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Vendedors.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Vendedors.
     */
    distinct?: VendedorScalarFieldEnum | VendedorScalarFieldEnum[]
  }

  /**
   * Vendedor findFirstOrThrow
   */
  export type VendedorFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Vendedor
     */
    select?: VendedorSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VendedorInclude<ExtArgs> | null
    /**
     * Filter, which Vendedor to fetch.
     */
    where?: VendedorWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Vendedors to fetch.
     */
    orderBy?: VendedorOrderByWithRelationInput | VendedorOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Vendedors.
     */
    cursor?: VendedorWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Vendedors from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Vendedors.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Vendedors.
     */
    distinct?: VendedorScalarFieldEnum | VendedorScalarFieldEnum[]
  }

  /**
   * Vendedor findMany
   */
  export type VendedorFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Vendedor
     */
    select?: VendedorSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VendedorInclude<ExtArgs> | null
    /**
     * Filter, which Vendedors to fetch.
     */
    where?: VendedorWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Vendedors to fetch.
     */
    orderBy?: VendedorOrderByWithRelationInput | VendedorOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Vendedors.
     */
    cursor?: VendedorWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Vendedors from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Vendedors.
     */
    skip?: number
    distinct?: VendedorScalarFieldEnum | VendedorScalarFieldEnum[]
  }

  /**
   * Vendedor create
   */
  export type VendedorCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Vendedor
     */
    select?: VendedorSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VendedorInclude<ExtArgs> | null
    /**
     * The data needed to create a Vendedor.
     */
    data: XOR<VendedorCreateInput, VendedorUncheckedCreateInput>
  }

  /**
   * Vendedor createMany
   */
  export type VendedorCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Vendedors.
     */
    data: VendedorCreateManyInput | VendedorCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Vendedor update
   */
  export type VendedorUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Vendedor
     */
    select?: VendedorSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VendedorInclude<ExtArgs> | null
    /**
     * The data needed to update a Vendedor.
     */
    data: XOR<VendedorUpdateInput, VendedorUncheckedUpdateInput>
    /**
     * Choose, which Vendedor to update.
     */
    where: VendedorWhereUniqueInput
  }

  /**
   * Vendedor updateMany
   */
  export type VendedorUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Vendedors.
     */
    data: XOR<VendedorUpdateManyMutationInput, VendedorUncheckedUpdateManyInput>
    /**
     * Filter which Vendedors to update
     */
    where?: VendedorWhereInput
  }

  /**
   * Vendedor upsert
   */
  export type VendedorUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Vendedor
     */
    select?: VendedorSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VendedorInclude<ExtArgs> | null
    /**
     * The filter to search for the Vendedor to update in case it exists.
     */
    where: VendedorWhereUniqueInput
    /**
     * In case the Vendedor found by the `where` argument doesn't exist, create a new Vendedor with this data.
     */
    create: XOR<VendedorCreateInput, VendedorUncheckedCreateInput>
    /**
     * In case the Vendedor was found with the provided `where` argument, update it with this data.
     */
    update: XOR<VendedorUpdateInput, VendedorUncheckedUpdateInput>
  }

  /**
   * Vendedor delete
   */
  export type VendedorDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Vendedor
     */
    select?: VendedorSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VendedorInclude<ExtArgs> | null
    /**
     * Filter which Vendedor to delete.
     */
    where: VendedorWhereUniqueInput
  }

  /**
   * Vendedor deleteMany
   */
  export type VendedorDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Vendedors to delete
     */
    where?: VendedorWhereInput
  }

  /**
   * Vendedor.notasFiscais
   */
  export type Vendedor$notasFiscaisArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NotasFiscalCabecalho
     */
    select?: NotasFiscalCabecalhoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotasFiscalCabecalhoInclude<ExtArgs> | null
    where?: NotasFiscalCabecalhoWhereInput
    orderBy?: NotasFiscalCabecalhoOrderByWithRelationInput | NotasFiscalCabecalhoOrderByWithRelationInput[]
    cursor?: NotasFiscalCabecalhoWhereUniqueInput
    take?: number
    skip?: number
    distinct?: NotasFiscalCabecalhoScalarFieldEnum | NotasFiscalCabecalhoScalarFieldEnum[]
  }

  /**
   * Vendedor.filial
   */
  export type Vendedor$filialArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Filial
     */
    select?: FilialSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FilialInclude<ExtArgs> | null
    where?: FilialWhereInput
  }

  /**
   * Vendedor without action
   */
  export type VendedorDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Vendedor
     */
    select?: VendedorSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VendedorInclude<ExtArgs> | null
  }


  /**
   * Model Produto
   */

  export type AggregateProduto = {
    _count: ProdutoCountAggregateOutputType | null
    _avg: ProdutoAvgAggregateOutputType | null
    _sum: ProdutoSumAggregateOutputType | null
    _min: ProdutoMinAggregateOutputType | null
    _max: ProdutoMaxAggregateOutputType | null
  }

  export type ProdutoAvgAggregateOutputType = {
    id: number | null
    preco: Decimal | null
  }

  export type ProdutoSumAggregateOutputType = {
    id: number | null
    preco: Decimal | null
  }

  export type ProdutoMinAggregateOutputType = {
    id: number | null
    descricao: string | null
    tipo: string | null
    preco: Decimal | null
  }

  export type ProdutoMaxAggregateOutputType = {
    id: number | null
    descricao: string | null
    tipo: string | null
    preco: Decimal | null
  }

  export type ProdutoCountAggregateOutputType = {
    id: number
    descricao: number
    tipo: number
    preco: number
    _all: number
  }


  export type ProdutoAvgAggregateInputType = {
    id?: true
    preco?: true
  }

  export type ProdutoSumAggregateInputType = {
    id?: true
    preco?: true
  }

  export type ProdutoMinAggregateInputType = {
    id?: true
    descricao?: true
    tipo?: true
    preco?: true
  }

  export type ProdutoMaxAggregateInputType = {
    id?: true
    descricao?: true
    tipo?: true
    preco?: true
  }

  export type ProdutoCountAggregateInputType = {
    id?: true
    descricao?: true
    tipo?: true
    preco?: true
    _all?: true
  }

  export type ProdutoAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Produto to aggregate.
     */
    where?: ProdutoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Produtos to fetch.
     */
    orderBy?: ProdutoOrderByWithRelationInput | ProdutoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ProdutoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Produtos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Produtos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Produtos
    **/
    _count?: true | ProdutoCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ProdutoAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ProdutoSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ProdutoMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ProdutoMaxAggregateInputType
  }

  export type GetProdutoAggregateType<T extends ProdutoAggregateArgs> = {
        [P in keyof T & keyof AggregateProduto]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateProduto[P]>
      : GetScalarType<T[P], AggregateProduto[P]>
  }




  export type ProdutoGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProdutoWhereInput
    orderBy?: ProdutoOrderByWithAggregationInput | ProdutoOrderByWithAggregationInput[]
    by: ProdutoScalarFieldEnum[] | ProdutoScalarFieldEnum
    having?: ProdutoScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ProdutoCountAggregateInputType | true
    _avg?: ProdutoAvgAggregateInputType
    _sum?: ProdutoSumAggregateInputType
    _min?: ProdutoMinAggregateInputType
    _max?: ProdutoMaxAggregateInputType
  }

  export type ProdutoGroupByOutputType = {
    id: number
    descricao: string
    tipo: string
    preco: Decimal
    _count: ProdutoCountAggregateOutputType | null
    _avg: ProdutoAvgAggregateOutputType | null
    _sum: ProdutoSumAggregateOutputType | null
    _min: ProdutoMinAggregateOutputType | null
    _max: ProdutoMaxAggregateOutputType | null
  }

  type GetProdutoGroupByPayload<T extends ProdutoGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ProdutoGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ProdutoGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ProdutoGroupByOutputType[P]>
            : GetScalarType<T[P], ProdutoGroupByOutputType[P]>
        }
      >
    >


  export type ProdutoSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    descricao?: boolean
    tipo?: boolean
    preco?: boolean
    maquinasEstoque?: boolean | Produto$maquinasEstoqueArgs<ExtArgs>
    notasFiscaisItens?: boolean | Produto$notasFiscaisItensArgs<ExtArgs>
    _count?: boolean | ProdutoCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["produto"]>


  export type ProdutoSelectScalar = {
    id?: boolean
    descricao?: boolean
    tipo?: boolean
    preco?: boolean
  }

  export type ProdutoInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    maquinasEstoque?: boolean | Produto$maquinasEstoqueArgs<ExtArgs>
    notasFiscaisItens?: boolean | Produto$notasFiscaisItensArgs<ExtArgs>
    _count?: boolean | ProdutoCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $ProdutoPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Produto"
    objects: {
      maquinasEstoque: Prisma.$MaquinaEstoquePayload<ExtArgs>[]
      notasFiscaisItens: Prisma.$NotaFiscalItemPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      descricao: string
      tipo: string
      preco: Prisma.Decimal
    }, ExtArgs["result"]["produto"]>
    composites: {}
  }

  type ProdutoGetPayload<S extends boolean | null | undefined | ProdutoDefaultArgs> = $Result.GetResult<Prisma.$ProdutoPayload, S>

  type ProdutoCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ProdutoFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ProdutoCountAggregateInputType | true
    }

  export interface ProdutoDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Produto'], meta: { name: 'Produto' } }
    /**
     * Find zero or one Produto that matches the filter.
     * @param {ProdutoFindUniqueArgs} args - Arguments to find a Produto
     * @example
     * // Get one Produto
     * const produto = await prisma.produto.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ProdutoFindUniqueArgs>(args: SelectSubset<T, ProdutoFindUniqueArgs<ExtArgs>>): Prisma__ProdutoClient<$Result.GetResult<Prisma.$ProdutoPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Produto that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {ProdutoFindUniqueOrThrowArgs} args - Arguments to find a Produto
     * @example
     * // Get one Produto
     * const produto = await prisma.produto.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ProdutoFindUniqueOrThrowArgs>(args: SelectSubset<T, ProdutoFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ProdutoClient<$Result.GetResult<Prisma.$ProdutoPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Produto that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProdutoFindFirstArgs} args - Arguments to find a Produto
     * @example
     * // Get one Produto
     * const produto = await prisma.produto.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ProdutoFindFirstArgs>(args?: SelectSubset<T, ProdutoFindFirstArgs<ExtArgs>>): Prisma__ProdutoClient<$Result.GetResult<Prisma.$ProdutoPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Produto that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProdutoFindFirstOrThrowArgs} args - Arguments to find a Produto
     * @example
     * // Get one Produto
     * const produto = await prisma.produto.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ProdutoFindFirstOrThrowArgs>(args?: SelectSubset<T, ProdutoFindFirstOrThrowArgs<ExtArgs>>): Prisma__ProdutoClient<$Result.GetResult<Prisma.$ProdutoPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Produtos that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProdutoFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Produtos
     * const produtos = await prisma.produto.findMany()
     * 
     * // Get first 10 Produtos
     * const produtos = await prisma.produto.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const produtoWithIdOnly = await prisma.produto.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ProdutoFindManyArgs>(args?: SelectSubset<T, ProdutoFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProdutoPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Produto.
     * @param {ProdutoCreateArgs} args - Arguments to create a Produto.
     * @example
     * // Create one Produto
     * const Produto = await prisma.produto.create({
     *   data: {
     *     // ... data to create a Produto
     *   }
     * })
     * 
     */
    create<T extends ProdutoCreateArgs>(args: SelectSubset<T, ProdutoCreateArgs<ExtArgs>>): Prisma__ProdutoClient<$Result.GetResult<Prisma.$ProdutoPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Produtos.
     * @param {ProdutoCreateManyArgs} args - Arguments to create many Produtos.
     * @example
     * // Create many Produtos
     * const produto = await prisma.produto.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ProdutoCreateManyArgs>(args?: SelectSubset<T, ProdutoCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Produto.
     * @param {ProdutoDeleteArgs} args - Arguments to delete one Produto.
     * @example
     * // Delete one Produto
     * const Produto = await prisma.produto.delete({
     *   where: {
     *     // ... filter to delete one Produto
     *   }
     * })
     * 
     */
    delete<T extends ProdutoDeleteArgs>(args: SelectSubset<T, ProdutoDeleteArgs<ExtArgs>>): Prisma__ProdutoClient<$Result.GetResult<Prisma.$ProdutoPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Produto.
     * @param {ProdutoUpdateArgs} args - Arguments to update one Produto.
     * @example
     * // Update one Produto
     * const produto = await prisma.produto.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ProdutoUpdateArgs>(args: SelectSubset<T, ProdutoUpdateArgs<ExtArgs>>): Prisma__ProdutoClient<$Result.GetResult<Prisma.$ProdutoPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Produtos.
     * @param {ProdutoDeleteManyArgs} args - Arguments to filter Produtos to delete.
     * @example
     * // Delete a few Produtos
     * const { count } = await prisma.produto.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ProdutoDeleteManyArgs>(args?: SelectSubset<T, ProdutoDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Produtos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProdutoUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Produtos
     * const produto = await prisma.produto.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ProdutoUpdateManyArgs>(args: SelectSubset<T, ProdutoUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Produto.
     * @param {ProdutoUpsertArgs} args - Arguments to update or create a Produto.
     * @example
     * // Update or create a Produto
     * const produto = await prisma.produto.upsert({
     *   create: {
     *     // ... data to create a Produto
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Produto we want to update
     *   }
     * })
     */
    upsert<T extends ProdutoUpsertArgs>(args: SelectSubset<T, ProdutoUpsertArgs<ExtArgs>>): Prisma__ProdutoClient<$Result.GetResult<Prisma.$ProdutoPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Produtos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProdutoCountArgs} args - Arguments to filter Produtos to count.
     * @example
     * // Count the number of Produtos
     * const count = await prisma.produto.count({
     *   where: {
     *     // ... the filter for the Produtos we want to count
     *   }
     * })
    **/
    count<T extends ProdutoCountArgs>(
      args?: Subset<T, ProdutoCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ProdutoCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Produto.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProdutoAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ProdutoAggregateArgs>(args: Subset<T, ProdutoAggregateArgs>): Prisma.PrismaPromise<GetProdutoAggregateType<T>>

    /**
     * Group by Produto.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProdutoGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ProdutoGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ProdutoGroupByArgs['orderBy'] }
        : { orderBy?: ProdutoGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ProdutoGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetProdutoGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Produto model
   */
  readonly fields: ProdutoFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Produto.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ProdutoClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    maquinasEstoque<T extends Produto$maquinasEstoqueArgs<ExtArgs> = {}>(args?: Subset<T, Produto$maquinasEstoqueArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MaquinaEstoquePayload<ExtArgs>, T, "findMany"> | Null>
    notasFiscaisItens<T extends Produto$notasFiscaisItensArgs<ExtArgs> = {}>(args?: Subset<T, Produto$notasFiscaisItensArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotaFiscalItemPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Produto model
   */ 
  interface ProdutoFieldRefs {
    readonly id: FieldRef<"Produto", 'Int'>
    readonly descricao: FieldRef<"Produto", 'String'>
    readonly tipo: FieldRef<"Produto", 'String'>
    readonly preco: FieldRef<"Produto", 'Decimal'>
  }
    

  // Custom InputTypes
  /**
   * Produto findUnique
   */
  export type ProdutoFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Produto
     */
    select?: ProdutoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProdutoInclude<ExtArgs> | null
    /**
     * Filter, which Produto to fetch.
     */
    where: ProdutoWhereUniqueInput
  }

  /**
   * Produto findUniqueOrThrow
   */
  export type ProdutoFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Produto
     */
    select?: ProdutoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProdutoInclude<ExtArgs> | null
    /**
     * Filter, which Produto to fetch.
     */
    where: ProdutoWhereUniqueInput
  }

  /**
   * Produto findFirst
   */
  export type ProdutoFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Produto
     */
    select?: ProdutoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProdutoInclude<ExtArgs> | null
    /**
     * Filter, which Produto to fetch.
     */
    where?: ProdutoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Produtos to fetch.
     */
    orderBy?: ProdutoOrderByWithRelationInput | ProdutoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Produtos.
     */
    cursor?: ProdutoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Produtos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Produtos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Produtos.
     */
    distinct?: ProdutoScalarFieldEnum | ProdutoScalarFieldEnum[]
  }

  /**
   * Produto findFirstOrThrow
   */
  export type ProdutoFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Produto
     */
    select?: ProdutoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProdutoInclude<ExtArgs> | null
    /**
     * Filter, which Produto to fetch.
     */
    where?: ProdutoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Produtos to fetch.
     */
    orderBy?: ProdutoOrderByWithRelationInput | ProdutoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Produtos.
     */
    cursor?: ProdutoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Produtos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Produtos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Produtos.
     */
    distinct?: ProdutoScalarFieldEnum | ProdutoScalarFieldEnum[]
  }

  /**
   * Produto findMany
   */
  export type ProdutoFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Produto
     */
    select?: ProdutoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProdutoInclude<ExtArgs> | null
    /**
     * Filter, which Produtos to fetch.
     */
    where?: ProdutoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Produtos to fetch.
     */
    orderBy?: ProdutoOrderByWithRelationInput | ProdutoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Produtos.
     */
    cursor?: ProdutoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Produtos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Produtos.
     */
    skip?: number
    distinct?: ProdutoScalarFieldEnum | ProdutoScalarFieldEnum[]
  }

  /**
   * Produto create
   */
  export type ProdutoCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Produto
     */
    select?: ProdutoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProdutoInclude<ExtArgs> | null
    /**
     * The data needed to create a Produto.
     */
    data: XOR<ProdutoCreateInput, ProdutoUncheckedCreateInput>
  }

  /**
   * Produto createMany
   */
  export type ProdutoCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Produtos.
     */
    data: ProdutoCreateManyInput | ProdutoCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Produto update
   */
  export type ProdutoUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Produto
     */
    select?: ProdutoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProdutoInclude<ExtArgs> | null
    /**
     * The data needed to update a Produto.
     */
    data: XOR<ProdutoUpdateInput, ProdutoUncheckedUpdateInput>
    /**
     * Choose, which Produto to update.
     */
    where: ProdutoWhereUniqueInput
  }

  /**
   * Produto updateMany
   */
  export type ProdutoUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Produtos.
     */
    data: XOR<ProdutoUpdateManyMutationInput, ProdutoUncheckedUpdateManyInput>
    /**
     * Filter which Produtos to update
     */
    where?: ProdutoWhereInput
  }

  /**
   * Produto upsert
   */
  export type ProdutoUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Produto
     */
    select?: ProdutoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProdutoInclude<ExtArgs> | null
    /**
     * The filter to search for the Produto to update in case it exists.
     */
    where: ProdutoWhereUniqueInput
    /**
     * In case the Produto found by the `where` argument doesn't exist, create a new Produto with this data.
     */
    create: XOR<ProdutoCreateInput, ProdutoUncheckedCreateInput>
    /**
     * In case the Produto was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ProdutoUpdateInput, ProdutoUncheckedUpdateInput>
  }

  /**
   * Produto delete
   */
  export type ProdutoDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Produto
     */
    select?: ProdutoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProdutoInclude<ExtArgs> | null
    /**
     * Filter which Produto to delete.
     */
    where: ProdutoWhereUniqueInput
  }

  /**
   * Produto deleteMany
   */
  export type ProdutoDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Produtos to delete
     */
    where?: ProdutoWhereInput
  }

  /**
   * Produto.maquinasEstoque
   */
  export type Produto$maquinasEstoqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MaquinaEstoque
     */
    select?: MaquinaEstoqueSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MaquinaEstoqueInclude<ExtArgs> | null
    where?: MaquinaEstoqueWhereInput
    orderBy?: MaquinaEstoqueOrderByWithRelationInput | MaquinaEstoqueOrderByWithRelationInput[]
    cursor?: MaquinaEstoqueWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MaquinaEstoqueScalarFieldEnum | MaquinaEstoqueScalarFieldEnum[]
  }

  /**
   * Produto.notasFiscaisItens
   */
  export type Produto$notasFiscaisItensArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NotaFiscalItem
     */
    select?: NotaFiscalItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotaFiscalItemInclude<ExtArgs> | null
    where?: NotaFiscalItemWhereInput
    orderBy?: NotaFiscalItemOrderByWithRelationInput | NotaFiscalItemOrderByWithRelationInput[]
    cursor?: NotaFiscalItemWhereUniqueInput
    take?: number
    skip?: number
    distinct?: NotaFiscalItemScalarFieldEnum | NotaFiscalItemScalarFieldEnum[]
  }

  /**
   * Produto without action
   */
  export type ProdutoDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Produto
     */
    select?: ProdutoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProdutoInclude<ExtArgs> | null
  }


  /**
   * Model MaquinaEstoque
   */

  export type AggregateMaquinaEstoque = {
    _count: MaquinaEstoqueCountAggregateOutputType | null
    _avg: MaquinaEstoqueAvgAggregateOutputType | null
    _sum: MaquinaEstoqueSumAggregateOutputType | null
    _min: MaquinaEstoqueMinAggregateOutputType | null
    _max: MaquinaEstoqueMaxAggregateOutputType | null
  }

  export type MaquinaEstoqueAvgAggregateOutputType = {
    produtoId: number | null
    filialId: number | null
  }

  export type MaquinaEstoqueSumAggregateOutputType = {
    produtoId: number | null
    filialId: number | null
  }

  export type MaquinaEstoqueMinAggregateOutputType = {
    Chassi: string | null
    produtoId: number | null
    filialId: number | null
    Status: string | null
  }

  export type MaquinaEstoqueMaxAggregateOutputType = {
    Chassi: string | null
    produtoId: number | null
    filialId: number | null
    Status: string | null
  }

  export type MaquinaEstoqueCountAggregateOutputType = {
    Chassi: number
    produtoId: number
    filialId: number
    Status: number
    _all: number
  }


  export type MaquinaEstoqueAvgAggregateInputType = {
    produtoId?: true
    filialId?: true
  }

  export type MaquinaEstoqueSumAggregateInputType = {
    produtoId?: true
    filialId?: true
  }

  export type MaquinaEstoqueMinAggregateInputType = {
    Chassi?: true
    produtoId?: true
    filialId?: true
    Status?: true
  }

  export type MaquinaEstoqueMaxAggregateInputType = {
    Chassi?: true
    produtoId?: true
    filialId?: true
    Status?: true
  }

  export type MaquinaEstoqueCountAggregateInputType = {
    Chassi?: true
    produtoId?: true
    filialId?: true
    Status?: true
    _all?: true
  }

  export type MaquinaEstoqueAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which MaquinaEstoque to aggregate.
     */
    where?: MaquinaEstoqueWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MaquinaEstoques to fetch.
     */
    orderBy?: MaquinaEstoqueOrderByWithRelationInput | MaquinaEstoqueOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: MaquinaEstoqueWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MaquinaEstoques from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MaquinaEstoques.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned MaquinaEstoques
    **/
    _count?: true | MaquinaEstoqueCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: MaquinaEstoqueAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: MaquinaEstoqueSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: MaquinaEstoqueMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: MaquinaEstoqueMaxAggregateInputType
  }

  export type GetMaquinaEstoqueAggregateType<T extends MaquinaEstoqueAggregateArgs> = {
        [P in keyof T & keyof AggregateMaquinaEstoque]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMaquinaEstoque[P]>
      : GetScalarType<T[P], AggregateMaquinaEstoque[P]>
  }




  export type MaquinaEstoqueGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MaquinaEstoqueWhereInput
    orderBy?: MaquinaEstoqueOrderByWithAggregationInput | MaquinaEstoqueOrderByWithAggregationInput[]
    by: MaquinaEstoqueScalarFieldEnum[] | MaquinaEstoqueScalarFieldEnum
    having?: MaquinaEstoqueScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: MaquinaEstoqueCountAggregateInputType | true
    _avg?: MaquinaEstoqueAvgAggregateInputType
    _sum?: MaquinaEstoqueSumAggregateInputType
    _min?: MaquinaEstoqueMinAggregateInputType
    _max?: MaquinaEstoqueMaxAggregateInputType
  }

  export type MaquinaEstoqueGroupByOutputType = {
    Chassi: string
    produtoId: number
    filialId: number | null
    Status: string | null
    _count: MaquinaEstoqueCountAggregateOutputType | null
    _avg: MaquinaEstoqueAvgAggregateOutputType | null
    _sum: MaquinaEstoqueSumAggregateOutputType | null
    _min: MaquinaEstoqueMinAggregateOutputType | null
    _max: MaquinaEstoqueMaxAggregateOutputType | null
  }

  type GetMaquinaEstoqueGroupByPayload<T extends MaquinaEstoqueGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<MaquinaEstoqueGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof MaquinaEstoqueGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], MaquinaEstoqueGroupByOutputType[P]>
            : GetScalarType<T[P], MaquinaEstoqueGroupByOutputType[P]>
        }
      >
    >


  export type MaquinaEstoqueSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    Chassi?: boolean
    produtoId?: boolean
    filialId?: boolean
    Status?: boolean
    produto?: boolean | ProdutoDefaultArgs<ExtArgs>
    filial?: boolean | MaquinaEstoque$filialArgs<ExtArgs>
    Notas_Fiscais_Itens?: boolean | MaquinaEstoque$Notas_Fiscais_ItensArgs<ExtArgs>
    _count?: boolean | MaquinaEstoqueCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["maquinaEstoque"]>


  export type MaquinaEstoqueSelectScalar = {
    Chassi?: boolean
    produtoId?: boolean
    filialId?: boolean
    Status?: boolean
  }

  export type MaquinaEstoqueInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    produto?: boolean | ProdutoDefaultArgs<ExtArgs>
    filial?: boolean | MaquinaEstoque$filialArgs<ExtArgs>
    Notas_Fiscais_Itens?: boolean | MaquinaEstoque$Notas_Fiscais_ItensArgs<ExtArgs>
    _count?: boolean | MaquinaEstoqueCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $MaquinaEstoquePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "MaquinaEstoque"
    objects: {
      produto: Prisma.$ProdutoPayload<ExtArgs>
      filial: Prisma.$FilialPayload<ExtArgs> | null
      Notas_Fiscais_Itens: Prisma.$NotaFiscalItemPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      Chassi: string
      produtoId: number
      filialId: number | null
      Status: string | null
    }, ExtArgs["result"]["maquinaEstoque"]>
    composites: {}
  }

  type MaquinaEstoqueGetPayload<S extends boolean | null | undefined | MaquinaEstoqueDefaultArgs> = $Result.GetResult<Prisma.$MaquinaEstoquePayload, S>

  type MaquinaEstoqueCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<MaquinaEstoqueFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: MaquinaEstoqueCountAggregateInputType | true
    }

  export interface MaquinaEstoqueDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['MaquinaEstoque'], meta: { name: 'MaquinaEstoque' } }
    /**
     * Find zero or one MaquinaEstoque that matches the filter.
     * @param {MaquinaEstoqueFindUniqueArgs} args - Arguments to find a MaquinaEstoque
     * @example
     * // Get one MaquinaEstoque
     * const maquinaEstoque = await prisma.maquinaEstoque.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends MaquinaEstoqueFindUniqueArgs>(args: SelectSubset<T, MaquinaEstoqueFindUniqueArgs<ExtArgs>>): Prisma__MaquinaEstoqueClient<$Result.GetResult<Prisma.$MaquinaEstoquePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one MaquinaEstoque that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {MaquinaEstoqueFindUniqueOrThrowArgs} args - Arguments to find a MaquinaEstoque
     * @example
     * // Get one MaquinaEstoque
     * const maquinaEstoque = await prisma.maquinaEstoque.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends MaquinaEstoqueFindUniqueOrThrowArgs>(args: SelectSubset<T, MaquinaEstoqueFindUniqueOrThrowArgs<ExtArgs>>): Prisma__MaquinaEstoqueClient<$Result.GetResult<Prisma.$MaquinaEstoquePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first MaquinaEstoque that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MaquinaEstoqueFindFirstArgs} args - Arguments to find a MaquinaEstoque
     * @example
     * // Get one MaquinaEstoque
     * const maquinaEstoque = await prisma.maquinaEstoque.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends MaquinaEstoqueFindFirstArgs>(args?: SelectSubset<T, MaquinaEstoqueFindFirstArgs<ExtArgs>>): Prisma__MaquinaEstoqueClient<$Result.GetResult<Prisma.$MaquinaEstoquePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first MaquinaEstoque that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MaquinaEstoqueFindFirstOrThrowArgs} args - Arguments to find a MaquinaEstoque
     * @example
     * // Get one MaquinaEstoque
     * const maquinaEstoque = await prisma.maquinaEstoque.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends MaquinaEstoqueFindFirstOrThrowArgs>(args?: SelectSubset<T, MaquinaEstoqueFindFirstOrThrowArgs<ExtArgs>>): Prisma__MaquinaEstoqueClient<$Result.GetResult<Prisma.$MaquinaEstoquePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more MaquinaEstoques that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MaquinaEstoqueFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all MaquinaEstoques
     * const maquinaEstoques = await prisma.maquinaEstoque.findMany()
     * 
     * // Get first 10 MaquinaEstoques
     * const maquinaEstoques = await prisma.maquinaEstoque.findMany({ take: 10 })
     * 
     * // Only select the `Chassi`
     * const maquinaEstoqueWithChassiOnly = await prisma.maquinaEstoque.findMany({ select: { Chassi: true } })
     * 
     */
    findMany<T extends MaquinaEstoqueFindManyArgs>(args?: SelectSubset<T, MaquinaEstoqueFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MaquinaEstoquePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a MaquinaEstoque.
     * @param {MaquinaEstoqueCreateArgs} args - Arguments to create a MaquinaEstoque.
     * @example
     * // Create one MaquinaEstoque
     * const MaquinaEstoque = await prisma.maquinaEstoque.create({
     *   data: {
     *     // ... data to create a MaquinaEstoque
     *   }
     * })
     * 
     */
    create<T extends MaquinaEstoqueCreateArgs>(args: SelectSubset<T, MaquinaEstoqueCreateArgs<ExtArgs>>): Prisma__MaquinaEstoqueClient<$Result.GetResult<Prisma.$MaquinaEstoquePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many MaquinaEstoques.
     * @param {MaquinaEstoqueCreateManyArgs} args - Arguments to create many MaquinaEstoques.
     * @example
     * // Create many MaquinaEstoques
     * const maquinaEstoque = await prisma.maquinaEstoque.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends MaquinaEstoqueCreateManyArgs>(args?: SelectSubset<T, MaquinaEstoqueCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a MaquinaEstoque.
     * @param {MaquinaEstoqueDeleteArgs} args - Arguments to delete one MaquinaEstoque.
     * @example
     * // Delete one MaquinaEstoque
     * const MaquinaEstoque = await prisma.maquinaEstoque.delete({
     *   where: {
     *     // ... filter to delete one MaquinaEstoque
     *   }
     * })
     * 
     */
    delete<T extends MaquinaEstoqueDeleteArgs>(args: SelectSubset<T, MaquinaEstoqueDeleteArgs<ExtArgs>>): Prisma__MaquinaEstoqueClient<$Result.GetResult<Prisma.$MaquinaEstoquePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one MaquinaEstoque.
     * @param {MaquinaEstoqueUpdateArgs} args - Arguments to update one MaquinaEstoque.
     * @example
     * // Update one MaquinaEstoque
     * const maquinaEstoque = await prisma.maquinaEstoque.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends MaquinaEstoqueUpdateArgs>(args: SelectSubset<T, MaquinaEstoqueUpdateArgs<ExtArgs>>): Prisma__MaquinaEstoqueClient<$Result.GetResult<Prisma.$MaquinaEstoquePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more MaquinaEstoques.
     * @param {MaquinaEstoqueDeleteManyArgs} args - Arguments to filter MaquinaEstoques to delete.
     * @example
     * // Delete a few MaquinaEstoques
     * const { count } = await prisma.maquinaEstoque.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends MaquinaEstoqueDeleteManyArgs>(args?: SelectSubset<T, MaquinaEstoqueDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more MaquinaEstoques.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MaquinaEstoqueUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many MaquinaEstoques
     * const maquinaEstoque = await prisma.maquinaEstoque.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends MaquinaEstoqueUpdateManyArgs>(args: SelectSubset<T, MaquinaEstoqueUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one MaquinaEstoque.
     * @param {MaquinaEstoqueUpsertArgs} args - Arguments to update or create a MaquinaEstoque.
     * @example
     * // Update or create a MaquinaEstoque
     * const maquinaEstoque = await prisma.maquinaEstoque.upsert({
     *   create: {
     *     // ... data to create a MaquinaEstoque
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the MaquinaEstoque we want to update
     *   }
     * })
     */
    upsert<T extends MaquinaEstoqueUpsertArgs>(args: SelectSubset<T, MaquinaEstoqueUpsertArgs<ExtArgs>>): Prisma__MaquinaEstoqueClient<$Result.GetResult<Prisma.$MaquinaEstoquePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of MaquinaEstoques.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MaquinaEstoqueCountArgs} args - Arguments to filter MaquinaEstoques to count.
     * @example
     * // Count the number of MaquinaEstoques
     * const count = await prisma.maquinaEstoque.count({
     *   where: {
     *     // ... the filter for the MaquinaEstoques we want to count
     *   }
     * })
    **/
    count<T extends MaquinaEstoqueCountArgs>(
      args?: Subset<T, MaquinaEstoqueCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MaquinaEstoqueCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a MaquinaEstoque.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MaquinaEstoqueAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MaquinaEstoqueAggregateArgs>(args: Subset<T, MaquinaEstoqueAggregateArgs>): Prisma.PrismaPromise<GetMaquinaEstoqueAggregateType<T>>

    /**
     * Group by MaquinaEstoque.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MaquinaEstoqueGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends MaquinaEstoqueGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: MaquinaEstoqueGroupByArgs['orderBy'] }
        : { orderBy?: MaquinaEstoqueGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, MaquinaEstoqueGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMaquinaEstoqueGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the MaquinaEstoque model
   */
  readonly fields: MaquinaEstoqueFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for MaquinaEstoque.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__MaquinaEstoqueClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    produto<T extends ProdutoDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ProdutoDefaultArgs<ExtArgs>>): Prisma__ProdutoClient<$Result.GetResult<Prisma.$ProdutoPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    filial<T extends MaquinaEstoque$filialArgs<ExtArgs> = {}>(args?: Subset<T, MaquinaEstoque$filialArgs<ExtArgs>>): Prisma__FilialClient<$Result.GetResult<Prisma.$FilialPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    Notas_Fiscais_Itens<T extends MaquinaEstoque$Notas_Fiscais_ItensArgs<ExtArgs> = {}>(args?: Subset<T, MaquinaEstoque$Notas_Fiscais_ItensArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotaFiscalItemPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the MaquinaEstoque model
   */ 
  interface MaquinaEstoqueFieldRefs {
    readonly Chassi: FieldRef<"MaquinaEstoque", 'String'>
    readonly produtoId: FieldRef<"MaquinaEstoque", 'Int'>
    readonly filialId: FieldRef<"MaquinaEstoque", 'Int'>
    readonly Status: FieldRef<"MaquinaEstoque", 'String'>
  }
    

  // Custom InputTypes
  /**
   * MaquinaEstoque findUnique
   */
  export type MaquinaEstoqueFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MaquinaEstoque
     */
    select?: MaquinaEstoqueSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MaquinaEstoqueInclude<ExtArgs> | null
    /**
     * Filter, which MaquinaEstoque to fetch.
     */
    where: MaquinaEstoqueWhereUniqueInput
  }

  /**
   * MaquinaEstoque findUniqueOrThrow
   */
  export type MaquinaEstoqueFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MaquinaEstoque
     */
    select?: MaquinaEstoqueSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MaquinaEstoqueInclude<ExtArgs> | null
    /**
     * Filter, which MaquinaEstoque to fetch.
     */
    where: MaquinaEstoqueWhereUniqueInput
  }

  /**
   * MaquinaEstoque findFirst
   */
  export type MaquinaEstoqueFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MaquinaEstoque
     */
    select?: MaquinaEstoqueSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MaquinaEstoqueInclude<ExtArgs> | null
    /**
     * Filter, which MaquinaEstoque to fetch.
     */
    where?: MaquinaEstoqueWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MaquinaEstoques to fetch.
     */
    orderBy?: MaquinaEstoqueOrderByWithRelationInput | MaquinaEstoqueOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MaquinaEstoques.
     */
    cursor?: MaquinaEstoqueWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MaquinaEstoques from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MaquinaEstoques.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MaquinaEstoques.
     */
    distinct?: MaquinaEstoqueScalarFieldEnum | MaquinaEstoqueScalarFieldEnum[]
  }

  /**
   * MaquinaEstoque findFirstOrThrow
   */
  export type MaquinaEstoqueFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MaquinaEstoque
     */
    select?: MaquinaEstoqueSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MaquinaEstoqueInclude<ExtArgs> | null
    /**
     * Filter, which MaquinaEstoque to fetch.
     */
    where?: MaquinaEstoqueWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MaquinaEstoques to fetch.
     */
    orderBy?: MaquinaEstoqueOrderByWithRelationInput | MaquinaEstoqueOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MaquinaEstoques.
     */
    cursor?: MaquinaEstoqueWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MaquinaEstoques from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MaquinaEstoques.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MaquinaEstoques.
     */
    distinct?: MaquinaEstoqueScalarFieldEnum | MaquinaEstoqueScalarFieldEnum[]
  }

  /**
   * MaquinaEstoque findMany
   */
  export type MaquinaEstoqueFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MaquinaEstoque
     */
    select?: MaquinaEstoqueSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MaquinaEstoqueInclude<ExtArgs> | null
    /**
     * Filter, which MaquinaEstoques to fetch.
     */
    where?: MaquinaEstoqueWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MaquinaEstoques to fetch.
     */
    orderBy?: MaquinaEstoqueOrderByWithRelationInput | MaquinaEstoqueOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing MaquinaEstoques.
     */
    cursor?: MaquinaEstoqueWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MaquinaEstoques from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MaquinaEstoques.
     */
    skip?: number
    distinct?: MaquinaEstoqueScalarFieldEnum | MaquinaEstoqueScalarFieldEnum[]
  }

  /**
   * MaquinaEstoque create
   */
  export type MaquinaEstoqueCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MaquinaEstoque
     */
    select?: MaquinaEstoqueSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MaquinaEstoqueInclude<ExtArgs> | null
    /**
     * The data needed to create a MaquinaEstoque.
     */
    data: XOR<MaquinaEstoqueCreateInput, MaquinaEstoqueUncheckedCreateInput>
  }

  /**
   * MaquinaEstoque createMany
   */
  export type MaquinaEstoqueCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many MaquinaEstoques.
     */
    data: MaquinaEstoqueCreateManyInput | MaquinaEstoqueCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * MaquinaEstoque update
   */
  export type MaquinaEstoqueUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MaquinaEstoque
     */
    select?: MaquinaEstoqueSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MaquinaEstoqueInclude<ExtArgs> | null
    /**
     * The data needed to update a MaquinaEstoque.
     */
    data: XOR<MaquinaEstoqueUpdateInput, MaquinaEstoqueUncheckedUpdateInput>
    /**
     * Choose, which MaquinaEstoque to update.
     */
    where: MaquinaEstoqueWhereUniqueInput
  }

  /**
   * MaquinaEstoque updateMany
   */
  export type MaquinaEstoqueUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update MaquinaEstoques.
     */
    data: XOR<MaquinaEstoqueUpdateManyMutationInput, MaquinaEstoqueUncheckedUpdateManyInput>
    /**
     * Filter which MaquinaEstoques to update
     */
    where?: MaquinaEstoqueWhereInput
  }

  /**
   * MaquinaEstoque upsert
   */
  export type MaquinaEstoqueUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MaquinaEstoque
     */
    select?: MaquinaEstoqueSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MaquinaEstoqueInclude<ExtArgs> | null
    /**
     * The filter to search for the MaquinaEstoque to update in case it exists.
     */
    where: MaquinaEstoqueWhereUniqueInput
    /**
     * In case the MaquinaEstoque found by the `where` argument doesn't exist, create a new MaquinaEstoque with this data.
     */
    create: XOR<MaquinaEstoqueCreateInput, MaquinaEstoqueUncheckedCreateInput>
    /**
     * In case the MaquinaEstoque was found with the provided `where` argument, update it with this data.
     */
    update: XOR<MaquinaEstoqueUpdateInput, MaquinaEstoqueUncheckedUpdateInput>
  }

  /**
   * MaquinaEstoque delete
   */
  export type MaquinaEstoqueDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MaquinaEstoque
     */
    select?: MaquinaEstoqueSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MaquinaEstoqueInclude<ExtArgs> | null
    /**
     * Filter which MaquinaEstoque to delete.
     */
    where: MaquinaEstoqueWhereUniqueInput
  }

  /**
   * MaquinaEstoque deleteMany
   */
  export type MaquinaEstoqueDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which MaquinaEstoques to delete
     */
    where?: MaquinaEstoqueWhereInput
  }

  /**
   * MaquinaEstoque.filial
   */
  export type MaquinaEstoque$filialArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Filial
     */
    select?: FilialSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FilialInclude<ExtArgs> | null
    where?: FilialWhereInput
  }

  /**
   * MaquinaEstoque.Notas_Fiscais_Itens
   */
  export type MaquinaEstoque$Notas_Fiscais_ItensArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NotaFiscalItem
     */
    select?: NotaFiscalItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotaFiscalItemInclude<ExtArgs> | null
    where?: NotaFiscalItemWhereInput
    orderBy?: NotaFiscalItemOrderByWithRelationInput | NotaFiscalItemOrderByWithRelationInput[]
    cursor?: NotaFiscalItemWhereUniqueInput
    take?: number
    skip?: number
    distinct?: NotaFiscalItemScalarFieldEnum | NotaFiscalItemScalarFieldEnum[]
  }

  /**
   * MaquinaEstoque without action
   */
  export type MaquinaEstoqueDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MaquinaEstoque
     */
    select?: MaquinaEstoqueSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MaquinaEstoqueInclude<ExtArgs> | null
  }


  /**
   * Model NotasFiscalCabecalho
   */

  export type AggregateNotasFiscalCabecalho = {
    _count: NotasFiscalCabecalhoCountAggregateOutputType | null
    _avg: NotasFiscalCabecalhoAvgAggregateOutputType | null
    _sum: NotasFiscalCabecalhoSumAggregateOutputType | null
    _min: NotasFiscalCabecalhoMinAggregateOutputType | null
    _max: NotasFiscalCabecalhoMaxAggregateOutputType | null
  }

  export type NotasFiscalCabecalhoAvgAggregateOutputType = {
    id: number | null
    numeroNota: number | null
    valorTotal: Decimal | null
    filialId: number | null
    clienteId: number | null
    vendedorId: number | null
  }

  export type NotasFiscalCabecalhoSumAggregateOutputType = {
    id: number | null
    numeroNota: number | null
    valorTotal: Decimal | null
    filialId: number | null
    clienteId: number | null
    vendedorId: number | null
  }

  export type NotasFiscalCabecalhoMinAggregateOutputType = {
    id: number | null
    numeroNota: number | null
    dataEmissao: Date | null
    valorTotal: Decimal | null
    filialId: number | null
    clienteId: number | null
    vendedorId: number | null
  }

  export type NotasFiscalCabecalhoMaxAggregateOutputType = {
    id: number | null
    numeroNota: number | null
    dataEmissao: Date | null
    valorTotal: Decimal | null
    filialId: number | null
    clienteId: number | null
    vendedorId: number | null
  }

  export type NotasFiscalCabecalhoCountAggregateOutputType = {
    id: number
    numeroNota: number
    dataEmissao: number
    valorTotal: number
    filialId: number
    clienteId: number
    vendedorId: number
    _all: number
  }


  export type NotasFiscalCabecalhoAvgAggregateInputType = {
    id?: true
    numeroNota?: true
    valorTotal?: true
    filialId?: true
    clienteId?: true
    vendedorId?: true
  }

  export type NotasFiscalCabecalhoSumAggregateInputType = {
    id?: true
    numeroNota?: true
    valorTotal?: true
    filialId?: true
    clienteId?: true
    vendedorId?: true
  }

  export type NotasFiscalCabecalhoMinAggregateInputType = {
    id?: true
    numeroNota?: true
    dataEmissao?: true
    valorTotal?: true
    filialId?: true
    clienteId?: true
    vendedorId?: true
  }

  export type NotasFiscalCabecalhoMaxAggregateInputType = {
    id?: true
    numeroNota?: true
    dataEmissao?: true
    valorTotal?: true
    filialId?: true
    clienteId?: true
    vendedorId?: true
  }

  export type NotasFiscalCabecalhoCountAggregateInputType = {
    id?: true
    numeroNota?: true
    dataEmissao?: true
    valorTotal?: true
    filialId?: true
    clienteId?: true
    vendedorId?: true
    _all?: true
  }

  export type NotasFiscalCabecalhoAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which NotasFiscalCabecalho to aggregate.
     */
    where?: NotasFiscalCabecalhoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of NotasFiscalCabecalhos to fetch.
     */
    orderBy?: NotasFiscalCabecalhoOrderByWithRelationInput | NotasFiscalCabecalhoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: NotasFiscalCabecalhoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` NotasFiscalCabecalhos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` NotasFiscalCabecalhos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned NotasFiscalCabecalhos
    **/
    _count?: true | NotasFiscalCabecalhoCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: NotasFiscalCabecalhoAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: NotasFiscalCabecalhoSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: NotasFiscalCabecalhoMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: NotasFiscalCabecalhoMaxAggregateInputType
  }

  export type GetNotasFiscalCabecalhoAggregateType<T extends NotasFiscalCabecalhoAggregateArgs> = {
        [P in keyof T & keyof AggregateNotasFiscalCabecalho]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateNotasFiscalCabecalho[P]>
      : GetScalarType<T[P], AggregateNotasFiscalCabecalho[P]>
  }




  export type NotasFiscalCabecalhoGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: NotasFiscalCabecalhoWhereInput
    orderBy?: NotasFiscalCabecalhoOrderByWithAggregationInput | NotasFiscalCabecalhoOrderByWithAggregationInput[]
    by: NotasFiscalCabecalhoScalarFieldEnum[] | NotasFiscalCabecalhoScalarFieldEnum
    having?: NotasFiscalCabecalhoScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: NotasFiscalCabecalhoCountAggregateInputType | true
    _avg?: NotasFiscalCabecalhoAvgAggregateInputType
    _sum?: NotasFiscalCabecalhoSumAggregateInputType
    _min?: NotasFiscalCabecalhoMinAggregateInputType
    _max?: NotasFiscalCabecalhoMaxAggregateInputType
  }

  export type NotasFiscalCabecalhoGroupByOutputType = {
    id: number
    numeroNota: number
    dataEmissao: Date
    valorTotal: Decimal
    filialId: number | null
    clienteId: number | null
    vendedorId: number | null
    _count: NotasFiscalCabecalhoCountAggregateOutputType | null
    _avg: NotasFiscalCabecalhoAvgAggregateOutputType | null
    _sum: NotasFiscalCabecalhoSumAggregateOutputType | null
    _min: NotasFiscalCabecalhoMinAggregateOutputType | null
    _max: NotasFiscalCabecalhoMaxAggregateOutputType | null
  }

  type GetNotasFiscalCabecalhoGroupByPayload<T extends NotasFiscalCabecalhoGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<NotasFiscalCabecalhoGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof NotasFiscalCabecalhoGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], NotasFiscalCabecalhoGroupByOutputType[P]>
            : GetScalarType<T[P], NotasFiscalCabecalhoGroupByOutputType[P]>
        }
      >
    >


  export type NotasFiscalCabecalhoSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    numeroNota?: boolean
    dataEmissao?: boolean
    valorTotal?: boolean
    filialId?: boolean
    clienteId?: boolean
    vendedorId?: boolean
    filial?: boolean | NotasFiscalCabecalho$filialArgs<ExtArgs>
    cliente?: boolean | NotasFiscalCabecalho$clienteArgs<ExtArgs>
    vendedor?: boolean | NotasFiscalCabecalho$vendedorArgs<ExtArgs>
    itens?: boolean | NotasFiscalCabecalho$itensArgs<ExtArgs>
    _count?: boolean | NotasFiscalCabecalhoCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["notasFiscalCabecalho"]>


  export type NotasFiscalCabecalhoSelectScalar = {
    id?: boolean
    numeroNota?: boolean
    dataEmissao?: boolean
    valorTotal?: boolean
    filialId?: boolean
    clienteId?: boolean
    vendedorId?: boolean
  }

  export type NotasFiscalCabecalhoInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    filial?: boolean | NotasFiscalCabecalho$filialArgs<ExtArgs>
    cliente?: boolean | NotasFiscalCabecalho$clienteArgs<ExtArgs>
    vendedor?: boolean | NotasFiscalCabecalho$vendedorArgs<ExtArgs>
    itens?: boolean | NotasFiscalCabecalho$itensArgs<ExtArgs>
    _count?: boolean | NotasFiscalCabecalhoCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $NotasFiscalCabecalhoPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "NotasFiscalCabecalho"
    objects: {
      filial: Prisma.$FilialPayload<ExtArgs> | null
      cliente: Prisma.$ClientePayload<ExtArgs> | null
      vendedor: Prisma.$VendedorPayload<ExtArgs> | null
      itens: Prisma.$NotaFiscalItemPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      numeroNota: number
      dataEmissao: Date
      valorTotal: Prisma.Decimal
      filialId: number | null
      clienteId: number | null
      vendedorId: number | null
    }, ExtArgs["result"]["notasFiscalCabecalho"]>
    composites: {}
  }

  type NotasFiscalCabecalhoGetPayload<S extends boolean | null | undefined | NotasFiscalCabecalhoDefaultArgs> = $Result.GetResult<Prisma.$NotasFiscalCabecalhoPayload, S>

  type NotasFiscalCabecalhoCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<NotasFiscalCabecalhoFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: NotasFiscalCabecalhoCountAggregateInputType | true
    }

  export interface NotasFiscalCabecalhoDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['NotasFiscalCabecalho'], meta: { name: 'NotasFiscalCabecalho' } }
    /**
     * Find zero or one NotasFiscalCabecalho that matches the filter.
     * @param {NotasFiscalCabecalhoFindUniqueArgs} args - Arguments to find a NotasFiscalCabecalho
     * @example
     * // Get one NotasFiscalCabecalho
     * const notasFiscalCabecalho = await prisma.notasFiscalCabecalho.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends NotasFiscalCabecalhoFindUniqueArgs>(args: SelectSubset<T, NotasFiscalCabecalhoFindUniqueArgs<ExtArgs>>): Prisma__NotasFiscalCabecalhoClient<$Result.GetResult<Prisma.$NotasFiscalCabecalhoPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one NotasFiscalCabecalho that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {NotasFiscalCabecalhoFindUniqueOrThrowArgs} args - Arguments to find a NotasFiscalCabecalho
     * @example
     * // Get one NotasFiscalCabecalho
     * const notasFiscalCabecalho = await prisma.notasFiscalCabecalho.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends NotasFiscalCabecalhoFindUniqueOrThrowArgs>(args: SelectSubset<T, NotasFiscalCabecalhoFindUniqueOrThrowArgs<ExtArgs>>): Prisma__NotasFiscalCabecalhoClient<$Result.GetResult<Prisma.$NotasFiscalCabecalhoPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first NotasFiscalCabecalho that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotasFiscalCabecalhoFindFirstArgs} args - Arguments to find a NotasFiscalCabecalho
     * @example
     * // Get one NotasFiscalCabecalho
     * const notasFiscalCabecalho = await prisma.notasFiscalCabecalho.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends NotasFiscalCabecalhoFindFirstArgs>(args?: SelectSubset<T, NotasFiscalCabecalhoFindFirstArgs<ExtArgs>>): Prisma__NotasFiscalCabecalhoClient<$Result.GetResult<Prisma.$NotasFiscalCabecalhoPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first NotasFiscalCabecalho that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotasFiscalCabecalhoFindFirstOrThrowArgs} args - Arguments to find a NotasFiscalCabecalho
     * @example
     * // Get one NotasFiscalCabecalho
     * const notasFiscalCabecalho = await prisma.notasFiscalCabecalho.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends NotasFiscalCabecalhoFindFirstOrThrowArgs>(args?: SelectSubset<T, NotasFiscalCabecalhoFindFirstOrThrowArgs<ExtArgs>>): Prisma__NotasFiscalCabecalhoClient<$Result.GetResult<Prisma.$NotasFiscalCabecalhoPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more NotasFiscalCabecalhos that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotasFiscalCabecalhoFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all NotasFiscalCabecalhos
     * const notasFiscalCabecalhos = await prisma.notasFiscalCabecalho.findMany()
     * 
     * // Get first 10 NotasFiscalCabecalhos
     * const notasFiscalCabecalhos = await prisma.notasFiscalCabecalho.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const notasFiscalCabecalhoWithIdOnly = await prisma.notasFiscalCabecalho.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends NotasFiscalCabecalhoFindManyArgs>(args?: SelectSubset<T, NotasFiscalCabecalhoFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotasFiscalCabecalhoPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a NotasFiscalCabecalho.
     * @param {NotasFiscalCabecalhoCreateArgs} args - Arguments to create a NotasFiscalCabecalho.
     * @example
     * // Create one NotasFiscalCabecalho
     * const NotasFiscalCabecalho = await prisma.notasFiscalCabecalho.create({
     *   data: {
     *     // ... data to create a NotasFiscalCabecalho
     *   }
     * })
     * 
     */
    create<T extends NotasFiscalCabecalhoCreateArgs>(args: SelectSubset<T, NotasFiscalCabecalhoCreateArgs<ExtArgs>>): Prisma__NotasFiscalCabecalhoClient<$Result.GetResult<Prisma.$NotasFiscalCabecalhoPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many NotasFiscalCabecalhos.
     * @param {NotasFiscalCabecalhoCreateManyArgs} args - Arguments to create many NotasFiscalCabecalhos.
     * @example
     * // Create many NotasFiscalCabecalhos
     * const notasFiscalCabecalho = await prisma.notasFiscalCabecalho.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends NotasFiscalCabecalhoCreateManyArgs>(args?: SelectSubset<T, NotasFiscalCabecalhoCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a NotasFiscalCabecalho.
     * @param {NotasFiscalCabecalhoDeleteArgs} args - Arguments to delete one NotasFiscalCabecalho.
     * @example
     * // Delete one NotasFiscalCabecalho
     * const NotasFiscalCabecalho = await prisma.notasFiscalCabecalho.delete({
     *   where: {
     *     // ... filter to delete one NotasFiscalCabecalho
     *   }
     * })
     * 
     */
    delete<T extends NotasFiscalCabecalhoDeleteArgs>(args: SelectSubset<T, NotasFiscalCabecalhoDeleteArgs<ExtArgs>>): Prisma__NotasFiscalCabecalhoClient<$Result.GetResult<Prisma.$NotasFiscalCabecalhoPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one NotasFiscalCabecalho.
     * @param {NotasFiscalCabecalhoUpdateArgs} args - Arguments to update one NotasFiscalCabecalho.
     * @example
     * // Update one NotasFiscalCabecalho
     * const notasFiscalCabecalho = await prisma.notasFiscalCabecalho.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends NotasFiscalCabecalhoUpdateArgs>(args: SelectSubset<T, NotasFiscalCabecalhoUpdateArgs<ExtArgs>>): Prisma__NotasFiscalCabecalhoClient<$Result.GetResult<Prisma.$NotasFiscalCabecalhoPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more NotasFiscalCabecalhos.
     * @param {NotasFiscalCabecalhoDeleteManyArgs} args - Arguments to filter NotasFiscalCabecalhos to delete.
     * @example
     * // Delete a few NotasFiscalCabecalhos
     * const { count } = await prisma.notasFiscalCabecalho.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends NotasFiscalCabecalhoDeleteManyArgs>(args?: SelectSubset<T, NotasFiscalCabecalhoDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more NotasFiscalCabecalhos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotasFiscalCabecalhoUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many NotasFiscalCabecalhos
     * const notasFiscalCabecalho = await prisma.notasFiscalCabecalho.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends NotasFiscalCabecalhoUpdateManyArgs>(args: SelectSubset<T, NotasFiscalCabecalhoUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one NotasFiscalCabecalho.
     * @param {NotasFiscalCabecalhoUpsertArgs} args - Arguments to update or create a NotasFiscalCabecalho.
     * @example
     * // Update or create a NotasFiscalCabecalho
     * const notasFiscalCabecalho = await prisma.notasFiscalCabecalho.upsert({
     *   create: {
     *     // ... data to create a NotasFiscalCabecalho
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the NotasFiscalCabecalho we want to update
     *   }
     * })
     */
    upsert<T extends NotasFiscalCabecalhoUpsertArgs>(args: SelectSubset<T, NotasFiscalCabecalhoUpsertArgs<ExtArgs>>): Prisma__NotasFiscalCabecalhoClient<$Result.GetResult<Prisma.$NotasFiscalCabecalhoPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of NotasFiscalCabecalhos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotasFiscalCabecalhoCountArgs} args - Arguments to filter NotasFiscalCabecalhos to count.
     * @example
     * // Count the number of NotasFiscalCabecalhos
     * const count = await prisma.notasFiscalCabecalho.count({
     *   where: {
     *     // ... the filter for the NotasFiscalCabecalhos we want to count
     *   }
     * })
    **/
    count<T extends NotasFiscalCabecalhoCountArgs>(
      args?: Subset<T, NotasFiscalCabecalhoCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], NotasFiscalCabecalhoCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a NotasFiscalCabecalho.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotasFiscalCabecalhoAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends NotasFiscalCabecalhoAggregateArgs>(args: Subset<T, NotasFiscalCabecalhoAggregateArgs>): Prisma.PrismaPromise<GetNotasFiscalCabecalhoAggregateType<T>>

    /**
     * Group by NotasFiscalCabecalho.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotasFiscalCabecalhoGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends NotasFiscalCabecalhoGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: NotasFiscalCabecalhoGroupByArgs['orderBy'] }
        : { orderBy?: NotasFiscalCabecalhoGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, NotasFiscalCabecalhoGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetNotasFiscalCabecalhoGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the NotasFiscalCabecalho model
   */
  readonly fields: NotasFiscalCabecalhoFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for NotasFiscalCabecalho.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__NotasFiscalCabecalhoClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    filial<T extends NotasFiscalCabecalho$filialArgs<ExtArgs> = {}>(args?: Subset<T, NotasFiscalCabecalho$filialArgs<ExtArgs>>): Prisma__FilialClient<$Result.GetResult<Prisma.$FilialPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    cliente<T extends NotasFiscalCabecalho$clienteArgs<ExtArgs> = {}>(args?: Subset<T, NotasFiscalCabecalho$clienteArgs<ExtArgs>>): Prisma__ClienteClient<$Result.GetResult<Prisma.$ClientePayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    vendedor<T extends NotasFiscalCabecalho$vendedorArgs<ExtArgs> = {}>(args?: Subset<T, NotasFiscalCabecalho$vendedorArgs<ExtArgs>>): Prisma__VendedorClient<$Result.GetResult<Prisma.$VendedorPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    itens<T extends NotasFiscalCabecalho$itensArgs<ExtArgs> = {}>(args?: Subset<T, NotasFiscalCabecalho$itensArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotaFiscalItemPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the NotasFiscalCabecalho model
   */ 
  interface NotasFiscalCabecalhoFieldRefs {
    readonly id: FieldRef<"NotasFiscalCabecalho", 'Int'>
    readonly numeroNota: FieldRef<"NotasFiscalCabecalho", 'Int'>
    readonly dataEmissao: FieldRef<"NotasFiscalCabecalho", 'DateTime'>
    readonly valorTotal: FieldRef<"NotasFiscalCabecalho", 'Decimal'>
    readonly filialId: FieldRef<"NotasFiscalCabecalho", 'Int'>
    readonly clienteId: FieldRef<"NotasFiscalCabecalho", 'Int'>
    readonly vendedorId: FieldRef<"NotasFiscalCabecalho", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * NotasFiscalCabecalho findUnique
   */
  export type NotasFiscalCabecalhoFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NotasFiscalCabecalho
     */
    select?: NotasFiscalCabecalhoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotasFiscalCabecalhoInclude<ExtArgs> | null
    /**
     * Filter, which NotasFiscalCabecalho to fetch.
     */
    where: NotasFiscalCabecalhoWhereUniqueInput
  }

  /**
   * NotasFiscalCabecalho findUniqueOrThrow
   */
  export type NotasFiscalCabecalhoFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NotasFiscalCabecalho
     */
    select?: NotasFiscalCabecalhoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotasFiscalCabecalhoInclude<ExtArgs> | null
    /**
     * Filter, which NotasFiscalCabecalho to fetch.
     */
    where: NotasFiscalCabecalhoWhereUniqueInput
  }

  /**
   * NotasFiscalCabecalho findFirst
   */
  export type NotasFiscalCabecalhoFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NotasFiscalCabecalho
     */
    select?: NotasFiscalCabecalhoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotasFiscalCabecalhoInclude<ExtArgs> | null
    /**
     * Filter, which NotasFiscalCabecalho to fetch.
     */
    where?: NotasFiscalCabecalhoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of NotasFiscalCabecalhos to fetch.
     */
    orderBy?: NotasFiscalCabecalhoOrderByWithRelationInput | NotasFiscalCabecalhoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for NotasFiscalCabecalhos.
     */
    cursor?: NotasFiscalCabecalhoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` NotasFiscalCabecalhos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` NotasFiscalCabecalhos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of NotasFiscalCabecalhos.
     */
    distinct?: NotasFiscalCabecalhoScalarFieldEnum | NotasFiscalCabecalhoScalarFieldEnum[]
  }

  /**
   * NotasFiscalCabecalho findFirstOrThrow
   */
  export type NotasFiscalCabecalhoFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NotasFiscalCabecalho
     */
    select?: NotasFiscalCabecalhoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotasFiscalCabecalhoInclude<ExtArgs> | null
    /**
     * Filter, which NotasFiscalCabecalho to fetch.
     */
    where?: NotasFiscalCabecalhoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of NotasFiscalCabecalhos to fetch.
     */
    orderBy?: NotasFiscalCabecalhoOrderByWithRelationInput | NotasFiscalCabecalhoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for NotasFiscalCabecalhos.
     */
    cursor?: NotasFiscalCabecalhoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` NotasFiscalCabecalhos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` NotasFiscalCabecalhos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of NotasFiscalCabecalhos.
     */
    distinct?: NotasFiscalCabecalhoScalarFieldEnum | NotasFiscalCabecalhoScalarFieldEnum[]
  }

  /**
   * NotasFiscalCabecalho findMany
   */
  export type NotasFiscalCabecalhoFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NotasFiscalCabecalho
     */
    select?: NotasFiscalCabecalhoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotasFiscalCabecalhoInclude<ExtArgs> | null
    /**
     * Filter, which NotasFiscalCabecalhos to fetch.
     */
    where?: NotasFiscalCabecalhoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of NotasFiscalCabecalhos to fetch.
     */
    orderBy?: NotasFiscalCabecalhoOrderByWithRelationInput | NotasFiscalCabecalhoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing NotasFiscalCabecalhos.
     */
    cursor?: NotasFiscalCabecalhoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` NotasFiscalCabecalhos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` NotasFiscalCabecalhos.
     */
    skip?: number
    distinct?: NotasFiscalCabecalhoScalarFieldEnum | NotasFiscalCabecalhoScalarFieldEnum[]
  }

  /**
   * NotasFiscalCabecalho create
   */
  export type NotasFiscalCabecalhoCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NotasFiscalCabecalho
     */
    select?: NotasFiscalCabecalhoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotasFiscalCabecalhoInclude<ExtArgs> | null
    /**
     * The data needed to create a NotasFiscalCabecalho.
     */
    data: XOR<NotasFiscalCabecalhoCreateInput, NotasFiscalCabecalhoUncheckedCreateInput>
  }

  /**
   * NotasFiscalCabecalho createMany
   */
  export type NotasFiscalCabecalhoCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many NotasFiscalCabecalhos.
     */
    data: NotasFiscalCabecalhoCreateManyInput | NotasFiscalCabecalhoCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * NotasFiscalCabecalho update
   */
  export type NotasFiscalCabecalhoUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NotasFiscalCabecalho
     */
    select?: NotasFiscalCabecalhoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotasFiscalCabecalhoInclude<ExtArgs> | null
    /**
     * The data needed to update a NotasFiscalCabecalho.
     */
    data: XOR<NotasFiscalCabecalhoUpdateInput, NotasFiscalCabecalhoUncheckedUpdateInput>
    /**
     * Choose, which NotasFiscalCabecalho to update.
     */
    where: NotasFiscalCabecalhoWhereUniqueInput
  }

  /**
   * NotasFiscalCabecalho updateMany
   */
  export type NotasFiscalCabecalhoUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update NotasFiscalCabecalhos.
     */
    data: XOR<NotasFiscalCabecalhoUpdateManyMutationInput, NotasFiscalCabecalhoUncheckedUpdateManyInput>
    /**
     * Filter which NotasFiscalCabecalhos to update
     */
    where?: NotasFiscalCabecalhoWhereInput
  }

  /**
   * NotasFiscalCabecalho upsert
   */
  export type NotasFiscalCabecalhoUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NotasFiscalCabecalho
     */
    select?: NotasFiscalCabecalhoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotasFiscalCabecalhoInclude<ExtArgs> | null
    /**
     * The filter to search for the NotasFiscalCabecalho to update in case it exists.
     */
    where: NotasFiscalCabecalhoWhereUniqueInput
    /**
     * In case the NotasFiscalCabecalho found by the `where` argument doesn't exist, create a new NotasFiscalCabecalho with this data.
     */
    create: XOR<NotasFiscalCabecalhoCreateInput, NotasFiscalCabecalhoUncheckedCreateInput>
    /**
     * In case the NotasFiscalCabecalho was found with the provided `where` argument, update it with this data.
     */
    update: XOR<NotasFiscalCabecalhoUpdateInput, NotasFiscalCabecalhoUncheckedUpdateInput>
  }

  /**
   * NotasFiscalCabecalho delete
   */
  export type NotasFiscalCabecalhoDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NotasFiscalCabecalho
     */
    select?: NotasFiscalCabecalhoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotasFiscalCabecalhoInclude<ExtArgs> | null
    /**
     * Filter which NotasFiscalCabecalho to delete.
     */
    where: NotasFiscalCabecalhoWhereUniqueInput
  }

  /**
   * NotasFiscalCabecalho deleteMany
   */
  export type NotasFiscalCabecalhoDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which NotasFiscalCabecalhos to delete
     */
    where?: NotasFiscalCabecalhoWhereInput
  }

  /**
   * NotasFiscalCabecalho.filial
   */
  export type NotasFiscalCabecalho$filialArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Filial
     */
    select?: FilialSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FilialInclude<ExtArgs> | null
    where?: FilialWhereInput
  }

  /**
   * NotasFiscalCabecalho.cliente
   */
  export type NotasFiscalCabecalho$clienteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Cliente
     */
    select?: ClienteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClienteInclude<ExtArgs> | null
    where?: ClienteWhereInput
  }

  /**
   * NotasFiscalCabecalho.vendedor
   */
  export type NotasFiscalCabecalho$vendedorArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Vendedor
     */
    select?: VendedorSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VendedorInclude<ExtArgs> | null
    where?: VendedorWhereInput
  }

  /**
   * NotasFiscalCabecalho.itens
   */
  export type NotasFiscalCabecalho$itensArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NotaFiscalItem
     */
    select?: NotaFiscalItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotaFiscalItemInclude<ExtArgs> | null
    where?: NotaFiscalItemWhereInput
    orderBy?: NotaFiscalItemOrderByWithRelationInput | NotaFiscalItemOrderByWithRelationInput[]
    cursor?: NotaFiscalItemWhereUniqueInput
    take?: number
    skip?: number
    distinct?: NotaFiscalItemScalarFieldEnum | NotaFiscalItemScalarFieldEnum[]
  }

  /**
   * NotasFiscalCabecalho without action
   */
  export type NotasFiscalCabecalhoDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NotasFiscalCabecalho
     */
    select?: NotasFiscalCabecalhoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotasFiscalCabecalhoInclude<ExtArgs> | null
  }


  /**
   * Model NotaFiscalItem
   */

  export type AggregateNotaFiscalItem = {
    _count: NotaFiscalItemCountAggregateOutputType | null
    _avg: NotaFiscalItemAvgAggregateOutputType | null
    _sum: NotaFiscalItemSumAggregateOutputType | null
    _min: NotaFiscalItemMinAggregateOutputType | null
    _max: NotaFiscalItemMaxAggregateOutputType | null
  }

  export type NotaFiscalItemAvgAggregateOutputType = {
    id: number | null
    notaFiscalId: number | null
    produtoId: number | null
    Quantidade: Decimal | null
    valorUnitario: Decimal | null
    valorTotalItem: Decimal | null
  }

  export type NotaFiscalItemSumAggregateOutputType = {
    id: number | null
    notaFiscalId: number | null
    produtoId: number | null
    Quantidade: Decimal | null
    valorUnitario: Decimal | null
    valorTotalItem: Decimal | null
  }

  export type NotaFiscalItemMinAggregateOutputType = {
    id: number | null
    notaFiscalId: number | null
    produtoId: number | null
    Quantidade: Decimal | null
    valorUnitario: Decimal | null
    valorTotalItem: Decimal | null
    Chassi: string | null
  }

  export type NotaFiscalItemMaxAggregateOutputType = {
    id: number | null
    notaFiscalId: number | null
    produtoId: number | null
    Quantidade: Decimal | null
    valorUnitario: Decimal | null
    valorTotalItem: Decimal | null
    Chassi: string | null
  }

  export type NotaFiscalItemCountAggregateOutputType = {
    id: number
    notaFiscalId: number
    produtoId: number
    Quantidade: number
    valorUnitario: number
    valorTotalItem: number
    Chassi: number
    _all: number
  }


  export type NotaFiscalItemAvgAggregateInputType = {
    id?: true
    notaFiscalId?: true
    produtoId?: true
    Quantidade?: true
    valorUnitario?: true
    valorTotalItem?: true
  }

  export type NotaFiscalItemSumAggregateInputType = {
    id?: true
    notaFiscalId?: true
    produtoId?: true
    Quantidade?: true
    valorUnitario?: true
    valorTotalItem?: true
  }

  export type NotaFiscalItemMinAggregateInputType = {
    id?: true
    notaFiscalId?: true
    produtoId?: true
    Quantidade?: true
    valorUnitario?: true
    valorTotalItem?: true
    Chassi?: true
  }

  export type NotaFiscalItemMaxAggregateInputType = {
    id?: true
    notaFiscalId?: true
    produtoId?: true
    Quantidade?: true
    valorUnitario?: true
    valorTotalItem?: true
    Chassi?: true
  }

  export type NotaFiscalItemCountAggregateInputType = {
    id?: true
    notaFiscalId?: true
    produtoId?: true
    Quantidade?: true
    valorUnitario?: true
    valorTotalItem?: true
    Chassi?: true
    _all?: true
  }

  export type NotaFiscalItemAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which NotaFiscalItem to aggregate.
     */
    where?: NotaFiscalItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of NotaFiscalItems to fetch.
     */
    orderBy?: NotaFiscalItemOrderByWithRelationInput | NotaFiscalItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: NotaFiscalItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` NotaFiscalItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` NotaFiscalItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned NotaFiscalItems
    **/
    _count?: true | NotaFiscalItemCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: NotaFiscalItemAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: NotaFiscalItemSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: NotaFiscalItemMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: NotaFiscalItemMaxAggregateInputType
  }

  export type GetNotaFiscalItemAggregateType<T extends NotaFiscalItemAggregateArgs> = {
        [P in keyof T & keyof AggregateNotaFiscalItem]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateNotaFiscalItem[P]>
      : GetScalarType<T[P], AggregateNotaFiscalItem[P]>
  }




  export type NotaFiscalItemGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: NotaFiscalItemWhereInput
    orderBy?: NotaFiscalItemOrderByWithAggregationInput | NotaFiscalItemOrderByWithAggregationInput[]
    by: NotaFiscalItemScalarFieldEnum[] | NotaFiscalItemScalarFieldEnum
    having?: NotaFiscalItemScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: NotaFiscalItemCountAggregateInputType | true
    _avg?: NotaFiscalItemAvgAggregateInputType
    _sum?: NotaFiscalItemSumAggregateInputType
    _min?: NotaFiscalItemMinAggregateInputType
    _max?: NotaFiscalItemMaxAggregateInputType
  }

  export type NotaFiscalItemGroupByOutputType = {
    id: number
    notaFiscalId: number
    produtoId: number
    Quantidade: Decimal
    valorUnitario: Decimal
    valorTotalItem: Decimal
    Chassi: string | null
    _count: NotaFiscalItemCountAggregateOutputType | null
    _avg: NotaFiscalItemAvgAggregateOutputType | null
    _sum: NotaFiscalItemSumAggregateOutputType | null
    _min: NotaFiscalItemMinAggregateOutputType | null
    _max: NotaFiscalItemMaxAggregateOutputType | null
  }

  type GetNotaFiscalItemGroupByPayload<T extends NotaFiscalItemGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<NotaFiscalItemGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof NotaFiscalItemGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], NotaFiscalItemGroupByOutputType[P]>
            : GetScalarType<T[P], NotaFiscalItemGroupByOutputType[P]>
        }
      >
    >


  export type NotaFiscalItemSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    notaFiscalId?: boolean
    produtoId?: boolean
    Quantidade?: boolean
    valorUnitario?: boolean
    valorTotalItem?: boolean
    Chassi?: boolean
    Maquinas_Estoque?: boolean | NotaFiscalItem$Maquinas_EstoqueArgs<ExtArgs>
    notaFiscal?: boolean | NotasFiscalCabecalhoDefaultArgs<ExtArgs>
    produto?: boolean | ProdutoDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["notaFiscalItem"]>


  export type NotaFiscalItemSelectScalar = {
    id?: boolean
    notaFiscalId?: boolean
    produtoId?: boolean
    Quantidade?: boolean
    valorUnitario?: boolean
    valorTotalItem?: boolean
    Chassi?: boolean
  }

  export type NotaFiscalItemInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Maquinas_Estoque?: boolean | NotaFiscalItem$Maquinas_EstoqueArgs<ExtArgs>
    notaFiscal?: boolean | NotasFiscalCabecalhoDefaultArgs<ExtArgs>
    produto?: boolean | ProdutoDefaultArgs<ExtArgs>
  }

  export type $NotaFiscalItemPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "NotaFiscalItem"
    objects: {
      Maquinas_Estoque: Prisma.$MaquinaEstoquePayload<ExtArgs> | null
      notaFiscal: Prisma.$NotasFiscalCabecalhoPayload<ExtArgs>
      produto: Prisma.$ProdutoPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      notaFiscalId: number
      produtoId: number
      Quantidade: Prisma.Decimal
      valorUnitario: Prisma.Decimal
      valorTotalItem: Prisma.Decimal
      Chassi: string | null
    }, ExtArgs["result"]["notaFiscalItem"]>
    composites: {}
  }

  type NotaFiscalItemGetPayload<S extends boolean | null | undefined | NotaFiscalItemDefaultArgs> = $Result.GetResult<Prisma.$NotaFiscalItemPayload, S>

  type NotaFiscalItemCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<NotaFiscalItemFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: NotaFiscalItemCountAggregateInputType | true
    }

  export interface NotaFiscalItemDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['NotaFiscalItem'], meta: { name: 'NotaFiscalItem' } }
    /**
     * Find zero or one NotaFiscalItem that matches the filter.
     * @param {NotaFiscalItemFindUniqueArgs} args - Arguments to find a NotaFiscalItem
     * @example
     * // Get one NotaFiscalItem
     * const notaFiscalItem = await prisma.notaFiscalItem.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends NotaFiscalItemFindUniqueArgs>(args: SelectSubset<T, NotaFiscalItemFindUniqueArgs<ExtArgs>>): Prisma__NotaFiscalItemClient<$Result.GetResult<Prisma.$NotaFiscalItemPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one NotaFiscalItem that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {NotaFiscalItemFindUniqueOrThrowArgs} args - Arguments to find a NotaFiscalItem
     * @example
     * // Get one NotaFiscalItem
     * const notaFiscalItem = await prisma.notaFiscalItem.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends NotaFiscalItemFindUniqueOrThrowArgs>(args: SelectSubset<T, NotaFiscalItemFindUniqueOrThrowArgs<ExtArgs>>): Prisma__NotaFiscalItemClient<$Result.GetResult<Prisma.$NotaFiscalItemPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first NotaFiscalItem that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotaFiscalItemFindFirstArgs} args - Arguments to find a NotaFiscalItem
     * @example
     * // Get one NotaFiscalItem
     * const notaFiscalItem = await prisma.notaFiscalItem.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends NotaFiscalItemFindFirstArgs>(args?: SelectSubset<T, NotaFiscalItemFindFirstArgs<ExtArgs>>): Prisma__NotaFiscalItemClient<$Result.GetResult<Prisma.$NotaFiscalItemPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first NotaFiscalItem that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotaFiscalItemFindFirstOrThrowArgs} args - Arguments to find a NotaFiscalItem
     * @example
     * // Get one NotaFiscalItem
     * const notaFiscalItem = await prisma.notaFiscalItem.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends NotaFiscalItemFindFirstOrThrowArgs>(args?: SelectSubset<T, NotaFiscalItemFindFirstOrThrowArgs<ExtArgs>>): Prisma__NotaFiscalItemClient<$Result.GetResult<Prisma.$NotaFiscalItemPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more NotaFiscalItems that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotaFiscalItemFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all NotaFiscalItems
     * const notaFiscalItems = await prisma.notaFiscalItem.findMany()
     * 
     * // Get first 10 NotaFiscalItems
     * const notaFiscalItems = await prisma.notaFiscalItem.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const notaFiscalItemWithIdOnly = await prisma.notaFiscalItem.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends NotaFiscalItemFindManyArgs>(args?: SelectSubset<T, NotaFiscalItemFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotaFiscalItemPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a NotaFiscalItem.
     * @param {NotaFiscalItemCreateArgs} args - Arguments to create a NotaFiscalItem.
     * @example
     * // Create one NotaFiscalItem
     * const NotaFiscalItem = await prisma.notaFiscalItem.create({
     *   data: {
     *     // ... data to create a NotaFiscalItem
     *   }
     * })
     * 
     */
    create<T extends NotaFiscalItemCreateArgs>(args: SelectSubset<T, NotaFiscalItemCreateArgs<ExtArgs>>): Prisma__NotaFiscalItemClient<$Result.GetResult<Prisma.$NotaFiscalItemPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many NotaFiscalItems.
     * @param {NotaFiscalItemCreateManyArgs} args - Arguments to create many NotaFiscalItems.
     * @example
     * // Create many NotaFiscalItems
     * const notaFiscalItem = await prisma.notaFiscalItem.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends NotaFiscalItemCreateManyArgs>(args?: SelectSubset<T, NotaFiscalItemCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a NotaFiscalItem.
     * @param {NotaFiscalItemDeleteArgs} args - Arguments to delete one NotaFiscalItem.
     * @example
     * // Delete one NotaFiscalItem
     * const NotaFiscalItem = await prisma.notaFiscalItem.delete({
     *   where: {
     *     // ... filter to delete one NotaFiscalItem
     *   }
     * })
     * 
     */
    delete<T extends NotaFiscalItemDeleteArgs>(args: SelectSubset<T, NotaFiscalItemDeleteArgs<ExtArgs>>): Prisma__NotaFiscalItemClient<$Result.GetResult<Prisma.$NotaFiscalItemPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one NotaFiscalItem.
     * @param {NotaFiscalItemUpdateArgs} args - Arguments to update one NotaFiscalItem.
     * @example
     * // Update one NotaFiscalItem
     * const notaFiscalItem = await prisma.notaFiscalItem.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends NotaFiscalItemUpdateArgs>(args: SelectSubset<T, NotaFiscalItemUpdateArgs<ExtArgs>>): Prisma__NotaFiscalItemClient<$Result.GetResult<Prisma.$NotaFiscalItemPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more NotaFiscalItems.
     * @param {NotaFiscalItemDeleteManyArgs} args - Arguments to filter NotaFiscalItems to delete.
     * @example
     * // Delete a few NotaFiscalItems
     * const { count } = await prisma.notaFiscalItem.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends NotaFiscalItemDeleteManyArgs>(args?: SelectSubset<T, NotaFiscalItemDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more NotaFiscalItems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotaFiscalItemUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many NotaFiscalItems
     * const notaFiscalItem = await prisma.notaFiscalItem.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends NotaFiscalItemUpdateManyArgs>(args: SelectSubset<T, NotaFiscalItemUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one NotaFiscalItem.
     * @param {NotaFiscalItemUpsertArgs} args - Arguments to update or create a NotaFiscalItem.
     * @example
     * // Update or create a NotaFiscalItem
     * const notaFiscalItem = await prisma.notaFiscalItem.upsert({
     *   create: {
     *     // ... data to create a NotaFiscalItem
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the NotaFiscalItem we want to update
     *   }
     * })
     */
    upsert<T extends NotaFiscalItemUpsertArgs>(args: SelectSubset<T, NotaFiscalItemUpsertArgs<ExtArgs>>): Prisma__NotaFiscalItemClient<$Result.GetResult<Prisma.$NotaFiscalItemPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of NotaFiscalItems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotaFiscalItemCountArgs} args - Arguments to filter NotaFiscalItems to count.
     * @example
     * // Count the number of NotaFiscalItems
     * const count = await prisma.notaFiscalItem.count({
     *   where: {
     *     // ... the filter for the NotaFiscalItems we want to count
     *   }
     * })
    **/
    count<T extends NotaFiscalItemCountArgs>(
      args?: Subset<T, NotaFiscalItemCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], NotaFiscalItemCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a NotaFiscalItem.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotaFiscalItemAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends NotaFiscalItemAggregateArgs>(args: Subset<T, NotaFiscalItemAggregateArgs>): Prisma.PrismaPromise<GetNotaFiscalItemAggregateType<T>>

    /**
     * Group by NotaFiscalItem.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotaFiscalItemGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends NotaFiscalItemGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: NotaFiscalItemGroupByArgs['orderBy'] }
        : { orderBy?: NotaFiscalItemGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, NotaFiscalItemGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetNotaFiscalItemGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the NotaFiscalItem model
   */
  readonly fields: NotaFiscalItemFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for NotaFiscalItem.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__NotaFiscalItemClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    Maquinas_Estoque<T extends NotaFiscalItem$Maquinas_EstoqueArgs<ExtArgs> = {}>(args?: Subset<T, NotaFiscalItem$Maquinas_EstoqueArgs<ExtArgs>>): Prisma__MaquinaEstoqueClient<$Result.GetResult<Prisma.$MaquinaEstoquePayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    notaFiscal<T extends NotasFiscalCabecalhoDefaultArgs<ExtArgs> = {}>(args?: Subset<T, NotasFiscalCabecalhoDefaultArgs<ExtArgs>>): Prisma__NotasFiscalCabecalhoClient<$Result.GetResult<Prisma.$NotasFiscalCabecalhoPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    produto<T extends ProdutoDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ProdutoDefaultArgs<ExtArgs>>): Prisma__ProdutoClient<$Result.GetResult<Prisma.$ProdutoPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the NotaFiscalItem model
   */ 
  interface NotaFiscalItemFieldRefs {
    readonly id: FieldRef<"NotaFiscalItem", 'Int'>
    readonly notaFiscalId: FieldRef<"NotaFiscalItem", 'Int'>
    readonly produtoId: FieldRef<"NotaFiscalItem", 'Int'>
    readonly Quantidade: FieldRef<"NotaFiscalItem", 'Decimal'>
    readonly valorUnitario: FieldRef<"NotaFiscalItem", 'Decimal'>
    readonly valorTotalItem: FieldRef<"NotaFiscalItem", 'Decimal'>
    readonly Chassi: FieldRef<"NotaFiscalItem", 'String'>
  }
    

  // Custom InputTypes
  /**
   * NotaFiscalItem findUnique
   */
  export type NotaFiscalItemFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NotaFiscalItem
     */
    select?: NotaFiscalItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotaFiscalItemInclude<ExtArgs> | null
    /**
     * Filter, which NotaFiscalItem to fetch.
     */
    where: NotaFiscalItemWhereUniqueInput
  }

  /**
   * NotaFiscalItem findUniqueOrThrow
   */
  export type NotaFiscalItemFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NotaFiscalItem
     */
    select?: NotaFiscalItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotaFiscalItemInclude<ExtArgs> | null
    /**
     * Filter, which NotaFiscalItem to fetch.
     */
    where: NotaFiscalItemWhereUniqueInput
  }

  /**
   * NotaFiscalItem findFirst
   */
  export type NotaFiscalItemFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NotaFiscalItem
     */
    select?: NotaFiscalItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotaFiscalItemInclude<ExtArgs> | null
    /**
     * Filter, which NotaFiscalItem to fetch.
     */
    where?: NotaFiscalItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of NotaFiscalItems to fetch.
     */
    orderBy?: NotaFiscalItemOrderByWithRelationInput | NotaFiscalItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for NotaFiscalItems.
     */
    cursor?: NotaFiscalItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` NotaFiscalItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` NotaFiscalItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of NotaFiscalItems.
     */
    distinct?: NotaFiscalItemScalarFieldEnum | NotaFiscalItemScalarFieldEnum[]
  }

  /**
   * NotaFiscalItem findFirstOrThrow
   */
  export type NotaFiscalItemFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NotaFiscalItem
     */
    select?: NotaFiscalItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotaFiscalItemInclude<ExtArgs> | null
    /**
     * Filter, which NotaFiscalItem to fetch.
     */
    where?: NotaFiscalItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of NotaFiscalItems to fetch.
     */
    orderBy?: NotaFiscalItemOrderByWithRelationInput | NotaFiscalItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for NotaFiscalItems.
     */
    cursor?: NotaFiscalItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` NotaFiscalItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` NotaFiscalItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of NotaFiscalItems.
     */
    distinct?: NotaFiscalItemScalarFieldEnum | NotaFiscalItemScalarFieldEnum[]
  }

  /**
   * NotaFiscalItem findMany
   */
  export type NotaFiscalItemFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NotaFiscalItem
     */
    select?: NotaFiscalItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotaFiscalItemInclude<ExtArgs> | null
    /**
     * Filter, which NotaFiscalItems to fetch.
     */
    where?: NotaFiscalItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of NotaFiscalItems to fetch.
     */
    orderBy?: NotaFiscalItemOrderByWithRelationInput | NotaFiscalItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing NotaFiscalItems.
     */
    cursor?: NotaFiscalItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` NotaFiscalItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` NotaFiscalItems.
     */
    skip?: number
    distinct?: NotaFiscalItemScalarFieldEnum | NotaFiscalItemScalarFieldEnum[]
  }

  /**
   * NotaFiscalItem create
   */
  export type NotaFiscalItemCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NotaFiscalItem
     */
    select?: NotaFiscalItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotaFiscalItemInclude<ExtArgs> | null
    /**
     * The data needed to create a NotaFiscalItem.
     */
    data: XOR<NotaFiscalItemCreateInput, NotaFiscalItemUncheckedCreateInput>
  }

  /**
   * NotaFiscalItem createMany
   */
  export type NotaFiscalItemCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many NotaFiscalItems.
     */
    data: NotaFiscalItemCreateManyInput | NotaFiscalItemCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * NotaFiscalItem update
   */
  export type NotaFiscalItemUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NotaFiscalItem
     */
    select?: NotaFiscalItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotaFiscalItemInclude<ExtArgs> | null
    /**
     * The data needed to update a NotaFiscalItem.
     */
    data: XOR<NotaFiscalItemUpdateInput, NotaFiscalItemUncheckedUpdateInput>
    /**
     * Choose, which NotaFiscalItem to update.
     */
    where: NotaFiscalItemWhereUniqueInput
  }

  /**
   * NotaFiscalItem updateMany
   */
  export type NotaFiscalItemUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update NotaFiscalItems.
     */
    data: XOR<NotaFiscalItemUpdateManyMutationInput, NotaFiscalItemUncheckedUpdateManyInput>
    /**
     * Filter which NotaFiscalItems to update
     */
    where?: NotaFiscalItemWhereInput
  }

  /**
   * NotaFiscalItem upsert
   */
  export type NotaFiscalItemUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NotaFiscalItem
     */
    select?: NotaFiscalItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotaFiscalItemInclude<ExtArgs> | null
    /**
     * The filter to search for the NotaFiscalItem to update in case it exists.
     */
    where: NotaFiscalItemWhereUniqueInput
    /**
     * In case the NotaFiscalItem found by the `where` argument doesn't exist, create a new NotaFiscalItem with this data.
     */
    create: XOR<NotaFiscalItemCreateInput, NotaFiscalItemUncheckedCreateInput>
    /**
     * In case the NotaFiscalItem was found with the provided `where` argument, update it with this data.
     */
    update: XOR<NotaFiscalItemUpdateInput, NotaFiscalItemUncheckedUpdateInput>
  }

  /**
   * NotaFiscalItem delete
   */
  export type NotaFiscalItemDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NotaFiscalItem
     */
    select?: NotaFiscalItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotaFiscalItemInclude<ExtArgs> | null
    /**
     * Filter which NotaFiscalItem to delete.
     */
    where: NotaFiscalItemWhereUniqueInput
  }

  /**
   * NotaFiscalItem deleteMany
   */
  export type NotaFiscalItemDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which NotaFiscalItems to delete
     */
    where?: NotaFiscalItemWhereInput
  }

  /**
   * NotaFiscalItem.Maquinas_Estoque
   */
  export type NotaFiscalItem$Maquinas_EstoqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MaquinaEstoque
     */
    select?: MaquinaEstoqueSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MaquinaEstoqueInclude<ExtArgs> | null
    where?: MaquinaEstoqueWhereInput
  }

  /**
   * NotaFiscalItem without action
   */
  export type NotaFiscalItemDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NotaFiscalItem
     */
    select?: NotaFiscalItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotaFiscalItemInclude<ExtArgs> | null
  }


  /**
   * Model User
   */

  export type AggregateUser = {
    _count: UserCountAggregateOutputType | null
    _avg: UserAvgAggregateOutputType | null
    _sum: UserSumAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  export type UserAvgAggregateOutputType = {
    id: number | null
  }

  export type UserSumAggregateOutputType = {
    id: number | null
  }

  export type UserMinAggregateOutputType = {
    id: number | null
    email: string | null
    password: string | null
    createdAt: Date | null
  }

  export type UserMaxAggregateOutputType = {
    id: number | null
    email: string | null
    password: string | null
    createdAt: Date | null
  }

  export type UserCountAggregateOutputType = {
    id: number
    email: number
    password: number
    createdAt: number
    _all: number
  }


  export type UserAvgAggregateInputType = {
    id?: true
  }

  export type UserSumAggregateInputType = {
    id?: true
  }

  export type UserMinAggregateInputType = {
    id?: true
    email?: true
    password?: true
    createdAt?: true
  }

  export type UserMaxAggregateInputType = {
    id?: true
    email?: true
    password?: true
    createdAt?: true
  }

  export type UserCountAggregateInputType = {
    id?: true
    email?: true
    password?: true
    createdAt?: true
    _all?: true
  }

  export type UserAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which User to aggregate.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Users
    **/
    _count?: true | UserCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: UserAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: UserSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserMaxAggregateInputType
  }

  export type GetUserAggregateType<T extends UserAggregateArgs> = {
        [P in keyof T & keyof AggregateUser]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUser[P]>
      : GetScalarType<T[P], AggregateUser[P]>
  }




  export type UserGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserWhereInput
    orderBy?: UserOrderByWithAggregationInput | UserOrderByWithAggregationInput[]
    by: UserScalarFieldEnum[] | UserScalarFieldEnum
    having?: UserScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserCountAggregateInputType | true
    _avg?: UserAvgAggregateInputType
    _sum?: UserSumAggregateInputType
    _min?: UserMinAggregateInputType
    _max?: UserMaxAggregateInputType
  }

  export type UserGroupByOutputType = {
    id: number
    email: string
    password: string
    createdAt: Date
    _count: UserCountAggregateOutputType | null
    _avg: UserAvgAggregateOutputType | null
    _sum: UserSumAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  type GetUserGroupByPayload<T extends UserGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserGroupByOutputType[P]>
            : GetScalarType<T[P], UserGroupByOutputType[P]>
        }
      >
    >


  export type UserSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    password?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["user"]>


  export type UserSelectScalar = {
    id?: boolean
    email?: boolean
    password?: boolean
    createdAt?: boolean
  }


  export type $UserPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "User"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: number
      email: string
      password: string
      createdAt: Date
    }, ExtArgs["result"]["user"]>
    composites: {}
  }

  type UserGetPayload<S extends boolean | null | undefined | UserDefaultArgs> = $Result.GetResult<Prisma.$UserPayload, S>

  type UserCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<UserFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: UserCountAggregateInputType | true
    }

  export interface UserDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['User'], meta: { name: 'User' } }
    /**
     * Find zero or one User that matches the filter.
     * @param {UserFindUniqueArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserFindUniqueArgs>(args: SelectSubset<T, UserFindUniqueArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one User that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {UserFindUniqueOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserFindUniqueOrThrowArgs>(args: SelectSubset<T, UserFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first User that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserFindFirstArgs>(args?: SelectSubset<T, UserFindFirstArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first User that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserFindFirstOrThrowArgs>(args?: SelectSubset<T, UserFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Users that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Users
     * const users = await prisma.user.findMany()
     * 
     * // Get first 10 Users
     * const users = await prisma.user.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userWithIdOnly = await prisma.user.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UserFindManyArgs>(args?: SelectSubset<T, UserFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a User.
     * @param {UserCreateArgs} args - Arguments to create a User.
     * @example
     * // Create one User
     * const User = await prisma.user.create({
     *   data: {
     *     // ... data to create a User
     *   }
     * })
     * 
     */
    create<T extends UserCreateArgs>(args: SelectSubset<T, UserCreateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Users.
     * @param {UserCreateManyArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserCreateManyArgs>(args?: SelectSubset<T, UserCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a User.
     * @param {UserDeleteArgs} args - Arguments to delete one User.
     * @example
     * // Delete one User
     * const User = await prisma.user.delete({
     *   where: {
     *     // ... filter to delete one User
     *   }
     * })
     * 
     */
    delete<T extends UserDeleteArgs>(args: SelectSubset<T, UserDeleteArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one User.
     * @param {UserUpdateArgs} args - Arguments to update one User.
     * @example
     * // Update one User
     * const user = await prisma.user.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserUpdateArgs>(args: SelectSubset<T, UserUpdateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Users.
     * @param {UserDeleteManyArgs} args - Arguments to filter Users to delete.
     * @example
     * // Delete a few Users
     * const { count } = await prisma.user.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserDeleteManyArgs>(args?: SelectSubset<T, UserDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserUpdateManyArgs>(args: SelectSubset<T, UserUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one User.
     * @param {UserUpsertArgs} args - Arguments to update or create a User.
     * @example
     * // Update or create a User
     * const user = await prisma.user.upsert({
     *   create: {
     *     // ... data to create a User
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the User we want to update
     *   }
     * })
     */
    upsert<T extends UserUpsertArgs>(args: SelectSubset<T, UserUpsertArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserCountArgs} args - Arguments to filter Users to count.
     * @example
     * // Count the number of Users
     * const count = await prisma.user.count({
     *   where: {
     *     // ... the filter for the Users we want to count
     *   }
     * })
    **/
    count<T extends UserCountArgs>(
      args?: Subset<T, UserCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserAggregateArgs>(args: Subset<T, UserAggregateArgs>): Prisma.PrismaPromise<GetUserAggregateType<T>>

    /**
     * Group by User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserGroupByArgs['orderBy'] }
        : { orderBy?: UserGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the User model
   */
  readonly fields: UserFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for User.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the User model
   */ 
  interface UserFieldRefs {
    readonly id: FieldRef<"User", 'Int'>
    readonly email: FieldRef<"User", 'String'>
    readonly password: FieldRef<"User", 'String'>
    readonly createdAt: FieldRef<"User", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * User findUnique
   */
  export type UserFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findUniqueOrThrow
   */
  export type UserFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findFirst
   */
  export type UserFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findFirstOrThrow
   */
  export type UserFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findMany
   */
  export type UserFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Filter, which Users to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User create
   */
  export type UserCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * The data needed to create a User.
     */
    data: XOR<UserCreateInput, UserUncheckedCreateInput>
  }

  /**
   * User createMany
   */
  export type UserCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * User update
   */
  export type UserUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * The data needed to update a User.
     */
    data: XOR<UserUpdateInput, UserUncheckedUpdateInput>
    /**
     * Choose, which User to update.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User updateMany
   */
  export type UserUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Users.
     */
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     */
    where?: UserWhereInput
  }

  /**
   * User upsert
   */
  export type UserUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * The filter to search for the User to update in case it exists.
     */
    where: UserWhereUniqueInput
    /**
     * In case the User found by the `where` argument doesn't exist, create a new User with this data.
     */
    create: XOR<UserCreateInput, UserUncheckedCreateInput>
    /**
     * In case the User was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserUpdateInput, UserUncheckedUpdateInput>
  }

  /**
   * User delete
   */
  export type UserDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Filter which User to delete.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User deleteMany
   */
  export type UserDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Users to delete
     */
    where?: UserWhereInput
  }

  /**
   * User without action
   */
  export type UserDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
  }


  /**
   * Model RfvParameterSet
   */

  export type AggregateRfvParameterSet = {
    _count: RfvParameterSetCountAggregateOutputType | null
    _avg: RfvParameterSetAvgAggregateOutputType | null
    _sum: RfvParameterSetSumAggregateOutputType | null
    _min: RfvParameterSetMinAggregateOutputType | null
    _max: RfvParameterSetMaxAggregateOutputType | null
  }

  export type RfvParameterSetAvgAggregateOutputType = {
    id: number | null
    filialId: number | null
    windowDays: number | null
  }

  export type RfvParameterSetSumAggregateOutputType = {
    id: number | null
    filialId: number | null
    windowDays: number | null
  }

  export type RfvParameterSetMinAggregateOutputType = {
    id: number | null
    filialId: number | null
    name: string | null
    strategy: $Enums.RfvStrategy | null
    windowDays: number | null
    effectiveFrom: Date | null
    effectiveTo: Date | null
    createdAt: Date | null
    updatedAt: Date | null
    calculationStrategy: $Enums.CalculationStrategy | null
  }

  export type RfvParameterSetMaxAggregateOutputType = {
    id: number | null
    filialId: number | null
    name: string | null
    strategy: $Enums.RfvStrategy | null
    windowDays: number | null
    effectiveFrom: Date | null
    effectiveTo: Date | null
    createdAt: Date | null
    updatedAt: Date | null
    calculationStrategy: $Enums.CalculationStrategy | null
  }

  export type RfvParameterSetCountAggregateOutputType = {
    id: number
    filialId: number
    name: number
    strategy: number
    windowDays: number
    weights: number
    ruleRecency: number
    ruleFrequency: number
    ruleValue: number
    effectiveFrom: number
    effectiveTo: number
    createdAt: number
    updatedAt: number
    calculationStrategy: number
    classRanges: number
    conditionalRules: number
    _all: number
  }


  export type RfvParameterSetAvgAggregateInputType = {
    id?: true
    filialId?: true
    windowDays?: true
  }

  export type RfvParameterSetSumAggregateInputType = {
    id?: true
    filialId?: true
    windowDays?: true
  }

  export type RfvParameterSetMinAggregateInputType = {
    id?: true
    filialId?: true
    name?: true
    strategy?: true
    windowDays?: true
    effectiveFrom?: true
    effectiveTo?: true
    createdAt?: true
    updatedAt?: true
    calculationStrategy?: true
  }

  export type RfvParameterSetMaxAggregateInputType = {
    id?: true
    filialId?: true
    name?: true
    strategy?: true
    windowDays?: true
    effectiveFrom?: true
    effectiveTo?: true
    createdAt?: true
    updatedAt?: true
    calculationStrategy?: true
  }

  export type RfvParameterSetCountAggregateInputType = {
    id?: true
    filialId?: true
    name?: true
    strategy?: true
    windowDays?: true
    weights?: true
    ruleRecency?: true
    ruleFrequency?: true
    ruleValue?: true
    effectiveFrom?: true
    effectiveTo?: true
    createdAt?: true
    updatedAt?: true
    calculationStrategy?: true
    classRanges?: true
    conditionalRules?: true
    _all?: true
  }

  export type RfvParameterSetAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which RfvParameterSet to aggregate.
     */
    where?: RfvParameterSetWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RfvParameterSets to fetch.
     */
    orderBy?: RfvParameterSetOrderByWithRelationInput | RfvParameterSetOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: RfvParameterSetWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RfvParameterSets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RfvParameterSets.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned RfvParameterSets
    **/
    _count?: true | RfvParameterSetCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: RfvParameterSetAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: RfvParameterSetSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: RfvParameterSetMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: RfvParameterSetMaxAggregateInputType
  }

  export type GetRfvParameterSetAggregateType<T extends RfvParameterSetAggregateArgs> = {
        [P in keyof T & keyof AggregateRfvParameterSet]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRfvParameterSet[P]>
      : GetScalarType<T[P], AggregateRfvParameterSet[P]>
  }




  export type RfvParameterSetGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RfvParameterSetWhereInput
    orderBy?: RfvParameterSetOrderByWithAggregationInput | RfvParameterSetOrderByWithAggregationInput[]
    by: RfvParameterSetScalarFieldEnum[] | RfvParameterSetScalarFieldEnum
    having?: RfvParameterSetScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: RfvParameterSetCountAggregateInputType | true
    _avg?: RfvParameterSetAvgAggregateInputType
    _sum?: RfvParameterSetSumAggregateInputType
    _min?: RfvParameterSetMinAggregateInputType
    _max?: RfvParameterSetMaxAggregateInputType
  }

  export type RfvParameterSetGroupByOutputType = {
    id: number
    filialId: number | null
    name: string
    strategy: $Enums.RfvStrategy
    windowDays: number
    weights: JsonValue
    ruleRecency: JsonValue
    ruleFrequency: JsonValue
    ruleValue: JsonValue
    effectiveFrom: Date
    effectiveTo: Date | null
    createdAt: Date
    updatedAt: Date
    calculationStrategy: $Enums.CalculationStrategy
    classRanges: JsonValue | null
    conditionalRules: JsonValue | null
    _count: RfvParameterSetCountAggregateOutputType | null
    _avg: RfvParameterSetAvgAggregateOutputType | null
    _sum: RfvParameterSetSumAggregateOutputType | null
    _min: RfvParameterSetMinAggregateOutputType | null
    _max: RfvParameterSetMaxAggregateOutputType | null
  }

  type GetRfvParameterSetGroupByPayload<T extends RfvParameterSetGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<RfvParameterSetGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof RfvParameterSetGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], RfvParameterSetGroupByOutputType[P]>
            : GetScalarType<T[P], RfvParameterSetGroupByOutputType[P]>
        }
      >
    >


  export type RfvParameterSetSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    filialId?: boolean
    name?: boolean
    strategy?: boolean
    windowDays?: boolean
    weights?: boolean
    ruleRecency?: boolean
    ruleFrequency?: boolean
    ruleValue?: boolean
    effectiveFrom?: boolean
    effectiveTo?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    calculationStrategy?: boolean
    classRanges?: boolean
    conditionalRules?: boolean
    filial?: boolean | RfvParameterSet$filialArgs<ExtArgs>
    segments?: boolean | RfvParameterSet$segmentsArgs<ExtArgs>
    _count?: boolean | RfvParameterSetCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["rfvParameterSet"]>


  export type RfvParameterSetSelectScalar = {
    id?: boolean
    filialId?: boolean
    name?: boolean
    strategy?: boolean
    windowDays?: boolean
    weights?: boolean
    ruleRecency?: boolean
    ruleFrequency?: boolean
    ruleValue?: boolean
    effectiveFrom?: boolean
    effectiveTo?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    calculationStrategy?: boolean
    classRanges?: boolean
    conditionalRules?: boolean
  }

  export type RfvParameterSetInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    filial?: boolean | RfvParameterSet$filialArgs<ExtArgs>
    segments?: boolean | RfvParameterSet$segmentsArgs<ExtArgs>
    _count?: boolean | RfvParameterSetCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $RfvParameterSetPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "RfvParameterSet"
    objects: {
      filial: Prisma.$FilialPayload<ExtArgs> | null
      segments: Prisma.$RfvSegmentPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      filialId: number | null
      name: string
      strategy: $Enums.RfvStrategy
      windowDays: number
      weights: Prisma.JsonValue
      ruleRecency: Prisma.JsonValue
      ruleFrequency: Prisma.JsonValue
      ruleValue: Prisma.JsonValue
      effectiveFrom: Date
      effectiveTo: Date | null
      createdAt: Date
      updatedAt: Date
      calculationStrategy: $Enums.CalculationStrategy
      classRanges: Prisma.JsonValue | null
      conditionalRules: Prisma.JsonValue | null
    }, ExtArgs["result"]["rfvParameterSet"]>
    composites: {}
  }

  type RfvParameterSetGetPayload<S extends boolean | null | undefined | RfvParameterSetDefaultArgs> = $Result.GetResult<Prisma.$RfvParameterSetPayload, S>

  type RfvParameterSetCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<RfvParameterSetFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: RfvParameterSetCountAggregateInputType | true
    }

  export interface RfvParameterSetDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['RfvParameterSet'], meta: { name: 'RfvParameterSet' } }
    /**
     * Find zero or one RfvParameterSet that matches the filter.
     * @param {RfvParameterSetFindUniqueArgs} args - Arguments to find a RfvParameterSet
     * @example
     * // Get one RfvParameterSet
     * const rfvParameterSet = await prisma.rfvParameterSet.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends RfvParameterSetFindUniqueArgs>(args: SelectSubset<T, RfvParameterSetFindUniqueArgs<ExtArgs>>): Prisma__RfvParameterSetClient<$Result.GetResult<Prisma.$RfvParameterSetPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one RfvParameterSet that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {RfvParameterSetFindUniqueOrThrowArgs} args - Arguments to find a RfvParameterSet
     * @example
     * // Get one RfvParameterSet
     * const rfvParameterSet = await prisma.rfvParameterSet.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends RfvParameterSetFindUniqueOrThrowArgs>(args: SelectSubset<T, RfvParameterSetFindUniqueOrThrowArgs<ExtArgs>>): Prisma__RfvParameterSetClient<$Result.GetResult<Prisma.$RfvParameterSetPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first RfvParameterSet that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RfvParameterSetFindFirstArgs} args - Arguments to find a RfvParameterSet
     * @example
     * // Get one RfvParameterSet
     * const rfvParameterSet = await prisma.rfvParameterSet.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends RfvParameterSetFindFirstArgs>(args?: SelectSubset<T, RfvParameterSetFindFirstArgs<ExtArgs>>): Prisma__RfvParameterSetClient<$Result.GetResult<Prisma.$RfvParameterSetPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first RfvParameterSet that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RfvParameterSetFindFirstOrThrowArgs} args - Arguments to find a RfvParameterSet
     * @example
     * // Get one RfvParameterSet
     * const rfvParameterSet = await prisma.rfvParameterSet.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends RfvParameterSetFindFirstOrThrowArgs>(args?: SelectSubset<T, RfvParameterSetFindFirstOrThrowArgs<ExtArgs>>): Prisma__RfvParameterSetClient<$Result.GetResult<Prisma.$RfvParameterSetPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more RfvParameterSets that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RfvParameterSetFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all RfvParameterSets
     * const rfvParameterSets = await prisma.rfvParameterSet.findMany()
     * 
     * // Get first 10 RfvParameterSets
     * const rfvParameterSets = await prisma.rfvParameterSet.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const rfvParameterSetWithIdOnly = await prisma.rfvParameterSet.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends RfvParameterSetFindManyArgs>(args?: SelectSubset<T, RfvParameterSetFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RfvParameterSetPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a RfvParameterSet.
     * @param {RfvParameterSetCreateArgs} args - Arguments to create a RfvParameterSet.
     * @example
     * // Create one RfvParameterSet
     * const RfvParameterSet = await prisma.rfvParameterSet.create({
     *   data: {
     *     // ... data to create a RfvParameterSet
     *   }
     * })
     * 
     */
    create<T extends RfvParameterSetCreateArgs>(args: SelectSubset<T, RfvParameterSetCreateArgs<ExtArgs>>): Prisma__RfvParameterSetClient<$Result.GetResult<Prisma.$RfvParameterSetPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many RfvParameterSets.
     * @param {RfvParameterSetCreateManyArgs} args - Arguments to create many RfvParameterSets.
     * @example
     * // Create many RfvParameterSets
     * const rfvParameterSet = await prisma.rfvParameterSet.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends RfvParameterSetCreateManyArgs>(args?: SelectSubset<T, RfvParameterSetCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a RfvParameterSet.
     * @param {RfvParameterSetDeleteArgs} args - Arguments to delete one RfvParameterSet.
     * @example
     * // Delete one RfvParameterSet
     * const RfvParameterSet = await prisma.rfvParameterSet.delete({
     *   where: {
     *     // ... filter to delete one RfvParameterSet
     *   }
     * })
     * 
     */
    delete<T extends RfvParameterSetDeleteArgs>(args: SelectSubset<T, RfvParameterSetDeleteArgs<ExtArgs>>): Prisma__RfvParameterSetClient<$Result.GetResult<Prisma.$RfvParameterSetPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one RfvParameterSet.
     * @param {RfvParameterSetUpdateArgs} args - Arguments to update one RfvParameterSet.
     * @example
     * // Update one RfvParameterSet
     * const rfvParameterSet = await prisma.rfvParameterSet.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends RfvParameterSetUpdateArgs>(args: SelectSubset<T, RfvParameterSetUpdateArgs<ExtArgs>>): Prisma__RfvParameterSetClient<$Result.GetResult<Prisma.$RfvParameterSetPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more RfvParameterSets.
     * @param {RfvParameterSetDeleteManyArgs} args - Arguments to filter RfvParameterSets to delete.
     * @example
     * // Delete a few RfvParameterSets
     * const { count } = await prisma.rfvParameterSet.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends RfvParameterSetDeleteManyArgs>(args?: SelectSubset<T, RfvParameterSetDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more RfvParameterSets.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RfvParameterSetUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many RfvParameterSets
     * const rfvParameterSet = await prisma.rfvParameterSet.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends RfvParameterSetUpdateManyArgs>(args: SelectSubset<T, RfvParameterSetUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one RfvParameterSet.
     * @param {RfvParameterSetUpsertArgs} args - Arguments to update or create a RfvParameterSet.
     * @example
     * // Update or create a RfvParameterSet
     * const rfvParameterSet = await prisma.rfvParameterSet.upsert({
     *   create: {
     *     // ... data to create a RfvParameterSet
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the RfvParameterSet we want to update
     *   }
     * })
     */
    upsert<T extends RfvParameterSetUpsertArgs>(args: SelectSubset<T, RfvParameterSetUpsertArgs<ExtArgs>>): Prisma__RfvParameterSetClient<$Result.GetResult<Prisma.$RfvParameterSetPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of RfvParameterSets.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RfvParameterSetCountArgs} args - Arguments to filter RfvParameterSets to count.
     * @example
     * // Count the number of RfvParameterSets
     * const count = await prisma.rfvParameterSet.count({
     *   where: {
     *     // ... the filter for the RfvParameterSets we want to count
     *   }
     * })
    **/
    count<T extends RfvParameterSetCountArgs>(
      args?: Subset<T, RfvParameterSetCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], RfvParameterSetCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a RfvParameterSet.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RfvParameterSetAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends RfvParameterSetAggregateArgs>(args: Subset<T, RfvParameterSetAggregateArgs>): Prisma.PrismaPromise<GetRfvParameterSetAggregateType<T>>

    /**
     * Group by RfvParameterSet.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RfvParameterSetGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends RfvParameterSetGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: RfvParameterSetGroupByArgs['orderBy'] }
        : { orderBy?: RfvParameterSetGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, RfvParameterSetGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetRfvParameterSetGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the RfvParameterSet model
   */
  readonly fields: RfvParameterSetFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for RfvParameterSet.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__RfvParameterSetClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    filial<T extends RfvParameterSet$filialArgs<ExtArgs> = {}>(args?: Subset<T, RfvParameterSet$filialArgs<ExtArgs>>): Prisma__FilialClient<$Result.GetResult<Prisma.$FilialPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    segments<T extends RfvParameterSet$segmentsArgs<ExtArgs> = {}>(args?: Subset<T, RfvParameterSet$segmentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RfvSegmentPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the RfvParameterSet model
   */ 
  interface RfvParameterSetFieldRefs {
    readonly id: FieldRef<"RfvParameterSet", 'Int'>
    readonly filialId: FieldRef<"RfvParameterSet", 'Int'>
    readonly name: FieldRef<"RfvParameterSet", 'String'>
    readonly strategy: FieldRef<"RfvParameterSet", 'RfvStrategy'>
    readonly windowDays: FieldRef<"RfvParameterSet", 'Int'>
    readonly weights: FieldRef<"RfvParameterSet", 'Json'>
    readonly ruleRecency: FieldRef<"RfvParameterSet", 'Json'>
    readonly ruleFrequency: FieldRef<"RfvParameterSet", 'Json'>
    readonly ruleValue: FieldRef<"RfvParameterSet", 'Json'>
    readonly effectiveFrom: FieldRef<"RfvParameterSet", 'DateTime'>
    readonly effectiveTo: FieldRef<"RfvParameterSet", 'DateTime'>
    readonly createdAt: FieldRef<"RfvParameterSet", 'DateTime'>
    readonly updatedAt: FieldRef<"RfvParameterSet", 'DateTime'>
    readonly calculationStrategy: FieldRef<"RfvParameterSet", 'CalculationStrategy'>
    readonly classRanges: FieldRef<"RfvParameterSet", 'Json'>
    readonly conditionalRules: FieldRef<"RfvParameterSet", 'Json'>
  }
    

  // Custom InputTypes
  /**
   * RfvParameterSet findUnique
   */
  export type RfvParameterSetFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RfvParameterSet
     */
    select?: RfvParameterSetSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RfvParameterSetInclude<ExtArgs> | null
    /**
     * Filter, which RfvParameterSet to fetch.
     */
    where: RfvParameterSetWhereUniqueInput
  }

  /**
   * RfvParameterSet findUniqueOrThrow
   */
  export type RfvParameterSetFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RfvParameterSet
     */
    select?: RfvParameterSetSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RfvParameterSetInclude<ExtArgs> | null
    /**
     * Filter, which RfvParameterSet to fetch.
     */
    where: RfvParameterSetWhereUniqueInput
  }

  /**
   * RfvParameterSet findFirst
   */
  export type RfvParameterSetFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RfvParameterSet
     */
    select?: RfvParameterSetSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RfvParameterSetInclude<ExtArgs> | null
    /**
     * Filter, which RfvParameterSet to fetch.
     */
    where?: RfvParameterSetWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RfvParameterSets to fetch.
     */
    orderBy?: RfvParameterSetOrderByWithRelationInput | RfvParameterSetOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for RfvParameterSets.
     */
    cursor?: RfvParameterSetWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RfvParameterSets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RfvParameterSets.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of RfvParameterSets.
     */
    distinct?: RfvParameterSetScalarFieldEnum | RfvParameterSetScalarFieldEnum[]
  }

  /**
   * RfvParameterSet findFirstOrThrow
   */
  export type RfvParameterSetFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RfvParameterSet
     */
    select?: RfvParameterSetSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RfvParameterSetInclude<ExtArgs> | null
    /**
     * Filter, which RfvParameterSet to fetch.
     */
    where?: RfvParameterSetWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RfvParameterSets to fetch.
     */
    orderBy?: RfvParameterSetOrderByWithRelationInput | RfvParameterSetOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for RfvParameterSets.
     */
    cursor?: RfvParameterSetWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RfvParameterSets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RfvParameterSets.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of RfvParameterSets.
     */
    distinct?: RfvParameterSetScalarFieldEnum | RfvParameterSetScalarFieldEnum[]
  }

  /**
   * RfvParameterSet findMany
   */
  export type RfvParameterSetFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RfvParameterSet
     */
    select?: RfvParameterSetSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RfvParameterSetInclude<ExtArgs> | null
    /**
     * Filter, which RfvParameterSets to fetch.
     */
    where?: RfvParameterSetWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RfvParameterSets to fetch.
     */
    orderBy?: RfvParameterSetOrderByWithRelationInput | RfvParameterSetOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing RfvParameterSets.
     */
    cursor?: RfvParameterSetWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RfvParameterSets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RfvParameterSets.
     */
    skip?: number
    distinct?: RfvParameterSetScalarFieldEnum | RfvParameterSetScalarFieldEnum[]
  }

  /**
   * RfvParameterSet create
   */
  export type RfvParameterSetCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RfvParameterSet
     */
    select?: RfvParameterSetSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RfvParameterSetInclude<ExtArgs> | null
    /**
     * The data needed to create a RfvParameterSet.
     */
    data: XOR<RfvParameterSetCreateInput, RfvParameterSetUncheckedCreateInput>
  }

  /**
   * RfvParameterSet createMany
   */
  export type RfvParameterSetCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many RfvParameterSets.
     */
    data: RfvParameterSetCreateManyInput | RfvParameterSetCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * RfvParameterSet update
   */
  export type RfvParameterSetUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RfvParameterSet
     */
    select?: RfvParameterSetSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RfvParameterSetInclude<ExtArgs> | null
    /**
     * The data needed to update a RfvParameterSet.
     */
    data: XOR<RfvParameterSetUpdateInput, RfvParameterSetUncheckedUpdateInput>
    /**
     * Choose, which RfvParameterSet to update.
     */
    where: RfvParameterSetWhereUniqueInput
  }

  /**
   * RfvParameterSet updateMany
   */
  export type RfvParameterSetUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update RfvParameterSets.
     */
    data: XOR<RfvParameterSetUpdateManyMutationInput, RfvParameterSetUncheckedUpdateManyInput>
    /**
     * Filter which RfvParameterSets to update
     */
    where?: RfvParameterSetWhereInput
  }

  /**
   * RfvParameterSet upsert
   */
  export type RfvParameterSetUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RfvParameterSet
     */
    select?: RfvParameterSetSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RfvParameterSetInclude<ExtArgs> | null
    /**
     * The filter to search for the RfvParameterSet to update in case it exists.
     */
    where: RfvParameterSetWhereUniqueInput
    /**
     * In case the RfvParameterSet found by the `where` argument doesn't exist, create a new RfvParameterSet with this data.
     */
    create: XOR<RfvParameterSetCreateInput, RfvParameterSetUncheckedCreateInput>
    /**
     * In case the RfvParameterSet was found with the provided `where` argument, update it with this data.
     */
    update: XOR<RfvParameterSetUpdateInput, RfvParameterSetUncheckedUpdateInput>
  }

  /**
   * RfvParameterSet delete
   */
  export type RfvParameterSetDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RfvParameterSet
     */
    select?: RfvParameterSetSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RfvParameterSetInclude<ExtArgs> | null
    /**
     * Filter which RfvParameterSet to delete.
     */
    where: RfvParameterSetWhereUniqueInput
  }

  /**
   * RfvParameterSet deleteMany
   */
  export type RfvParameterSetDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which RfvParameterSets to delete
     */
    where?: RfvParameterSetWhereInput
  }

  /**
   * RfvParameterSet.filial
   */
  export type RfvParameterSet$filialArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Filial
     */
    select?: FilialSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FilialInclude<ExtArgs> | null
    where?: FilialWhereInput
  }

  /**
   * RfvParameterSet.segments
   */
  export type RfvParameterSet$segmentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RfvSegment
     */
    select?: RfvSegmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RfvSegmentInclude<ExtArgs> | null
    where?: RfvSegmentWhereInput
    orderBy?: RfvSegmentOrderByWithRelationInput | RfvSegmentOrderByWithRelationInput[]
    cursor?: RfvSegmentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: RfvSegmentScalarFieldEnum | RfvSegmentScalarFieldEnum[]
  }

  /**
   * RfvParameterSet without action
   */
  export type RfvParameterSetDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RfvParameterSet
     */
    select?: RfvParameterSetSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RfvParameterSetInclude<ExtArgs> | null
  }


  /**
   * Model RfvSegment
   */

  export type AggregateRfvSegment = {
    _count: RfvSegmentCountAggregateOutputType | null
    _avg: RfvSegmentAvgAggregateOutputType | null
    _sum: RfvSegmentSumAggregateOutputType | null
    _min: RfvSegmentMinAggregateOutputType | null
    _max: RfvSegmentMaxAggregateOutputType | null
  }

  export type RfvSegmentAvgAggregateOutputType = {
    id: number | null
    parameterSetId: number | null
    priority: number | null
  }

  export type RfvSegmentSumAggregateOutputType = {
    id: number | null
    parameterSetId: number | null
    priority: number | null
  }

  export type RfvSegmentMinAggregateOutputType = {
    id: number | null
    parameterSetId: number | null
    name: string | null
    priority: number | null
  }

  export type RfvSegmentMaxAggregateOutputType = {
    id: number | null
    parameterSetId: number | null
    name: string | null
    priority: number | null
  }

  export type RfvSegmentCountAggregateOutputType = {
    id: number
    parameterSetId: number
    name: number
    rules: number
    priority: number
    _all: number
  }


  export type RfvSegmentAvgAggregateInputType = {
    id?: true
    parameterSetId?: true
    priority?: true
  }

  export type RfvSegmentSumAggregateInputType = {
    id?: true
    parameterSetId?: true
    priority?: true
  }

  export type RfvSegmentMinAggregateInputType = {
    id?: true
    parameterSetId?: true
    name?: true
    priority?: true
  }

  export type RfvSegmentMaxAggregateInputType = {
    id?: true
    parameterSetId?: true
    name?: true
    priority?: true
  }

  export type RfvSegmentCountAggregateInputType = {
    id?: true
    parameterSetId?: true
    name?: true
    rules?: true
    priority?: true
    _all?: true
  }

  export type RfvSegmentAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which RfvSegment to aggregate.
     */
    where?: RfvSegmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RfvSegments to fetch.
     */
    orderBy?: RfvSegmentOrderByWithRelationInput | RfvSegmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: RfvSegmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RfvSegments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RfvSegments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned RfvSegments
    **/
    _count?: true | RfvSegmentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: RfvSegmentAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: RfvSegmentSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: RfvSegmentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: RfvSegmentMaxAggregateInputType
  }

  export type GetRfvSegmentAggregateType<T extends RfvSegmentAggregateArgs> = {
        [P in keyof T & keyof AggregateRfvSegment]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRfvSegment[P]>
      : GetScalarType<T[P], AggregateRfvSegment[P]>
  }




  export type RfvSegmentGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RfvSegmentWhereInput
    orderBy?: RfvSegmentOrderByWithAggregationInput | RfvSegmentOrderByWithAggregationInput[]
    by: RfvSegmentScalarFieldEnum[] | RfvSegmentScalarFieldEnum
    having?: RfvSegmentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: RfvSegmentCountAggregateInputType | true
    _avg?: RfvSegmentAvgAggregateInputType
    _sum?: RfvSegmentSumAggregateInputType
    _min?: RfvSegmentMinAggregateInputType
    _max?: RfvSegmentMaxAggregateInputType
  }

  export type RfvSegmentGroupByOutputType = {
    id: number
    parameterSetId: number
    name: string
    rules: JsonValue
    priority: number
    _count: RfvSegmentCountAggregateOutputType | null
    _avg: RfvSegmentAvgAggregateOutputType | null
    _sum: RfvSegmentSumAggregateOutputType | null
    _min: RfvSegmentMinAggregateOutputType | null
    _max: RfvSegmentMaxAggregateOutputType | null
  }

  type GetRfvSegmentGroupByPayload<T extends RfvSegmentGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<RfvSegmentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof RfvSegmentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], RfvSegmentGroupByOutputType[P]>
            : GetScalarType<T[P], RfvSegmentGroupByOutputType[P]>
        }
      >
    >


  export type RfvSegmentSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    parameterSetId?: boolean
    name?: boolean
    rules?: boolean
    priority?: boolean
    parameterSet?: boolean | RfvParameterSetDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["rfvSegment"]>


  export type RfvSegmentSelectScalar = {
    id?: boolean
    parameterSetId?: boolean
    name?: boolean
    rules?: boolean
    priority?: boolean
  }

  export type RfvSegmentInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    parameterSet?: boolean | RfvParameterSetDefaultArgs<ExtArgs>
  }

  export type $RfvSegmentPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "RfvSegment"
    objects: {
      parameterSet: Prisma.$RfvParameterSetPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      parameterSetId: number
      name: string
      rules: Prisma.JsonValue
      priority: number
    }, ExtArgs["result"]["rfvSegment"]>
    composites: {}
  }

  type RfvSegmentGetPayload<S extends boolean | null | undefined | RfvSegmentDefaultArgs> = $Result.GetResult<Prisma.$RfvSegmentPayload, S>

  type RfvSegmentCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<RfvSegmentFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: RfvSegmentCountAggregateInputType | true
    }

  export interface RfvSegmentDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['RfvSegment'], meta: { name: 'RfvSegment' } }
    /**
     * Find zero or one RfvSegment that matches the filter.
     * @param {RfvSegmentFindUniqueArgs} args - Arguments to find a RfvSegment
     * @example
     * // Get one RfvSegment
     * const rfvSegment = await prisma.rfvSegment.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends RfvSegmentFindUniqueArgs>(args: SelectSubset<T, RfvSegmentFindUniqueArgs<ExtArgs>>): Prisma__RfvSegmentClient<$Result.GetResult<Prisma.$RfvSegmentPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one RfvSegment that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {RfvSegmentFindUniqueOrThrowArgs} args - Arguments to find a RfvSegment
     * @example
     * // Get one RfvSegment
     * const rfvSegment = await prisma.rfvSegment.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends RfvSegmentFindUniqueOrThrowArgs>(args: SelectSubset<T, RfvSegmentFindUniqueOrThrowArgs<ExtArgs>>): Prisma__RfvSegmentClient<$Result.GetResult<Prisma.$RfvSegmentPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first RfvSegment that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RfvSegmentFindFirstArgs} args - Arguments to find a RfvSegment
     * @example
     * // Get one RfvSegment
     * const rfvSegment = await prisma.rfvSegment.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends RfvSegmentFindFirstArgs>(args?: SelectSubset<T, RfvSegmentFindFirstArgs<ExtArgs>>): Prisma__RfvSegmentClient<$Result.GetResult<Prisma.$RfvSegmentPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first RfvSegment that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RfvSegmentFindFirstOrThrowArgs} args - Arguments to find a RfvSegment
     * @example
     * // Get one RfvSegment
     * const rfvSegment = await prisma.rfvSegment.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends RfvSegmentFindFirstOrThrowArgs>(args?: SelectSubset<T, RfvSegmentFindFirstOrThrowArgs<ExtArgs>>): Prisma__RfvSegmentClient<$Result.GetResult<Prisma.$RfvSegmentPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more RfvSegments that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RfvSegmentFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all RfvSegments
     * const rfvSegments = await prisma.rfvSegment.findMany()
     * 
     * // Get first 10 RfvSegments
     * const rfvSegments = await prisma.rfvSegment.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const rfvSegmentWithIdOnly = await prisma.rfvSegment.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends RfvSegmentFindManyArgs>(args?: SelectSubset<T, RfvSegmentFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RfvSegmentPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a RfvSegment.
     * @param {RfvSegmentCreateArgs} args - Arguments to create a RfvSegment.
     * @example
     * // Create one RfvSegment
     * const RfvSegment = await prisma.rfvSegment.create({
     *   data: {
     *     // ... data to create a RfvSegment
     *   }
     * })
     * 
     */
    create<T extends RfvSegmentCreateArgs>(args: SelectSubset<T, RfvSegmentCreateArgs<ExtArgs>>): Prisma__RfvSegmentClient<$Result.GetResult<Prisma.$RfvSegmentPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many RfvSegments.
     * @param {RfvSegmentCreateManyArgs} args - Arguments to create many RfvSegments.
     * @example
     * // Create many RfvSegments
     * const rfvSegment = await prisma.rfvSegment.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends RfvSegmentCreateManyArgs>(args?: SelectSubset<T, RfvSegmentCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a RfvSegment.
     * @param {RfvSegmentDeleteArgs} args - Arguments to delete one RfvSegment.
     * @example
     * // Delete one RfvSegment
     * const RfvSegment = await prisma.rfvSegment.delete({
     *   where: {
     *     // ... filter to delete one RfvSegment
     *   }
     * })
     * 
     */
    delete<T extends RfvSegmentDeleteArgs>(args: SelectSubset<T, RfvSegmentDeleteArgs<ExtArgs>>): Prisma__RfvSegmentClient<$Result.GetResult<Prisma.$RfvSegmentPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one RfvSegment.
     * @param {RfvSegmentUpdateArgs} args - Arguments to update one RfvSegment.
     * @example
     * // Update one RfvSegment
     * const rfvSegment = await prisma.rfvSegment.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends RfvSegmentUpdateArgs>(args: SelectSubset<T, RfvSegmentUpdateArgs<ExtArgs>>): Prisma__RfvSegmentClient<$Result.GetResult<Prisma.$RfvSegmentPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more RfvSegments.
     * @param {RfvSegmentDeleteManyArgs} args - Arguments to filter RfvSegments to delete.
     * @example
     * // Delete a few RfvSegments
     * const { count } = await prisma.rfvSegment.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends RfvSegmentDeleteManyArgs>(args?: SelectSubset<T, RfvSegmentDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more RfvSegments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RfvSegmentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many RfvSegments
     * const rfvSegment = await prisma.rfvSegment.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends RfvSegmentUpdateManyArgs>(args: SelectSubset<T, RfvSegmentUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one RfvSegment.
     * @param {RfvSegmentUpsertArgs} args - Arguments to update or create a RfvSegment.
     * @example
     * // Update or create a RfvSegment
     * const rfvSegment = await prisma.rfvSegment.upsert({
     *   create: {
     *     // ... data to create a RfvSegment
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the RfvSegment we want to update
     *   }
     * })
     */
    upsert<T extends RfvSegmentUpsertArgs>(args: SelectSubset<T, RfvSegmentUpsertArgs<ExtArgs>>): Prisma__RfvSegmentClient<$Result.GetResult<Prisma.$RfvSegmentPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of RfvSegments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RfvSegmentCountArgs} args - Arguments to filter RfvSegments to count.
     * @example
     * // Count the number of RfvSegments
     * const count = await prisma.rfvSegment.count({
     *   where: {
     *     // ... the filter for the RfvSegments we want to count
     *   }
     * })
    **/
    count<T extends RfvSegmentCountArgs>(
      args?: Subset<T, RfvSegmentCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], RfvSegmentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a RfvSegment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RfvSegmentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends RfvSegmentAggregateArgs>(args: Subset<T, RfvSegmentAggregateArgs>): Prisma.PrismaPromise<GetRfvSegmentAggregateType<T>>

    /**
     * Group by RfvSegment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RfvSegmentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends RfvSegmentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: RfvSegmentGroupByArgs['orderBy'] }
        : { orderBy?: RfvSegmentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, RfvSegmentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetRfvSegmentGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the RfvSegment model
   */
  readonly fields: RfvSegmentFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for RfvSegment.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__RfvSegmentClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    parameterSet<T extends RfvParameterSetDefaultArgs<ExtArgs> = {}>(args?: Subset<T, RfvParameterSetDefaultArgs<ExtArgs>>): Prisma__RfvParameterSetClient<$Result.GetResult<Prisma.$RfvParameterSetPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the RfvSegment model
   */ 
  interface RfvSegmentFieldRefs {
    readonly id: FieldRef<"RfvSegment", 'Int'>
    readonly parameterSetId: FieldRef<"RfvSegment", 'Int'>
    readonly name: FieldRef<"RfvSegment", 'String'>
    readonly rules: FieldRef<"RfvSegment", 'Json'>
    readonly priority: FieldRef<"RfvSegment", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * RfvSegment findUnique
   */
  export type RfvSegmentFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RfvSegment
     */
    select?: RfvSegmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RfvSegmentInclude<ExtArgs> | null
    /**
     * Filter, which RfvSegment to fetch.
     */
    where: RfvSegmentWhereUniqueInput
  }

  /**
   * RfvSegment findUniqueOrThrow
   */
  export type RfvSegmentFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RfvSegment
     */
    select?: RfvSegmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RfvSegmentInclude<ExtArgs> | null
    /**
     * Filter, which RfvSegment to fetch.
     */
    where: RfvSegmentWhereUniqueInput
  }

  /**
   * RfvSegment findFirst
   */
  export type RfvSegmentFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RfvSegment
     */
    select?: RfvSegmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RfvSegmentInclude<ExtArgs> | null
    /**
     * Filter, which RfvSegment to fetch.
     */
    where?: RfvSegmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RfvSegments to fetch.
     */
    orderBy?: RfvSegmentOrderByWithRelationInput | RfvSegmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for RfvSegments.
     */
    cursor?: RfvSegmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RfvSegments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RfvSegments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of RfvSegments.
     */
    distinct?: RfvSegmentScalarFieldEnum | RfvSegmentScalarFieldEnum[]
  }

  /**
   * RfvSegment findFirstOrThrow
   */
  export type RfvSegmentFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RfvSegment
     */
    select?: RfvSegmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RfvSegmentInclude<ExtArgs> | null
    /**
     * Filter, which RfvSegment to fetch.
     */
    where?: RfvSegmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RfvSegments to fetch.
     */
    orderBy?: RfvSegmentOrderByWithRelationInput | RfvSegmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for RfvSegments.
     */
    cursor?: RfvSegmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RfvSegments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RfvSegments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of RfvSegments.
     */
    distinct?: RfvSegmentScalarFieldEnum | RfvSegmentScalarFieldEnum[]
  }

  /**
   * RfvSegment findMany
   */
  export type RfvSegmentFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RfvSegment
     */
    select?: RfvSegmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RfvSegmentInclude<ExtArgs> | null
    /**
     * Filter, which RfvSegments to fetch.
     */
    where?: RfvSegmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RfvSegments to fetch.
     */
    orderBy?: RfvSegmentOrderByWithRelationInput | RfvSegmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing RfvSegments.
     */
    cursor?: RfvSegmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RfvSegments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RfvSegments.
     */
    skip?: number
    distinct?: RfvSegmentScalarFieldEnum | RfvSegmentScalarFieldEnum[]
  }

  /**
   * RfvSegment create
   */
  export type RfvSegmentCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RfvSegment
     */
    select?: RfvSegmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RfvSegmentInclude<ExtArgs> | null
    /**
     * The data needed to create a RfvSegment.
     */
    data: XOR<RfvSegmentCreateInput, RfvSegmentUncheckedCreateInput>
  }

  /**
   * RfvSegment createMany
   */
  export type RfvSegmentCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many RfvSegments.
     */
    data: RfvSegmentCreateManyInput | RfvSegmentCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * RfvSegment update
   */
  export type RfvSegmentUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RfvSegment
     */
    select?: RfvSegmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RfvSegmentInclude<ExtArgs> | null
    /**
     * The data needed to update a RfvSegment.
     */
    data: XOR<RfvSegmentUpdateInput, RfvSegmentUncheckedUpdateInput>
    /**
     * Choose, which RfvSegment to update.
     */
    where: RfvSegmentWhereUniqueInput
  }

  /**
   * RfvSegment updateMany
   */
  export type RfvSegmentUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update RfvSegments.
     */
    data: XOR<RfvSegmentUpdateManyMutationInput, RfvSegmentUncheckedUpdateManyInput>
    /**
     * Filter which RfvSegments to update
     */
    where?: RfvSegmentWhereInput
  }

  /**
   * RfvSegment upsert
   */
  export type RfvSegmentUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RfvSegment
     */
    select?: RfvSegmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RfvSegmentInclude<ExtArgs> | null
    /**
     * The filter to search for the RfvSegment to update in case it exists.
     */
    where: RfvSegmentWhereUniqueInput
    /**
     * In case the RfvSegment found by the `where` argument doesn't exist, create a new RfvSegment with this data.
     */
    create: XOR<RfvSegmentCreateInput, RfvSegmentUncheckedCreateInput>
    /**
     * In case the RfvSegment was found with the provided `where` argument, update it with this data.
     */
    update: XOR<RfvSegmentUpdateInput, RfvSegmentUncheckedUpdateInput>
  }

  /**
   * RfvSegment delete
   */
  export type RfvSegmentDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RfvSegment
     */
    select?: RfvSegmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RfvSegmentInclude<ExtArgs> | null
    /**
     * Filter which RfvSegment to delete.
     */
    where: RfvSegmentWhereUniqueInput
  }

  /**
   * RfvSegment deleteMany
   */
  export type RfvSegmentDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which RfvSegments to delete
     */
    where?: RfvSegmentWhereInput
  }

  /**
   * RfvSegment without action
   */
  export type RfvSegmentDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RfvSegment
     */
    select?: RfvSegmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RfvSegmentInclude<ExtArgs> | null
  }


  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    ReadUncommitted: 'ReadUncommitted',
    ReadCommitted: 'ReadCommitted',
    RepeatableRead: 'RepeatableRead',
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const EmpresaScalarFieldEnum: {
    id: 'id',
    razaoSocial: 'razaoSocial',
    nomeFantasia: 'nomeFantasia',
    cnpjMatriz: 'cnpjMatriz',
    inscricaoEstadual: 'inscricaoEstadual',
    cidade: 'cidade',
    estado: 'estado',
    logradouro: 'logradouro',
    numero: 'numero',
    bairro: 'bairro',
    cep: 'cep',
    telefone: 'telefone',
    email: 'email',
    ativo: 'ativo',
    dataCriacao: 'dataCriacao',
    dataAtualizacao: 'dataAtualizacao'
  };

  export type EmpresaScalarFieldEnum = (typeof EmpresaScalarFieldEnum)[keyof typeof EmpresaScalarFieldEnum]


  export const ClienteScalarFieldEnum: {
    id: 'id',
    nome: 'nome',
    cpfCnpj: 'cpfCnpj',
    cidade: 'cidade',
    estado: 'estado',
    logradouro: 'logradouro',
    numero: 'numero',
    bairro: 'bairro',
    cep: 'cep',
    telefone: 'telefone'
  };

  export type ClienteScalarFieldEnum = (typeof ClienteScalarFieldEnum)[keyof typeof ClienteScalarFieldEnum]


  export const FilialScalarFieldEnum: {
    id: 'id',
    empresaId: 'empresaId',
    nome: 'nome',
    cnpj: 'cnpj',
    cidade: 'cidade',
    estado: 'estado'
  };

  export type FilialScalarFieldEnum = (typeof FilialScalarFieldEnum)[keyof typeof FilialScalarFieldEnum]


  export const VendedorScalarFieldEnum: {
    id: 'id',
    nome: 'nome',
    cpf: 'cpf',
    filialId: 'filialId'
  };

  export type VendedorScalarFieldEnum = (typeof VendedorScalarFieldEnum)[keyof typeof VendedorScalarFieldEnum]


  export const ProdutoScalarFieldEnum: {
    id: 'id',
    descricao: 'descricao',
    tipo: 'tipo',
    preco: 'preco'
  };

  export type ProdutoScalarFieldEnum = (typeof ProdutoScalarFieldEnum)[keyof typeof ProdutoScalarFieldEnum]


  export const MaquinaEstoqueScalarFieldEnum: {
    Chassi: 'Chassi',
    produtoId: 'produtoId',
    filialId: 'filialId',
    Status: 'Status'
  };

  export type MaquinaEstoqueScalarFieldEnum = (typeof MaquinaEstoqueScalarFieldEnum)[keyof typeof MaquinaEstoqueScalarFieldEnum]


  export const NotasFiscalCabecalhoScalarFieldEnum: {
    id: 'id',
    numeroNota: 'numeroNota',
    dataEmissao: 'dataEmissao',
    valorTotal: 'valorTotal',
    filialId: 'filialId',
    clienteId: 'clienteId',
    vendedorId: 'vendedorId'
  };

  export type NotasFiscalCabecalhoScalarFieldEnum = (typeof NotasFiscalCabecalhoScalarFieldEnum)[keyof typeof NotasFiscalCabecalhoScalarFieldEnum]


  export const NotaFiscalItemScalarFieldEnum: {
    id: 'id',
    notaFiscalId: 'notaFiscalId',
    produtoId: 'produtoId',
    Quantidade: 'Quantidade',
    valorUnitario: 'valorUnitario',
    valorTotalItem: 'valorTotalItem',
    Chassi: 'Chassi'
  };

  export type NotaFiscalItemScalarFieldEnum = (typeof NotaFiscalItemScalarFieldEnum)[keyof typeof NotaFiscalItemScalarFieldEnum]


  export const UserScalarFieldEnum: {
    id: 'id',
    email: 'email',
    password: 'password',
    createdAt: 'createdAt'
  };

  export type UserScalarFieldEnum = (typeof UserScalarFieldEnum)[keyof typeof UserScalarFieldEnum]


  export const RfvParameterSetScalarFieldEnum: {
    id: 'id',
    filialId: 'filialId',
    name: 'name',
    strategy: 'strategy',
    windowDays: 'windowDays',
    weights: 'weights',
    ruleRecency: 'ruleRecency',
    ruleFrequency: 'ruleFrequency',
    ruleValue: 'ruleValue',
    effectiveFrom: 'effectiveFrom',
    effectiveTo: 'effectiveTo',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    calculationStrategy: 'calculationStrategy',
    classRanges: 'classRanges',
    conditionalRules: 'conditionalRules'
  };

  export type RfvParameterSetScalarFieldEnum = (typeof RfvParameterSetScalarFieldEnum)[keyof typeof RfvParameterSetScalarFieldEnum]


  export const RfvSegmentScalarFieldEnum: {
    id: 'id',
    parameterSetId: 'parameterSetId',
    name: 'name',
    rules: 'rules',
    priority: 'priority'
  };

  export type RfvSegmentScalarFieldEnum = (typeof RfvSegmentScalarFieldEnum)[keyof typeof RfvSegmentScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const JsonNullValueInput: {
    JsonNull: typeof JsonNull
  };

  export type JsonNullValueInput = (typeof JsonNullValueInput)[keyof typeof JsonNullValueInput]


  export const NullableJsonNullValueInput: {
    DbNull: typeof DbNull,
    JsonNull: typeof JsonNull
  };

  export type NullableJsonNullValueInput = (typeof NullableJsonNullValueInput)[keyof typeof NullableJsonNullValueInput]


  export const NullsOrder: {
    first: 'first',
    last: 'last'
  };

  export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]


  export const JsonNullValueFilter: {
    DbNull: typeof DbNull,
    JsonNull: typeof JsonNull,
    AnyNull: typeof AnyNull
  };

  export type JsonNullValueFilter = (typeof JsonNullValueFilter)[keyof typeof JsonNullValueFilter]


  /**
   * Field references 
   */


  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


  /**
   * Reference to a field of type 'Boolean'
   */
  export type BooleanFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Boolean'>
    


  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


  /**
   * Reference to a field of type 'Decimal'
   */
  export type DecimalFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Decimal'>
    


  /**
   * Reference to a field of type 'RfvStrategy'
   */
  export type EnumRfvStrategyFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'RfvStrategy'>
    


  /**
   * Reference to a field of type 'Json'
   */
  export type JsonFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Json'>
    


  /**
   * Reference to a field of type 'CalculationStrategy'
   */
  export type EnumCalculationStrategyFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'CalculationStrategy'>
    


  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    
  /**
   * Deep Input Types
   */


  export type EmpresaWhereInput = {
    AND?: EmpresaWhereInput | EmpresaWhereInput[]
    OR?: EmpresaWhereInput[]
    NOT?: EmpresaWhereInput | EmpresaWhereInput[]
    id?: IntFilter<"Empresa"> | number
    razaoSocial?: StringFilter<"Empresa"> | string
    nomeFantasia?: StringNullableFilter<"Empresa"> | string | null
    cnpjMatriz?: StringFilter<"Empresa"> | string
    inscricaoEstadual?: StringNullableFilter<"Empresa"> | string | null
    cidade?: StringNullableFilter<"Empresa"> | string | null
    estado?: StringNullableFilter<"Empresa"> | string | null
    logradouro?: StringNullableFilter<"Empresa"> | string | null
    numero?: StringNullableFilter<"Empresa"> | string | null
    bairro?: StringNullableFilter<"Empresa"> | string | null
    cep?: StringNullableFilter<"Empresa"> | string | null
    telefone?: StringNullableFilter<"Empresa"> | string | null
    email?: StringNullableFilter<"Empresa"> | string | null
    ativo?: BoolFilter<"Empresa"> | boolean
    dataCriacao?: DateTimeFilter<"Empresa"> | Date | string
    dataAtualizacao?: DateTimeFilter<"Empresa"> | Date | string
    filiais?: FilialListRelationFilter
  }

  export type EmpresaOrderByWithRelationInput = {
    id?: SortOrder
    razaoSocial?: SortOrder
    nomeFantasia?: SortOrderInput | SortOrder
    cnpjMatriz?: SortOrder
    inscricaoEstadual?: SortOrderInput | SortOrder
    cidade?: SortOrderInput | SortOrder
    estado?: SortOrderInput | SortOrder
    logradouro?: SortOrderInput | SortOrder
    numero?: SortOrderInput | SortOrder
    bairro?: SortOrderInput | SortOrder
    cep?: SortOrderInput | SortOrder
    telefone?: SortOrderInput | SortOrder
    email?: SortOrderInput | SortOrder
    ativo?: SortOrder
    dataCriacao?: SortOrder
    dataAtualizacao?: SortOrder
    filiais?: FilialOrderByRelationAggregateInput
  }

  export type EmpresaWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    cnpjMatriz?: string
    email?: string
    AND?: EmpresaWhereInput | EmpresaWhereInput[]
    OR?: EmpresaWhereInput[]
    NOT?: EmpresaWhereInput | EmpresaWhereInput[]
    razaoSocial?: StringFilter<"Empresa"> | string
    nomeFantasia?: StringNullableFilter<"Empresa"> | string | null
    inscricaoEstadual?: StringNullableFilter<"Empresa"> | string | null
    cidade?: StringNullableFilter<"Empresa"> | string | null
    estado?: StringNullableFilter<"Empresa"> | string | null
    logradouro?: StringNullableFilter<"Empresa"> | string | null
    numero?: StringNullableFilter<"Empresa"> | string | null
    bairro?: StringNullableFilter<"Empresa"> | string | null
    cep?: StringNullableFilter<"Empresa"> | string | null
    telefone?: StringNullableFilter<"Empresa"> | string | null
    ativo?: BoolFilter<"Empresa"> | boolean
    dataCriacao?: DateTimeFilter<"Empresa"> | Date | string
    dataAtualizacao?: DateTimeFilter<"Empresa"> | Date | string
    filiais?: FilialListRelationFilter
  }, "id" | "cnpjMatriz" | "email">

  export type EmpresaOrderByWithAggregationInput = {
    id?: SortOrder
    razaoSocial?: SortOrder
    nomeFantasia?: SortOrderInput | SortOrder
    cnpjMatriz?: SortOrder
    inscricaoEstadual?: SortOrderInput | SortOrder
    cidade?: SortOrderInput | SortOrder
    estado?: SortOrderInput | SortOrder
    logradouro?: SortOrderInput | SortOrder
    numero?: SortOrderInput | SortOrder
    bairro?: SortOrderInput | SortOrder
    cep?: SortOrderInput | SortOrder
    telefone?: SortOrderInput | SortOrder
    email?: SortOrderInput | SortOrder
    ativo?: SortOrder
    dataCriacao?: SortOrder
    dataAtualizacao?: SortOrder
    _count?: EmpresaCountOrderByAggregateInput
    _avg?: EmpresaAvgOrderByAggregateInput
    _max?: EmpresaMaxOrderByAggregateInput
    _min?: EmpresaMinOrderByAggregateInput
    _sum?: EmpresaSumOrderByAggregateInput
  }

  export type EmpresaScalarWhereWithAggregatesInput = {
    AND?: EmpresaScalarWhereWithAggregatesInput | EmpresaScalarWhereWithAggregatesInput[]
    OR?: EmpresaScalarWhereWithAggregatesInput[]
    NOT?: EmpresaScalarWhereWithAggregatesInput | EmpresaScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Empresa"> | number
    razaoSocial?: StringWithAggregatesFilter<"Empresa"> | string
    nomeFantasia?: StringNullableWithAggregatesFilter<"Empresa"> | string | null
    cnpjMatriz?: StringWithAggregatesFilter<"Empresa"> | string
    inscricaoEstadual?: StringNullableWithAggregatesFilter<"Empresa"> | string | null
    cidade?: StringNullableWithAggregatesFilter<"Empresa"> | string | null
    estado?: StringNullableWithAggregatesFilter<"Empresa"> | string | null
    logradouro?: StringNullableWithAggregatesFilter<"Empresa"> | string | null
    numero?: StringNullableWithAggregatesFilter<"Empresa"> | string | null
    bairro?: StringNullableWithAggregatesFilter<"Empresa"> | string | null
    cep?: StringNullableWithAggregatesFilter<"Empresa"> | string | null
    telefone?: StringNullableWithAggregatesFilter<"Empresa"> | string | null
    email?: StringNullableWithAggregatesFilter<"Empresa"> | string | null
    ativo?: BoolWithAggregatesFilter<"Empresa"> | boolean
    dataCriacao?: DateTimeWithAggregatesFilter<"Empresa"> | Date | string
    dataAtualizacao?: DateTimeWithAggregatesFilter<"Empresa"> | Date | string
  }

  export type ClienteWhereInput = {
    AND?: ClienteWhereInput | ClienteWhereInput[]
    OR?: ClienteWhereInput[]
    NOT?: ClienteWhereInput | ClienteWhereInput[]
    id?: IntFilter<"Cliente"> | number
    nome?: StringFilter<"Cliente"> | string
    cpfCnpj?: StringFilter<"Cliente"> | string
    cidade?: StringNullableFilter<"Cliente"> | string | null
    estado?: StringNullableFilter<"Cliente"> | string | null
    logradouro?: StringNullableFilter<"Cliente"> | string | null
    numero?: StringNullableFilter<"Cliente"> | string | null
    bairro?: StringNullableFilter<"Cliente"> | string | null
    cep?: StringNullableFilter<"Cliente"> | string | null
    telefone?: StringNullableFilter<"Cliente"> | string | null
    notasFiscais?: NotasFiscalCabecalhoListRelationFilter
  }

  export type ClienteOrderByWithRelationInput = {
    id?: SortOrder
    nome?: SortOrder
    cpfCnpj?: SortOrder
    cidade?: SortOrderInput | SortOrder
    estado?: SortOrderInput | SortOrder
    logradouro?: SortOrderInput | SortOrder
    numero?: SortOrderInput | SortOrder
    bairro?: SortOrderInput | SortOrder
    cep?: SortOrderInput | SortOrder
    telefone?: SortOrderInput | SortOrder
    notasFiscais?: NotasFiscalCabecalhoOrderByRelationAggregateInput
  }

  export type ClienteWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    cpfCnpj?: string
    AND?: ClienteWhereInput | ClienteWhereInput[]
    OR?: ClienteWhereInput[]
    NOT?: ClienteWhereInput | ClienteWhereInput[]
    nome?: StringFilter<"Cliente"> | string
    cidade?: StringNullableFilter<"Cliente"> | string | null
    estado?: StringNullableFilter<"Cliente"> | string | null
    logradouro?: StringNullableFilter<"Cliente"> | string | null
    numero?: StringNullableFilter<"Cliente"> | string | null
    bairro?: StringNullableFilter<"Cliente"> | string | null
    cep?: StringNullableFilter<"Cliente"> | string | null
    telefone?: StringNullableFilter<"Cliente"> | string | null
    notasFiscais?: NotasFiscalCabecalhoListRelationFilter
  }, "id" | "cpfCnpj">

  export type ClienteOrderByWithAggregationInput = {
    id?: SortOrder
    nome?: SortOrder
    cpfCnpj?: SortOrder
    cidade?: SortOrderInput | SortOrder
    estado?: SortOrderInput | SortOrder
    logradouro?: SortOrderInput | SortOrder
    numero?: SortOrderInput | SortOrder
    bairro?: SortOrderInput | SortOrder
    cep?: SortOrderInput | SortOrder
    telefone?: SortOrderInput | SortOrder
    _count?: ClienteCountOrderByAggregateInput
    _avg?: ClienteAvgOrderByAggregateInput
    _max?: ClienteMaxOrderByAggregateInput
    _min?: ClienteMinOrderByAggregateInput
    _sum?: ClienteSumOrderByAggregateInput
  }

  export type ClienteScalarWhereWithAggregatesInput = {
    AND?: ClienteScalarWhereWithAggregatesInput | ClienteScalarWhereWithAggregatesInput[]
    OR?: ClienteScalarWhereWithAggregatesInput[]
    NOT?: ClienteScalarWhereWithAggregatesInput | ClienteScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Cliente"> | number
    nome?: StringWithAggregatesFilter<"Cliente"> | string
    cpfCnpj?: StringWithAggregatesFilter<"Cliente"> | string
    cidade?: StringNullableWithAggregatesFilter<"Cliente"> | string | null
    estado?: StringNullableWithAggregatesFilter<"Cliente"> | string | null
    logradouro?: StringNullableWithAggregatesFilter<"Cliente"> | string | null
    numero?: StringNullableWithAggregatesFilter<"Cliente"> | string | null
    bairro?: StringNullableWithAggregatesFilter<"Cliente"> | string | null
    cep?: StringNullableWithAggregatesFilter<"Cliente"> | string | null
    telefone?: StringNullableWithAggregatesFilter<"Cliente"> | string | null
  }

  export type FilialWhereInput = {
    AND?: FilialWhereInput | FilialWhereInput[]
    OR?: FilialWhereInput[]
    NOT?: FilialWhereInput | FilialWhereInput[]
    id?: IntFilter<"Filial"> | number
    empresaId?: IntFilter<"Filial"> | number
    nome?: StringFilter<"Filial"> | string
    cnpj?: StringFilter<"Filial"> | string
    cidade?: StringNullableFilter<"Filial"> | string | null
    estado?: StringNullableFilter<"Filial"> | string | null
    empresa?: XOR<EmpresaRelationFilter, EmpresaWhereInput>
    notasFiscais?: NotasFiscalCabecalhoListRelationFilter
    vendedores?: VendedorListRelationFilter
    rfvParameterSets?: RfvParameterSetListRelationFilter
    maquinasEstoque?: MaquinaEstoqueListRelationFilter
  }

  export type FilialOrderByWithRelationInput = {
    id?: SortOrder
    empresaId?: SortOrder
    nome?: SortOrder
    cnpj?: SortOrder
    cidade?: SortOrderInput | SortOrder
    estado?: SortOrderInput | SortOrder
    empresa?: EmpresaOrderByWithRelationInput
    notasFiscais?: NotasFiscalCabecalhoOrderByRelationAggregateInput
    vendedores?: VendedorOrderByRelationAggregateInput
    rfvParameterSets?: RfvParameterSetOrderByRelationAggregateInput
    maquinasEstoque?: MaquinaEstoqueOrderByRelationAggregateInput
  }

  export type FilialWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    cnpj?: string
    AND?: FilialWhereInput | FilialWhereInput[]
    OR?: FilialWhereInput[]
    NOT?: FilialWhereInput | FilialWhereInput[]
    empresaId?: IntFilter<"Filial"> | number
    nome?: StringFilter<"Filial"> | string
    cidade?: StringNullableFilter<"Filial"> | string | null
    estado?: StringNullableFilter<"Filial"> | string | null
    empresa?: XOR<EmpresaRelationFilter, EmpresaWhereInput>
    notasFiscais?: NotasFiscalCabecalhoListRelationFilter
    vendedores?: VendedorListRelationFilter
    rfvParameterSets?: RfvParameterSetListRelationFilter
    maquinasEstoque?: MaquinaEstoqueListRelationFilter
  }, "id" | "cnpj">

  export type FilialOrderByWithAggregationInput = {
    id?: SortOrder
    empresaId?: SortOrder
    nome?: SortOrder
    cnpj?: SortOrder
    cidade?: SortOrderInput | SortOrder
    estado?: SortOrderInput | SortOrder
    _count?: FilialCountOrderByAggregateInput
    _avg?: FilialAvgOrderByAggregateInput
    _max?: FilialMaxOrderByAggregateInput
    _min?: FilialMinOrderByAggregateInput
    _sum?: FilialSumOrderByAggregateInput
  }

  export type FilialScalarWhereWithAggregatesInput = {
    AND?: FilialScalarWhereWithAggregatesInput | FilialScalarWhereWithAggregatesInput[]
    OR?: FilialScalarWhereWithAggregatesInput[]
    NOT?: FilialScalarWhereWithAggregatesInput | FilialScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Filial"> | number
    empresaId?: IntWithAggregatesFilter<"Filial"> | number
    nome?: StringWithAggregatesFilter<"Filial"> | string
    cnpj?: StringWithAggregatesFilter<"Filial"> | string
    cidade?: StringNullableWithAggregatesFilter<"Filial"> | string | null
    estado?: StringNullableWithAggregatesFilter<"Filial"> | string | null
  }

  export type VendedorWhereInput = {
    AND?: VendedorWhereInput | VendedorWhereInput[]
    OR?: VendedorWhereInput[]
    NOT?: VendedorWhereInput | VendedorWhereInput[]
    id?: IntFilter<"Vendedor"> | number
    nome?: StringFilter<"Vendedor"> | string
    cpf?: StringFilter<"Vendedor"> | string
    filialId?: IntNullableFilter<"Vendedor"> | number | null
    notasFiscais?: NotasFiscalCabecalhoListRelationFilter
    filial?: XOR<FilialNullableRelationFilter, FilialWhereInput> | null
  }

  export type VendedorOrderByWithRelationInput = {
    id?: SortOrder
    nome?: SortOrder
    cpf?: SortOrder
    filialId?: SortOrderInput | SortOrder
    notasFiscais?: NotasFiscalCabecalhoOrderByRelationAggregateInput
    filial?: FilialOrderByWithRelationInput
  }

  export type VendedorWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    cpf?: string
    AND?: VendedorWhereInput | VendedorWhereInput[]
    OR?: VendedorWhereInput[]
    NOT?: VendedorWhereInput | VendedorWhereInput[]
    nome?: StringFilter<"Vendedor"> | string
    filialId?: IntNullableFilter<"Vendedor"> | number | null
    notasFiscais?: NotasFiscalCabecalhoListRelationFilter
    filial?: XOR<FilialNullableRelationFilter, FilialWhereInput> | null
  }, "id" | "cpf">

  export type VendedorOrderByWithAggregationInput = {
    id?: SortOrder
    nome?: SortOrder
    cpf?: SortOrder
    filialId?: SortOrderInput | SortOrder
    _count?: VendedorCountOrderByAggregateInput
    _avg?: VendedorAvgOrderByAggregateInput
    _max?: VendedorMaxOrderByAggregateInput
    _min?: VendedorMinOrderByAggregateInput
    _sum?: VendedorSumOrderByAggregateInput
  }

  export type VendedorScalarWhereWithAggregatesInput = {
    AND?: VendedorScalarWhereWithAggregatesInput | VendedorScalarWhereWithAggregatesInput[]
    OR?: VendedorScalarWhereWithAggregatesInput[]
    NOT?: VendedorScalarWhereWithAggregatesInput | VendedorScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Vendedor"> | number
    nome?: StringWithAggregatesFilter<"Vendedor"> | string
    cpf?: StringWithAggregatesFilter<"Vendedor"> | string
    filialId?: IntNullableWithAggregatesFilter<"Vendedor"> | number | null
  }

  export type ProdutoWhereInput = {
    AND?: ProdutoWhereInput | ProdutoWhereInput[]
    OR?: ProdutoWhereInput[]
    NOT?: ProdutoWhereInput | ProdutoWhereInput[]
    id?: IntFilter<"Produto"> | number
    descricao?: StringFilter<"Produto"> | string
    tipo?: StringFilter<"Produto"> | string
    preco?: DecimalFilter<"Produto"> | Decimal | DecimalJsLike | number | string
    maquinasEstoque?: MaquinaEstoqueListRelationFilter
    notasFiscaisItens?: NotaFiscalItemListRelationFilter
  }

  export type ProdutoOrderByWithRelationInput = {
    id?: SortOrder
    descricao?: SortOrder
    tipo?: SortOrder
    preco?: SortOrder
    maquinasEstoque?: MaquinaEstoqueOrderByRelationAggregateInput
    notasFiscaisItens?: NotaFiscalItemOrderByRelationAggregateInput
  }

  export type ProdutoWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: ProdutoWhereInput | ProdutoWhereInput[]
    OR?: ProdutoWhereInput[]
    NOT?: ProdutoWhereInput | ProdutoWhereInput[]
    descricao?: StringFilter<"Produto"> | string
    tipo?: StringFilter<"Produto"> | string
    preco?: DecimalFilter<"Produto"> | Decimal | DecimalJsLike | number | string
    maquinasEstoque?: MaquinaEstoqueListRelationFilter
    notasFiscaisItens?: NotaFiscalItemListRelationFilter
  }, "id">

  export type ProdutoOrderByWithAggregationInput = {
    id?: SortOrder
    descricao?: SortOrder
    tipo?: SortOrder
    preco?: SortOrder
    _count?: ProdutoCountOrderByAggregateInput
    _avg?: ProdutoAvgOrderByAggregateInput
    _max?: ProdutoMaxOrderByAggregateInput
    _min?: ProdutoMinOrderByAggregateInput
    _sum?: ProdutoSumOrderByAggregateInput
  }

  export type ProdutoScalarWhereWithAggregatesInput = {
    AND?: ProdutoScalarWhereWithAggregatesInput | ProdutoScalarWhereWithAggregatesInput[]
    OR?: ProdutoScalarWhereWithAggregatesInput[]
    NOT?: ProdutoScalarWhereWithAggregatesInput | ProdutoScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Produto"> | number
    descricao?: StringWithAggregatesFilter<"Produto"> | string
    tipo?: StringWithAggregatesFilter<"Produto"> | string
    preco?: DecimalWithAggregatesFilter<"Produto"> | Decimal | DecimalJsLike | number | string
  }

  export type MaquinaEstoqueWhereInput = {
    AND?: MaquinaEstoqueWhereInput | MaquinaEstoqueWhereInput[]
    OR?: MaquinaEstoqueWhereInput[]
    NOT?: MaquinaEstoqueWhereInput | MaquinaEstoqueWhereInput[]
    Chassi?: StringFilter<"MaquinaEstoque"> | string
    produtoId?: IntFilter<"MaquinaEstoque"> | number
    filialId?: IntNullableFilter<"MaquinaEstoque"> | number | null
    Status?: StringNullableFilter<"MaquinaEstoque"> | string | null
    produto?: XOR<ProdutoRelationFilter, ProdutoWhereInput>
    filial?: XOR<FilialNullableRelationFilter, FilialWhereInput> | null
    Notas_Fiscais_Itens?: NotaFiscalItemListRelationFilter
  }

  export type MaquinaEstoqueOrderByWithRelationInput = {
    Chassi?: SortOrder
    produtoId?: SortOrder
    filialId?: SortOrderInput | SortOrder
    Status?: SortOrderInput | SortOrder
    produto?: ProdutoOrderByWithRelationInput
    filial?: FilialOrderByWithRelationInput
    Notas_Fiscais_Itens?: NotaFiscalItemOrderByRelationAggregateInput
  }

  export type MaquinaEstoqueWhereUniqueInput = Prisma.AtLeast<{
    Chassi?: string
    AND?: MaquinaEstoqueWhereInput | MaquinaEstoqueWhereInput[]
    OR?: MaquinaEstoqueWhereInput[]
    NOT?: MaquinaEstoqueWhereInput | MaquinaEstoqueWhereInput[]
    produtoId?: IntFilter<"MaquinaEstoque"> | number
    filialId?: IntNullableFilter<"MaquinaEstoque"> | number | null
    Status?: StringNullableFilter<"MaquinaEstoque"> | string | null
    produto?: XOR<ProdutoRelationFilter, ProdutoWhereInput>
    filial?: XOR<FilialNullableRelationFilter, FilialWhereInput> | null
    Notas_Fiscais_Itens?: NotaFiscalItemListRelationFilter
  }, "Chassi">

  export type MaquinaEstoqueOrderByWithAggregationInput = {
    Chassi?: SortOrder
    produtoId?: SortOrder
    filialId?: SortOrderInput | SortOrder
    Status?: SortOrderInput | SortOrder
    _count?: MaquinaEstoqueCountOrderByAggregateInput
    _avg?: MaquinaEstoqueAvgOrderByAggregateInput
    _max?: MaquinaEstoqueMaxOrderByAggregateInput
    _min?: MaquinaEstoqueMinOrderByAggregateInput
    _sum?: MaquinaEstoqueSumOrderByAggregateInput
  }

  export type MaquinaEstoqueScalarWhereWithAggregatesInput = {
    AND?: MaquinaEstoqueScalarWhereWithAggregatesInput | MaquinaEstoqueScalarWhereWithAggregatesInput[]
    OR?: MaquinaEstoqueScalarWhereWithAggregatesInput[]
    NOT?: MaquinaEstoqueScalarWhereWithAggregatesInput | MaquinaEstoqueScalarWhereWithAggregatesInput[]
    Chassi?: StringWithAggregatesFilter<"MaquinaEstoque"> | string
    produtoId?: IntWithAggregatesFilter<"MaquinaEstoque"> | number
    filialId?: IntNullableWithAggregatesFilter<"MaquinaEstoque"> | number | null
    Status?: StringNullableWithAggregatesFilter<"MaquinaEstoque"> | string | null
  }

  export type NotasFiscalCabecalhoWhereInput = {
    AND?: NotasFiscalCabecalhoWhereInput | NotasFiscalCabecalhoWhereInput[]
    OR?: NotasFiscalCabecalhoWhereInput[]
    NOT?: NotasFiscalCabecalhoWhereInput | NotasFiscalCabecalhoWhereInput[]
    id?: IntFilter<"NotasFiscalCabecalho"> | number
    numeroNota?: IntFilter<"NotasFiscalCabecalho"> | number
    dataEmissao?: DateTimeFilter<"NotasFiscalCabecalho"> | Date | string
    valorTotal?: DecimalFilter<"NotasFiscalCabecalho"> | Decimal | DecimalJsLike | number | string
    filialId?: IntNullableFilter<"NotasFiscalCabecalho"> | number | null
    clienteId?: IntNullableFilter<"NotasFiscalCabecalho"> | number | null
    vendedorId?: IntNullableFilter<"NotasFiscalCabecalho"> | number | null
    filial?: XOR<FilialNullableRelationFilter, FilialWhereInput> | null
    cliente?: XOR<ClienteNullableRelationFilter, ClienteWhereInput> | null
    vendedor?: XOR<VendedorNullableRelationFilter, VendedorWhereInput> | null
    itens?: NotaFiscalItemListRelationFilter
  }

  export type NotasFiscalCabecalhoOrderByWithRelationInput = {
    id?: SortOrder
    numeroNota?: SortOrder
    dataEmissao?: SortOrder
    valorTotal?: SortOrder
    filialId?: SortOrderInput | SortOrder
    clienteId?: SortOrderInput | SortOrder
    vendedorId?: SortOrderInput | SortOrder
    filial?: FilialOrderByWithRelationInput
    cliente?: ClienteOrderByWithRelationInput
    vendedor?: VendedorOrderByWithRelationInput
    itens?: NotaFiscalItemOrderByRelationAggregateInput
  }

  export type NotasFiscalCabecalhoWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    numeroNota_filialId?: NotasFiscalCabecalhoNumeroNotaFilialIdCompoundUniqueInput
    AND?: NotasFiscalCabecalhoWhereInput | NotasFiscalCabecalhoWhereInput[]
    OR?: NotasFiscalCabecalhoWhereInput[]
    NOT?: NotasFiscalCabecalhoWhereInput | NotasFiscalCabecalhoWhereInput[]
    numeroNota?: IntFilter<"NotasFiscalCabecalho"> | number
    dataEmissao?: DateTimeFilter<"NotasFiscalCabecalho"> | Date | string
    valorTotal?: DecimalFilter<"NotasFiscalCabecalho"> | Decimal | DecimalJsLike | number | string
    filialId?: IntNullableFilter<"NotasFiscalCabecalho"> | number | null
    clienteId?: IntNullableFilter<"NotasFiscalCabecalho"> | number | null
    vendedorId?: IntNullableFilter<"NotasFiscalCabecalho"> | number | null
    filial?: XOR<FilialNullableRelationFilter, FilialWhereInput> | null
    cliente?: XOR<ClienteNullableRelationFilter, ClienteWhereInput> | null
    vendedor?: XOR<VendedorNullableRelationFilter, VendedorWhereInput> | null
    itens?: NotaFiscalItemListRelationFilter
  }, "id" | "numeroNota_filialId">

  export type NotasFiscalCabecalhoOrderByWithAggregationInput = {
    id?: SortOrder
    numeroNota?: SortOrder
    dataEmissao?: SortOrder
    valorTotal?: SortOrder
    filialId?: SortOrderInput | SortOrder
    clienteId?: SortOrderInput | SortOrder
    vendedorId?: SortOrderInput | SortOrder
    _count?: NotasFiscalCabecalhoCountOrderByAggregateInput
    _avg?: NotasFiscalCabecalhoAvgOrderByAggregateInput
    _max?: NotasFiscalCabecalhoMaxOrderByAggregateInput
    _min?: NotasFiscalCabecalhoMinOrderByAggregateInput
    _sum?: NotasFiscalCabecalhoSumOrderByAggregateInput
  }

  export type NotasFiscalCabecalhoScalarWhereWithAggregatesInput = {
    AND?: NotasFiscalCabecalhoScalarWhereWithAggregatesInput | NotasFiscalCabecalhoScalarWhereWithAggregatesInput[]
    OR?: NotasFiscalCabecalhoScalarWhereWithAggregatesInput[]
    NOT?: NotasFiscalCabecalhoScalarWhereWithAggregatesInput | NotasFiscalCabecalhoScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"NotasFiscalCabecalho"> | number
    numeroNota?: IntWithAggregatesFilter<"NotasFiscalCabecalho"> | number
    dataEmissao?: DateTimeWithAggregatesFilter<"NotasFiscalCabecalho"> | Date | string
    valorTotal?: DecimalWithAggregatesFilter<"NotasFiscalCabecalho"> | Decimal | DecimalJsLike | number | string
    filialId?: IntNullableWithAggregatesFilter<"NotasFiscalCabecalho"> | number | null
    clienteId?: IntNullableWithAggregatesFilter<"NotasFiscalCabecalho"> | number | null
    vendedorId?: IntNullableWithAggregatesFilter<"NotasFiscalCabecalho"> | number | null
  }

  export type NotaFiscalItemWhereInput = {
    AND?: NotaFiscalItemWhereInput | NotaFiscalItemWhereInput[]
    OR?: NotaFiscalItemWhereInput[]
    NOT?: NotaFiscalItemWhereInput | NotaFiscalItemWhereInput[]
    id?: IntFilter<"NotaFiscalItem"> | number
    notaFiscalId?: IntFilter<"NotaFiscalItem"> | number
    produtoId?: IntFilter<"NotaFiscalItem"> | number
    Quantidade?: DecimalFilter<"NotaFiscalItem"> | Decimal | DecimalJsLike | number | string
    valorUnitario?: DecimalFilter<"NotaFiscalItem"> | Decimal | DecimalJsLike | number | string
    valorTotalItem?: DecimalFilter<"NotaFiscalItem"> | Decimal | DecimalJsLike | number | string
    Chassi?: StringNullableFilter<"NotaFiscalItem"> | string | null
    Maquinas_Estoque?: XOR<MaquinaEstoqueNullableRelationFilter, MaquinaEstoqueWhereInput> | null
    notaFiscal?: XOR<NotasFiscalCabecalhoRelationFilter, NotasFiscalCabecalhoWhereInput>
    produto?: XOR<ProdutoRelationFilter, ProdutoWhereInput>
  }

  export type NotaFiscalItemOrderByWithRelationInput = {
    id?: SortOrder
    notaFiscalId?: SortOrder
    produtoId?: SortOrder
    Quantidade?: SortOrder
    valorUnitario?: SortOrder
    valorTotalItem?: SortOrder
    Chassi?: SortOrderInput | SortOrder
    Maquinas_Estoque?: MaquinaEstoqueOrderByWithRelationInput
    notaFiscal?: NotasFiscalCabecalhoOrderByWithRelationInput
    produto?: ProdutoOrderByWithRelationInput
  }

  export type NotaFiscalItemWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: NotaFiscalItemWhereInput | NotaFiscalItemWhereInput[]
    OR?: NotaFiscalItemWhereInput[]
    NOT?: NotaFiscalItemWhereInput | NotaFiscalItemWhereInput[]
    notaFiscalId?: IntFilter<"NotaFiscalItem"> | number
    produtoId?: IntFilter<"NotaFiscalItem"> | number
    Quantidade?: DecimalFilter<"NotaFiscalItem"> | Decimal | DecimalJsLike | number | string
    valorUnitario?: DecimalFilter<"NotaFiscalItem"> | Decimal | DecimalJsLike | number | string
    valorTotalItem?: DecimalFilter<"NotaFiscalItem"> | Decimal | DecimalJsLike | number | string
    Chassi?: StringNullableFilter<"NotaFiscalItem"> | string | null
    Maquinas_Estoque?: XOR<MaquinaEstoqueNullableRelationFilter, MaquinaEstoqueWhereInput> | null
    notaFiscal?: XOR<NotasFiscalCabecalhoRelationFilter, NotasFiscalCabecalhoWhereInput>
    produto?: XOR<ProdutoRelationFilter, ProdutoWhereInput>
  }, "id">

  export type NotaFiscalItemOrderByWithAggregationInput = {
    id?: SortOrder
    notaFiscalId?: SortOrder
    produtoId?: SortOrder
    Quantidade?: SortOrder
    valorUnitario?: SortOrder
    valorTotalItem?: SortOrder
    Chassi?: SortOrderInput | SortOrder
    _count?: NotaFiscalItemCountOrderByAggregateInput
    _avg?: NotaFiscalItemAvgOrderByAggregateInput
    _max?: NotaFiscalItemMaxOrderByAggregateInput
    _min?: NotaFiscalItemMinOrderByAggregateInput
    _sum?: NotaFiscalItemSumOrderByAggregateInput
  }

  export type NotaFiscalItemScalarWhereWithAggregatesInput = {
    AND?: NotaFiscalItemScalarWhereWithAggregatesInput | NotaFiscalItemScalarWhereWithAggregatesInput[]
    OR?: NotaFiscalItemScalarWhereWithAggregatesInput[]
    NOT?: NotaFiscalItemScalarWhereWithAggregatesInput | NotaFiscalItemScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"NotaFiscalItem"> | number
    notaFiscalId?: IntWithAggregatesFilter<"NotaFiscalItem"> | number
    produtoId?: IntWithAggregatesFilter<"NotaFiscalItem"> | number
    Quantidade?: DecimalWithAggregatesFilter<"NotaFiscalItem"> | Decimal | DecimalJsLike | number | string
    valorUnitario?: DecimalWithAggregatesFilter<"NotaFiscalItem"> | Decimal | DecimalJsLike | number | string
    valorTotalItem?: DecimalWithAggregatesFilter<"NotaFiscalItem"> | Decimal | DecimalJsLike | number | string
    Chassi?: StringNullableWithAggregatesFilter<"NotaFiscalItem"> | string | null
  }

  export type UserWhereInput = {
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    id?: IntFilter<"User"> | number
    email?: StringFilter<"User"> | string
    password?: StringFilter<"User"> | string
    createdAt?: DateTimeFilter<"User"> | Date | string
  }

  export type UserOrderByWithRelationInput = {
    id?: SortOrder
    email?: SortOrder
    password?: SortOrder
    createdAt?: SortOrder
  }

  export type UserWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    email?: string
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    password?: StringFilter<"User"> | string
    createdAt?: DateTimeFilter<"User"> | Date | string
  }, "id" | "email">

  export type UserOrderByWithAggregationInput = {
    id?: SortOrder
    email?: SortOrder
    password?: SortOrder
    createdAt?: SortOrder
    _count?: UserCountOrderByAggregateInput
    _avg?: UserAvgOrderByAggregateInput
    _max?: UserMaxOrderByAggregateInput
    _min?: UserMinOrderByAggregateInput
    _sum?: UserSumOrderByAggregateInput
  }

  export type UserScalarWhereWithAggregatesInput = {
    AND?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    OR?: UserScalarWhereWithAggregatesInput[]
    NOT?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"User"> | number
    email?: StringWithAggregatesFilter<"User"> | string
    password?: StringWithAggregatesFilter<"User"> | string
    createdAt?: DateTimeWithAggregatesFilter<"User"> | Date | string
  }

  export type RfvParameterSetWhereInput = {
    AND?: RfvParameterSetWhereInput | RfvParameterSetWhereInput[]
    OR?: RfvParameterSetWhereInput[]
    NOT?: RfvParameterSetWhereInput | RfvParameterSetWhereInput[]
    id?: IntFilter<"RfvParameterSet"> | number
    filialId?: IntNullableFilter<"RfvParameterSet"> | number | null
    name?: StringFilter<"RfvParameterSet"> | string
    strategy?: EnumRfvStrategyFilter<"RfvParameterSet"> | $Enums.RfvStrategy
    windowDays?: IntFilter<"RfvParameterSet"> | number
    weights?: JsonFilter<"RfvParameterSet">
    ruleRecency?: JsonFilter<"RfvParameterSet">
    ruleFrequency?: JsonFilter<"RfvParameterSet">
    ruleValue?: JsonFilter<"RfvParameterSet">
    effectiveFrom?: DateTimeFilter<"RfvParameterSet"> | Date | string
    effectiveTo?: DateTimeNullableFilter<"RfvParameterSet"> | Date | string | null
    createdAt?: DateTimeFilter<"RfvParameterSet"> | Date | string
    updatedAt?: DateTimeFilter<"RfvParameterSet"> | Date | string
    calculationStrategy?: EnumCalculationStrategyFilter<"RfvParameterSet"> | $Enums.CalculationStrategy
    classRanges?: JsonNullableFilter<"RfvParameterSet">
    conditionalRules?: JsonNullableFilter<"RfvParameterSet">
    filial?: XOR<FilialNullableRelationFilter, FilialWhereInput> | null
    segments?: RfvSegmentListRelationFilter
  }

  export type RfvParameterSetOrderByWithRelationInput = {
    id?: SortOrder
    filialId?: SortOrderInput | SortOrder
    name?: SortOrder
    strategy?: SortOrder
    windowDays?: SortOrder
    weights?: SortOrder
    ruleRecency?: SortOrder
    ruleFrequency?: SortOrder
    ruleValue?: SortOrder
    effectiveFrom?: SortOrder
    effectiveTo?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    calculationStrategy?: SortOrder
    classRanges?: SortOrderInput | SortOrder
    conditionalRules?: SortOrderInput | SortOrder
    filial?: FilialOrderByWithRelationInput
    segments?: RfvSegmentOrderByRelationAggregateInput
  }

  export type RfvParameterSetWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: RfvParameterSetWhereInput | RfvParameterSetWhereInput[]
    OR?: RfvParameterSetWhereInput[]
    NOT?: RfvParameterSetWhereInput | RfvParameterSetWhereInput[]
    filialId?: IntNullableFilter<"RfvParameterSet"> | number | null
    name?: StringFilter<"RfvParameterSet"> | string
    strategy?: EnumRfvStrategyFilter<"RfvParameterSet"> | $Enums.RfvStrategy
    windowDays?: IntFilter<"RfvParameterSet"> | number
    weights?: JsonFilter<"RfvParameterSet">
    ruleRecency?: JsonFilter<"RfvParameterSet">
    ruleFrequency?: JsonFilter<"RfvParameterSet">
    ruleValue?: JsonFilter<"RfvParameterSet">
    effectiveFrom?: DateTimeFilter<"RfvParameterSet"> | Date | string
    effectiveTo?: DateTimeNullableFilter<"RfvParameterSet"> | Date | string | null
    createdAt?: DateTimeFilter<"RfvParameterSet"> | Date | string
    updatedAt?: DateTimeFilter<"RfvParameterSet"> | Date | string
    calculationStrategy?: EnumCalculationStrategyFilter<"RfvParameterSet"> | $Enums.CalculationStrategy
    classRanges?: JsonNullableFilter<"RfvParameterSet">
    conditionalRules?: JsonNullableFilter<"RfvParameterSet">
    filial?: XOR<FilialNullableRelationFilter, FilialWhereInput> | null
    segments?: RfvSegmentListRelationFilter
  }, "id">

  export type RfvParameterSetOrderByWithAggregationInput = {
    id?: SortOrder
    filialId?: SortOrderInput | SortOrder
    name?: SortOrder
    strategy?: SortOrder
    windowDays?: SortOrder
    weights?: SortOrder
    ruleRecency?: SortOrder
    ruleFrequency?: SortOrder
    ruleValue?: SortOrder
    effectiveFrom?: SortOrder
    effectiveTo?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    calculationStrategy?: SortOrder
    classRanges?: SortOrderInput | SortOrder
    conditionalRules?: SortOrderInput | SortOrder
    _count?: RfvParameterSetCountOrderByAggregateInput
    _avg?: RfvParameterSetAvgOrderByAggregateInput
    _max?: RfvParameterSetMaxOrderByAggregateInput
    _min?: RfvParameterSetMinOrderByAggregateInput
    _sum?: RfvParameterSetSumOrderByAggregateInput
  }

  export type RfvParameterSetScalarWhereWithAggregatesInput = {
    AND?: RfvParameterSetScalarWhereWithAggregatesInput | RfvParameterSetScalarWhereWithAggregatesInput[]
    OR?: RfvParameterSetScalarWhereWithAggregatesInput[]
    NOT?: RfvParameterSetScalarWhereWithAggregatesInput | RfvParameterSetScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"RfvParameterSet"> | number
    filialId?: IntNullableWithAggregatesFilter<"RfvParameterSet"> | number | null
    name?: StringWithAggregatesFilter<"RfvParameterSet"> | string
    strategy?: EnumRfvStrategyWithAggregatesFilter<"RfvParameterSet"> | $Enums.RfvStrategy
    windowDays?: IntWithAggregatesFilter<"RfvParameterSet"> | number
    weights?: JsonWithAggregatesFilter<"RfvParameterSet">
    ruleRecency?: JsonWithAggregatesFilter<"RfvParameterSet">
    ruleFrequency?: JsonWithAggregatesFilter<"RfvParameterSet">
    ruleValue?: JsonWithAggregatesFilter<"RfvParameterSet">
    effectiveFrom?: DateTimeWithAggregatesFilter<"RfvParameterSet"> | Date | string
    effectiveTo?: DateTimeNullableWithAggregatesFilter<"RfvParameterSet"> | Date | string | null
    createdAt?: DateTimeWithAggregatesFilter<"RfvParameterSet"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"RfvParameterSet"> | Date | string
    calculationStrategy?: EnumCalculationStrategyWithAggregatesFilter<"RfvParameterSet"> | $Enums.CalculationStrategy
    classRanges?: JsonNullableWithAggregatesFilter<"RfvParameterSet">
    conditionalRules?: JsonNullableWithAggregatesFilter<"RfvParameterSet">
  }

  export type RfvSegmentWhereInput = {
    AND?: RfvSegmentWhereInput | RfvSegmentWhereInput[]
    OR?: RfvSegmentWhereInput[]
    NOT?: RfvSegmentWhereInput | RfvSegmentWhereInput[]
    id?: IntFilter<"RfvSegment"> | number
    parameterSetId?: IntFilter<"RfvSegment"> | number
    name?: StringFilter<"RfvSegment"> | string
    rules?: JsonFilter<"RfvSegment">
    priority?: IntFilter<"RfvSegment"> | number
    parameterSet?: XOR<RfvParameterSetRelationFilter, RfvParameterSetWhereInput>
  }

  export type RfvSegmentOrderByWithRelationInput = {
    id?: SortOrder
    parameterSetId?: SortOrder
    name?: SortOrder
    rules?: SortOrder
    priority?: SortOrder
    parameterSet?: RfvParameterSetOrderByWithRelationInput
  }

  export type RfvSegmentWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: RfvSegmentWhereInput | RfvSegmentWhereInput[]
    OR?: RfvSegmentWhereInput[]
    NOT?: RfvSegmentWhereInput | RfvSegmentWhereInput[]
    parameterSetId?: IntFilter<"RfvSegment"> | number
    name?: StringFilter<"RfvSegment"> | string
    rules?: JsonFilter<"RfvSegment">
    priority?: IntFilter<"RfvSegment"> | number
    parameterSet?: XOR<RfvParameterSetRelationFilter, RfvParameterSetWhereInput>
  }, "id">

  export type RfvSegmentOrderByWithAggregationInput = {
    id?: SortOrder
    parameterSetId?: SortOrder
    name?: SortOrder
    rules?: SortOrder
    priority?: SortOrder
    _count?: RfvSegmentCountOrderByAggregateInput
    _avg?: RfvSegmentAvgOrderByAggregateInput
    _max?: RfvSegmentMaxOrderByAggregateInput
    _min?: RfvSegmentMinOrderByAggregateInput
    _sum?: RfvSegmentSumOrderByAggregateInput
  }

  export type RfvSegmentScalarWhereWithAggregatesInput = {
    AND?: RfvSegmentScalarWhereWithAggregatesInput | RfvSegmentScalarWhereWithAggregatesInput[]
    OR?: RfvSegmentScalarWhereWithAggregatesInput[]
    NOT?: RfvSegmentScalarWhereWithAggregatesInput | RfvSegmentScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"RfvSegment"> | number
    parameterSetId?: IntWithAggregatesFilter<"RfvSegment"> | number
    name?: StringWithAggregatesFilter<"RfvSegment"> | string
    rules?: JsonWithAggregatesFilter<"RfvSegment">
    priority?: IntWithAggregatesFilter<"RfvSegment"> | number
  }

  export type EmpresaCreateInput = {
    razaoSocial: string
    nomeFantasia?: string | null
    cnpjMatriz: string
    inscricaoEstadual?: string | null
    cidade?: string | null
    estado?: string | null
    logradouro?: string | null
    numero?: string | null
    bairro?: string | null
    cep?: string | null
    telefone?: string | null
    email?: string | null
    ativo?: boolean
    dataCriacao?: Date | string
    dataAtualizacao?: Date | string
    filiais?: FilialCreateNestedManyWithoutEmpresaInput
  }

  export type EmpresaUncheckedCreateInput = {
    id?: number
    razaoSocial: string
    nomeFantasia?: string | null
    cnpjMatriz: string
    inscricaoEstadual?: string | null
    cidade?: string | null
    estado?: string | null
    logradouro?: string | null
    numero?: string | null
    bairro?: string | null
    cep?: string | null
    telefone?: string | null
    email?: string | null
    ativo?: boolean
    dataCriacao?: Date | string
    dataAtualizacao?: Date | string
    filiais?: FilialUncheckedCreateNestedManyWithoutEmpresaInput
  }

  export type EmpresaUpdateInput = {
    razaoSocial?: StringFieldUpdateOperationsInput | string
    nomeFantasia?: NullableStringFieldUpdateOperationsInput | string | null
    cnpjMatriz?: StringFieldUpdateOperationsInput | string
    inscricaoEstadual?: NullableStringFieldUpdateOperationsInput | string | null
    cidade?: NullableStringFieldUpdateOperationsInput | string | null
    estado?: NullableStringFieldUpdateOperationsInput | string | null
    logradouro?: NullableStringFieldUpdateOperationsInput | string | null
    numero?: NullableStringFieldUpdateOperationsInput | string | null
    bairro?: NullableStringFieldUpdateOperationsInput | string | null
    cep?: NullableStringFieldUpdateOperationsInput | string | null
    telefone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    ativo?: BoolFieldUpdateOperationsInput | boolean
    dataCriacao?: DateTimeFieldUpdateOperationsInput | Date | string
    dataAtualizacao?: DateTimeFieldUpdateOperationsInput | Date | string
    filiais?: FilialUpdateManyWithoutEmpresaNestedInput
  }

  export type EmpresaUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    razaoSocial?: StringFieldUpdateOperationsInput | string
    nomeFantasia?: NullableStringFieldUpdateOperationsInput | string | null
    cnpjMatriz?: StringFieldUpdateOperationsInput | string
    inscricaoEstadual?: NullableStringFieldUpdateOperationsInput | string | null
    cidade?: NullableStringFieldUpdateOperationsInput | string | null
    estado?: NullableStringFieldUpdateOperationsInput | string | null
    logradouro?: NullableStringFieldUpdateOperationsInput | string | null
    numero?: NullableStringFieldUpdateOperationsInput | string | null
    bairro?: NullableStringFieldUpdateOperationsInput | string | null
    cep?: NullableStringFieldUpdateOperationsInput | string | null
    telefone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    ativo?: BoolFieldUpdateOperationsInput | boolean
    dataCriacao?: DateTimeFieldUpdateOperationsInput | Date | string
    dataAtualizacao?: DateTimeFieldUpdateOperationsInput | Date | string
    filiais?: FilialUncheckedUpdateManyWithoutEmpresaNestedInput
  }

  export type EmpresaCreateManyInput = {
    id?: number
    razaoSocial: string
    nomeFantasia?: string | null
    cnpjMatriz: string
    inscricaoEstadual?: string | null
    cidade?: string | null
    estado?: string | null
    logradouro?: string | null
    numero?: string | null
    bairro?: string | null
    cep?: string | null
    telefone?: string | null
    email?: string | null
    ativo?: boolean
    dataCriacao?: Date | string
    dataAtualizacao?: Date | string
  }

  export type EmpresaUpdateManyMutationInput = {
    razaoSocial?: StringFieldUpdateOperationsInput | string
    nomeFantasia?: NullableStringFieldUpdateOperationsInput | string | null
    cnpjMatriz?: StringFieldUpdateOperationsInput | string
    inscricaoEstadual?: NullableStringFieldUpdateOperationsInput | string | null
    cidade?: NullableStringFieldUpdateOperationsInput | string | null
    estado?: NullableStringFieldUpdateOperationsInput | string | null
    logradouro?: NullableStringFieldUpdateOperationsInput | string | null
    numero?: NullableStringFieldUpdateOperationsInput | string | null
    bairro?: NullableStringFieldUpdateOperationsInput | string | null
    cep?: NullableStringFieldUpdateOperationsInput | string | null
    telefone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    ativo?: BoolFieldUpdateOperationsInput | boolean
    dataCriacao?: DateTimeFieldUpdateOperationsInput | Date | string
    dataAtualizacao?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EmpresaUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    razaoSocial?: StringFieldUpdateOperationsInput | string
    nomeFantasia?: NullableStringFieldUpdateOperationsInput | string | null
    cnpjMatriz?: StringFieldUpdateOperationsInput | string
    inscricaoEstadual?: NullableStringFieldUpdateOperationsInput | string | null
    cidade?: NullableStringFieldUpdateOperationsInput | string | null
    estado?: NullableStringFieldUpdateOperationsInput | string | null
    logradouro?: NullableStringFieldUpdateOperationsInput | string | null
    numero?: NullableStringFieldUpdateOperationsInput | string | null
    bairro?: NullableStringFieldUpdateOperationsInput | string | null
    cep?: NullableStringFieldUpdateOperationsInput | string | null
    telefone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    ativo?: BoolFieldUpdateOperationsInput | boolean
    dataCriacao?: DateTimeFieldUpdateOperationsInput | Date | string
    dataAtualizacao?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ClienteCreateInput = {
    nome: string
    cpfCnpj: string
    cidade?: string | null
    estado?: string | null
    logradouro?: string | null
    numero?: string | null
    bairro?: string | null
    cep?: string | null
    telefone?: string | null
    notasFiscais?: NotasFiscalCabecalhoCreateNestedManyWithoutClienteInput
  }

  export type ClienteUncheckedCreateInput = {
    id?: number
    nome: string
    cpfCnpj: string
    cidade?: string | null
    estado?: string | null
    logradouro?: string | null
    numero?: string | null
    bairro?: string | null
    cep?: string | null
    telefone?: string | null
    notasFiscais?: NotasFiscalCabecalhoUncheckedCreateNestedManyWithoutClienteInput
  }

  export type ClienteUpdateInput = {
    nome?: StringFieldUpdateOperationsInput | string
    cpfCnpj?: StringFieldUpdateOperationsInput | string
    cidade?: NullableStringFieldUpdateOperationsInput | string | null
    estado?: NullableStringFieldUpdateOperationsInput | string | null
    logradouro?: NullableStringFieldUpdateOperationsInput | string | null
    numero?: NullableStringFieldUpdateOperationsInput | string | null
    bairro?: NullableStringFieldUpdateOperationsInput | string | null
    cep?: NullableStringFieldUpdateOperationsInput | string | null
    telefone?: NullableStringFieldUpdateOperationsInput | string | null
    notasFiscais?: NotasFiscalCabecalhoUpdateManyWithoutClienteNestedInput
  }

  export type ClienteUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    nome?: StringFieldUpdateOperationsInput | string
    cpfCnpj?: StringFieldUpdateOperationsInput | string
    cidade?: NullableStringFieldUpdateOperationsInput | string | null
    estado?: NullableStringFieldUpdateOperationsInput | string | null
    logradouro?: NullableStringFieldUpdateOperationsInput | string | null
    numero?: NullableStringFieldUpdateOperationsInput | string | null
    bairro?: NullableStringFieldUpdateOperationsInput | string | null
    cep?: NullableStringFieldUpdateOperationsInput | string | null
    telefone?: NullableStringFieldUpdateOperationsInput | string | null
    notasFiscais?: NotasFiscalCabecalhoUncheckedUpdateManyWithoutClienteNestedInput
  }

  export type ClienteCreateManyInput = {
    id?: number
    nome: string
    cpfCnpj: string
    cidade?: string | null
    estado?: string | null
    logradouro?: string | null
    numero?: string | null
    bairro?: string | null
    cep?: string | null
    telefone?: string | null
  }

  export type ClienteUpdateManyMutationInput = {
    nome?: StringFieldUpdateOperationsInput | string
    cpfCnpj?: StringFieldUpdateOperationsInput | string
    cidade?: NullableStringFieldUpdateOperationsInput | string | null
    estado?: NullableStringFieldUpdateOperationsInput | string | null
    logradouro?: NullableStringFieldUpdateOperationsInput | string | null
    numero?: NullableStringFieldUpdateOperationsInput | string | null
    bairro?: NullableStringFieldUpdateOperationsInput | string | null
    cep?: NullableStringFieldUpdateOperationsInput | string | null
    telefone?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ClienteUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    nome?: StringFieldUpdateOperationsInput | string
    cpfCnpj?: StringFieldUpdateOperationsInput | string
    cidade?: NullableStringFieldUpdateOperationsInput | string | null
    estado?: NullableStringFieldUpdateOperationsInput | string | null
    logradouro?: NullableStringFieldUpdateOperationsInput | string | null
    numero?: NullableStringFieldUpdateOperationsInput | string | null
    bairro?: NullableStringFieldUpdateOperationsInput | string | null
    cep?: NullableStringFieldUpdateOperationsInput | string | null
    telefone?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type FilialCreateInput = {
    nome: string
    cnpj: string
    cidade?: string | null
    estado?: string | null
    empresa: EmpresaCreateNestedOneWithoutFiliaisInput
    notasFiscais?: NotasFiscalCabecalhoCreateNestedManyWithoutFilialInput
    vendedores?: VendedorCreateNestedManyWithoutFilialInput
    rfvParameterSets?: RfvParameterSetCreateNestedManyWithoutFilialInput
    maquinasEstoque?: MaquinaEstoqueCreateNestedManyWithoutFilialInput
  }

  export type FilialUncheckedCreateInput = {
    id?: number
    empresaId: number
    nome: string
    cnpj: string
    cidade?: string | null
    estado?: string | null
    notasFiscais?: NotasFiscalCabecalhoUncheckedCreateNestedManyWithoutFilialInput
    vendedores?: VendedorUncheckedCreateNestedManyWithoutFilialInput
    rfvParameterSets?: RfvParameterSetUncheckedCreateNestedManyWithoutFilialInput
    maquinasEstoque?: MaquinaEstoqueUncheckedCreateNestedManyWithoutFilialInput
  }

  export type FilialUpdateInput = {
    nome?: StringFieldUpdateOperationsInput | string
    cnpj?: StringFieldUpdateOperationsInput | string
    cidade?: NullableStringFieldUpdateOperationsInput | string | null
    estado?: NullableStringFieldUpdateOperationsInput | string | null
    empresa?: EmpresaUpdateOneRequiredWithoutFiliaisNestedInput
    notasFiscais?: NotasFiscalCabecalhoUpdateManyWithoutFilialNestedInput
    vendedores?: VendedorUpdateManyWithoutFilialNestedInput
    rfvParameterSets?: RfvParameterSetUpdateManyWithoutFilialNestedInput
    maquinasEstoque?: MaquinaEstoqueUpdateManyWithoutFilialNestedInput
  }

  export type FilialUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    empresaId?: IntFieldUpdateOperationsInput | number
    nome?: StringFieldUpdateOperationsInput | string
    cnpj?: StringFieldUpdateOperationsInput | string
    cidade?: NullableStringFieldUpdateOperationsInput | string | null
    estado?: NullableStringFieldUpdateOperationsInput | string | null
    notasFiscais?: NotasFiscalCabecalhoUncheckedUpdateManyWithoutFilialNestedInput
    vendedores?: VendedorUncheckedUpdateManyWithoutFilialNestedInput
    rfvParameterSets?: RfvParameterSetUncheckedUpdateManyWithoutFilialNestedInput
    maquinasEstoque?: MaquinaEstoqueUncheckedUpdateManyWithoutFilialNestedInput
  }

  export type FilialCreateManyInput = {
    id?: number
    empresaId: number
    nome: string
    cnpj: string
    cidade?: string | null
    estado?: string | null
  }

  export type FilialUpdateManyMutationInput = {
    nome?: StringFieldUpdateOperationsInput | string
    cnpj?: StringFieldUpdateOperationsInput | string
    cidade?: NullableStringFieldUpdateOperationsInput | string | null
    estado?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type FilialUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    empresaId?: IntFieldUpdateOperationsInput | number
    nome?: StringFieldUpdateOperationsInput | string
    cnpj?: StringFieldUpdateOperationsInput | string
    cidade?: NullableStringFieldUpdateOperationsInput | string | null
    estado?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type VendedorCreateInput = {
    nome: string
    cpf: string
    notasFiscais?: NotasFiscalCabecalhoCreateNestedManyWithoutVendedorInput
    filial?: FilialCreateNestedOneWithoutVendedoresInput
  }

  export type VendedorUncheckedCreateInput = {
    id?: number
    nome: string
    cpf: string
    filialId?: number | null
    notasFiscais?: NotasFiscalCabecalhoUncheckedCreateNestedManyWithoutVendedorInput
  }

  export type VendedorUpdateInput = {
    nome?: StringFieldUpdateOperationsInput | string
    cpf?: StringFieldUpdateOperationsInput | string
    notasFiscais?: NotasFiscalCabecalhoUpdateManyWithoutVendedorNestedInput
    filial?: FilialUpdateOneWithoutVendedoresNestedInput
  }

  export type VendedorUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    nome?: StringFieldUpdateOperationsInput | string
    cpf?: StringFieldUpdateOperationsInput | string
    filialId?: NullableIntFieldUpdateOperationsInput | number | null
    notasFiscais?: NotasFiscalCabecalhoUncheckedUpdateManyWithoutVendedorNestedInput
  }

  export type VendedorCreateManyInput = {
    id?: number
    nome: string
    cpf: string
    filialId?: number | null
  }

  export type VendedorUpdateManyMutationInput = {
    nome?: StringFieldUpdateOperationsInput | string
    cpf?: StringFieldUpdateOperationsInput | string
  }

  export type VendedorUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    nome?: StringFieldUpdateOperationsInput | string
    cpf?: StringFieldUpdateOperationsInput | string
    filialId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type ProdutoCreateInput = {
    descricao: string
    tipo: string
    preco: Decimal | DecimalJsLike | number | string
    maquinasEstoque?: MaquinaEstoqueCreateNestedManyWithoutProdutoInput
    notasFiscaisItens?: NotaFiscalItemCreateNestedManyWithoutProdutoInput
  }

  export type ProdutoUncheckedCreateInput = {
    id?: number
    descricao: string
    tipo: string
    preco: Decimal | DecimalJsLike | number | string
    maquinasEstoque?: MaquinaEstoqueUncheckedCreateNestedManyWithoutProdutoInput
    notasFiscaisItens?: NotaFiscalItemUncheckedCreateNestedManyWithoutProdutoInput
  }

  export type ProdutoUpdateInput = {
    descricao?: StringFieldUpdateOperationsInput | string
    tipo?: StringFieldUpdateOperationsInput | string
    preco?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    maquinasEstoque?: MaquinaEstoqueUpdateManyWithoutProdutoNestedInput
    notasFiscaisItens?: NotaFiscalItemUpdateManyWithoutProdutoNestedInput
  }

  export type ProdutoUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    descricao?: StringFieldUpdateOperationsInput | string
    tipo?: StringFieldUpdateOperationsInput | string
    preco?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    maquinasEstoque?: MaquinaEstoqueUncheckedUpdateManyWithoutProdutoNestedInput
    notasFiscaisItens?: NotaFiscalItemUncheckedUpdateManyWithoutProdutoNestedInput
  }

  export type ProdutoCreateManyInput = {
    id?: number
    descricao: string
    tipo: string
    preco: Decimal | DecimalJsLike | number | string
  }

  export type ProdutoUpdateManyMutationInput = {
    descricao?: StringFieldUpdateOperationsInput | string
    tipo?: StringFieldUpdateOperationsInput | string
    preco?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
  }

  export type ProdutoUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    descricao?: StringFieldUpdateOperationsInput | string
    tipo?: StringFieldUpdateOperationsInput | string
    preco?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
  }

  export type MaquinaEstoqueCreateInput = {
    Chassi: string
    Status?: string | null
    produto: ProdutoCreateNestedOneWithoutMaquinasEstoqueInput
    filial?: FilialCreateNestedOneWithoutMaquinasEstoqueInput
    Notas_Fiscais_Itens?: NotaFiscalItemCreateNestedManyWithoutMaquinas_EstoqueInput
  }

  export type MaquinaEstoqueUncheckedCreateInput = {
    Chassi: string
    produtoId: number
    filialId?: number | null
    Status?: string | null
    Notas_Fiscais_Itens?: NotaFiscalItemUncheckedCreateNestedManyWithoutMaquinas_EstoqueInput
  }

  export type MaquinaEstoqueUpdateInput = {
    Chassi?: StringFieldUpdateOperationsInput | string
    Status?: NullableStringFieldUpdateOperationsInput | string | null
    produto?: ProdutoUpdateOneRequiredWithoutMaquinasEstoqueNestedInput
    filial?: FilialUpdateOneWithoutMaquinasEstoqueNestedInput
    Notas_Fiscais_Itens?: NotaFiscalItemUpdateManyWithoutMaquinas_EstoqueNestedInput
  }

  export type MaquinaEstoqueUncheckedUpdateInput = {
    Chassi?: StringFieldUpdateOperationsInput | string
    produtoId?: IntFieldUpdateOperationsInput | number
    filialId?: NullableIntFieldUpdateOperationsInput | number | null
    Status?: NullableStringFieldUpdateOperationsInput | string | null
    Notas_Fiscais_Itens?: NotaFiscalItemUncheckedUpdateManyWithoutMaquinas_EstoqueNestedInput
  }

  export type MaquinaEstoqueCreateManyInput = {
    Chassi: string
    produtoId: number
    filialId?: number | null
    Status?: string | null
  }

  export type MaquinaEstoqueUpdateManyMutationInput = {
    Chassi?: StringFieldUpdateOperationsInput | string
    Status?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type MaquinaEstoqueUncheckedUpdateManyInput = {
    Chassi?: StringFieldUpdateOperationsInput | string
    produtoId?: IntFieldUpdateOperationsInput | number
    filialId?: NullableIntFieldUpdateOperationsInput | number | null
    Status?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type NotasFiscalCabecalhoCreateInput = {
    numeroNota: number
    dataEmissao: Date | string
    valorTotal: Decimal | DecimalJsLike | number | string
    filial?: FilialCreateNestedOneWithoutNotasFiscaisInput
    cliente?: ClienteCreateNestedOneWithoutNotasFiscaisInput
    vendedor?: VendedorCreateNestedOneWithoutNotasFiscaisInput
    itens?: NotaFiscalItemCreateNestedManyWithoutNotaFiscalInput
  }

  export type NotasFiscalCabecalhoUncheckedCreateInput = {
    id?: number
    numeroNota: number
    dataEmissao: Date | string
    valorTotal: Decimal | DecimalJsLike | number | string
    filialId?: number | null
    clienteId?: number | null
    vendedorId?: number | null
    itens?: NotaFiscalItemUncheckedCreateNestedManyWithoutNotaFiscalInput
  }

  export type NotasFiscalCabecalhoUpdateInput = {
    numeroNota?: IntFieldUpdateOperationsInput | number
    dataEmissao?: DateTimeFieldUpdateOperationsInput | Date | string
    valorTotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    filial?: FilialUpdateOneWithoutNotasFiscaisNestedInput
    cliente?: ClienteUpdateOneWithoutNotasFiscaisNestedInput
    vendedor?: VendedorUpdateOneWithoutNotasFiscaisNestedInput
    itens?: NotaFiscalItemUpdateManyWithoutNotaFiscalNestedInput
  }

  export type NotasFiscalCabecalhoUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    numeroNota?: IntFieldUpdateOperationsInput | number
    dataEmissao?: DateTimeFieldUpdateOperationsInput | Date | string
    valorTotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    filialId?: NullableIntFieldUpdateOperationsInput | number | null
    clienteId?: NullableIntFieldUpdateOperationsInput | number | null
    vendedorId?: NullableIntFieldUpdateOperationsInput | number | null
    itens?: NotaFiscalItemUncheckedUpdateManyWithoutNotaFiscalNestedInput
  }

  export type NotasFiscalCabecalhoCreateManyInput = {
    id?: number
    numeroNota: number
    dataEmissao: Date | string
    valorTotal: Decimal | DecimalJsLike | number | string
    filialId?: number | null
    clienteId?: number | null
    vendedorId?: number | null
  }

  export type NotasFiscalCabecalhoUpdateManyMutationInput = {
    numeroNota?: IntFieldUpdateOperationsInput | number
    dataEmissao?: DateTimeFieldUpdateOperationsInput | Date | string
    valorTotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
  }

  export type NotasFiscalCabecalhoUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    numeroNota?: IntFieldUpdateOperationsInput | number
    dataEmissao?: DateTimeFieldUpdateOperationsInput | Date | string
    valorTotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    filialId?: NullableIntFieldUpdateOperationsInput | number | null
    clienteId?: NullableIntFieldUpdateOperationsInput | number | null
    vendedorId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type NotaFiscalItemCreateInput = {
    Quantidade: Decimal | DecimalJsLike | number | string
    valorUnitario: Decimal | DecimalJsLike | number | string
    valorTotalItem: Decimal | DecimalJsLike | number | string
    Maquinas_Estoque?: MaquinaEstoqueCreateNestedOneWithoutNotas_Fiscais_ItensInput
    notaFiscal: NotasFiscalCabecalhoCreateNestedOneWithoutItensInput
    produto: ProdutoCreateNestedOneWithoutNotasFiscaisItensInput
  }

  export type NotaFiscalItemUncheckedCreateInput = {
    id?: number
    notaFiscalId: number
    produtoId: number
    Quantidade: Decimal | DecimalJsLike | number | string
    valorUnitario: Decimal | DecimalJsLike | number | string
    valorTotalItem: Decimal | DecimalJsLike | number | string
    Chassi?: string | null
  }

  export type NotaFiscalItemUpdateInput = {
    Quantidade?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    valorUnitario?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    valorTotalItem?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    Maquinas_Estoque?: MaquinaEstoqueUpdateOneWithoutNotas_Fiscais_ItensNestedInput
    notaFiscal?: NotasFiscalCabecalhoUpdateOneRequiredWithoutItensNestedInput
    produto?: ProdutoUpdateOneRequiredWithoutNotasFiscaisItensNestedInput
  }

  export type NotaFiscalItemUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    notaFiscalId?: IntFieldUpdateOperationsInput | number
    produtoId?: IntFieldUpdateOperationsInput | number
    Quantidade?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    valorUnitario?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    valorTotalItem?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    Chassi?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type NotaFiscalItemCreateManyInput = {
    id?: number
    notaFiscalId: number
    produtoId: number
    Quantidade: Decimal | DecimalJsLike | number | string
    valorUnitario: Decimal | DecimalJsLike | number | string
    valorTotalItem: Decimal | DecimalJsLike | number | string
    Chassi?: string | null
  }

  export type NotaFiscalItemUpdateManyMutationInput = {
    Quantidade?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    valorUnitario?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    valorTotalItem?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
  }

  export type NotaFiscalItemUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    notaFiscalId?: IntFieldUpdateOperationsInput | number
    produtoId?: IntFieldUpdateOperationsInput | number
    Quantidade?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    valorUnitario?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    valorTotalItem?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    Chassi?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type UserCreateInput = {
    email: string
    password: string
    createdAt?: Date | string
  }

  export type UserUncheckedCreateInput = {
    id?: number
    email: string
    password: string
    createdAt?: Date | string
  }

  export type UserUpdateInput = {
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserCreateManyInput = {
    id?: number
    email: string
    password: string
    createdAt?: Date | string
  }

  export type UserUpdateManyMutationInput = {
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RfvParameterSetCreateInput = {
    name: string
    strategy?: $Enums.RfvStrategy
    windowDays?: number
    weights: JsonNullValueInput | InputJsonValue
    ruleRecency: JsonNullValueInput | InputJsonValue
    ruleFrequency: JsonNullValueInput | InputJsonValue
    ruleValue: JsonNullValueInput | InputJsonValue
    effectiveFrom: Date | string
    effectiveTo?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    calculationStrategy?: $Enums.CalculationStrategy
    classRanges?: NullableJsonNullValueInput | InputJsonValue
    conditionalRules?: NullableJsonNullValueInput | InputJsonValue
    filial?: FilialCreateNestedOneWithoutRfvParameterSetsInput
    segments?: RfvSegmentCreateNestedManyWithoutParameterSetInput
  }

  export type RfvParameterSetUncheckedCreateInput = {
    id?: number
    filialId?: number | null
    name: string
    strategy?: $Enums.RfvStrategy
    windowDays?: number
    weights: JsonNullValueInput | InputJsonValue
    ruleRecency: JsonNullValueInput | InputJsonValue
    ruleFrequency: JsonNullValueInput | InputJsonValue
    ruleValue: JsonNullValueInput | InputJsonValue
    effectiveFrom: Date | string
    effectiveTo?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    calculationStrategy?: $Enums.CalculationStrategy
    classRanges?: NullableJsonNullValueInput | InputJsonValue
    conditionalRules?: NullableJsonNullValueInput | InputJsonValue
    segments?: RfvSegmentUncheckedCreateNestedManyWithoutParameterSetInput
  }

  export type RfvParameterSetUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    strategy?: EnumRfvStrategyFieldUpdateOperationsInput | $Enums.RfvStrategy
    windowDays?: IntFieldUpdateOperationsInput | number
    weights?: JsonNullValueInput | InputJsonValue
    ruleRecency?: JsonNullValueInput | InputJsonValue
    ruleFrequency?: JsonNullValueInput | InputJsonValue
    ruleValue?: JsonNullValueInput | InputJsonValue
    effectiveFrom?: DateTimeFieldUpdateOperationsInput | Date | string
    effectiveTo?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    calculationStrategy?: EnumCalculationStrategyFieldUpdateOperationsInput | $Enums.CalculationStrategy
    classRanges?: NullableJsonNullValueInput | InputJsonValue
    conditionalRules?: NullableJsonNullValueInput | InputJsonValue
    filial?: FilialUpdateOneWithoutRfvParameterSetsNestedInput
    segments?: RfvSegmentUpdateManyWithoutParameterSetNestedInput
  }

  export type RfvParameterSetUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    filialId?: NullableIntFieldUpdateOperationsInput | number | null
    name?: StringFieldUpdateOperationsInput | string
    strategy?: EnumRfvStrategyFieldUpdateOperationsInput | $Enums.RfvStrategy
    windowDays?: IntFieldUpdateOperationsInput | number
    weights?: JsonNullValueInput | InputJsonValue
    ruleRecency?: JsonNullValueInput | InputJsonValue
    ruleFrequency?: JsonNullValueInput | InputJsonValue
    ruleValue?: JsonNullValueInput | InputJsonValue
    effectiveFrom?: DateTimeFieldUpdateOperationsInput | Date | string
    effectiveTo?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    calculationStrategy?: EnumCalculationStrategyFieldUpdateOperationsInput | $Enums.CalculationStrategy
    classRanges?: NullableJsonNullValueInput | InputJsonValue
    conditionalRules?: NullableJsonNullValueInput | InputJsonValue
    segments?: RfvSegmentUncheckedUpdateManyWithoutParameterSetNestedInput
  }

  export type RfvParameterSetCreateManyInput = {
    id?: number
    filialId?: number | null
    name: string
    strategy?: $Enums.RfvStrategy
    windowDays?: number
    weights: JsonNullValueInput | InputJsonValue
    ruleRecency: JsonNullValueInput | InputJsonValue
    ruleFrequency: JsonNullValueInput | InputJsonValue
    ruleValue: JsonNullValueInput | InputJsonValue
    effectiveFrom: Date | string
    effectiveTo?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    calculationStrategy?: $Enums.CalculationStrategy
    classRanges?: NullableJsonNullValueInput | InputJsonValue
    conditionalRules?: NullableJsonNullValueInput | InputJsonValue
  }

  export type RfvParameterSetUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    strategy?: EnumRfvStrategyFieldUpdateOperationsInput | $Enums.RfvStrategy
    windowDays?: IntFieldUpdateOperationsInput | number
    weights?: JsonNullValueInput | InputJsonValue
    ruleRecency?: JsonNullValueInput | InputJsonValue
    ruleFrequency?: JsonNullValueInput | InputJsonValue
    ruleValue?: JsonNullValueInput | InputJsonValue
    effectiveFrom?: DateTimeFieldUpdateOperationsInput | Date | string
    effectiveTo?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    calculationStrategy?: EnumCalculationStrategyFieldUpdateOperationsInput | $Enums.CalculationStrategy
    classRanges?: NullableJsonNullValueInput | InputJsonValue
    conditionalRules?: NullableJsonNullValueInput | InputJsonValue
  }

  export type RfvParameterSetUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    filialId?: NullableIntFieldUpdateOperationsInput | number | null
    name?: StringFieldUpdateOperationsInput | string
    strategy?: EnumRfvStrategyFieldUpdateOperationsInput | $Enums.RfvStrategy
    windowDays?: IntFieldUpdateOperationsInput | number
    weights?: JsonNullValueInput | InputJsonValue
    ruleRecency?: JsonNullValueInput | InputJsonValue
    ruleFrequency?: JsonNullValueInput | InputJsonValue
    ruleValue?: JsonNullValueInput | InputJsonValue
    effectiveFrom?: DateTimeFieldUpdateOperationsInput | Date | string
    effectiveTo?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    calculationStrategy?: EnumCalculationStrategyFieldUpdateOperationsInput | $Enums.CalculationStrategy
    classRanges?: NullableJsonNullValueInput | InputJsonValue
    conditionalRules?: NullableJsonNullValueInput | InputJsonValue
  }

  export type RfvSegmentCreateInput = {
    name: string
    rules: JsonNullValueInput | InputJsonValue
    priority?: number
    parameterSet: RfvParameterSetCreateNestedOneWithoutSegmentsInput
  }

  export type RfvSegmentUncheckedCreateInput = {
    id?: number
    parameterSetId: number
    name: string
    rules: JsonNullValueInput | InputJsonValue
    priority?: number
  }

  export type RfvSegmentUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    rules?: JsonNullValueInput | InputJsonValue
    priority?: IntFieldUpdateOperationsInput | number
    parameterSet?: RfvParameterSetUpdateOneRequiredWithoutSegmentsNestedInput
  }

  export type RfvSegmentUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    parameterSetId?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    rules?: JsonNullValueInput | InputJsonValue
    priority?: IntFieldUpdateOperationsInput | number
  }

  export type RfvSegmentCreateManyInput = {
    id?: number
    parameterSetId: number
    name: string
    rules: JsonNullValueInput | InputJsonValue
    priority?: number
  }

  export type RfvSegmentUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    rules?: JsonNullValueInput | InputJsonValue
    priority?: IntFieldUpdateOperationsInput | number
  }

  export type RfvSegmentUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    parameterSetId?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    rules?: JsonNullValueInput | InputJsonValue
    priority?: IntFieldUpdateOperationsInput | number
  }

  export type IntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type StringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | null
    notIn?: string[] | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type BoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type DateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[]
    notIn?: Date[] | string[]
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type FilialListRelationFilter = {
    every?: FilialWhereInput
    some?: FilialWhereInput
    none?: FilialWhereInput
  }

  export type SortOrderInput = {
    sort: SortOrder
    nulls?: NullsOrder
  }

  export type FilialOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type EmpresaCountOrderByAggregateInput = {
    id?: SortOrder
    razaoSocial?: SortOrder
    nomeFantasia?: SortOrder
    cnpjMatriz?: SortOrder
    inscricaoEstadual?: SortOrder
    cidade?: SortOrder
    estado?: SortOrder
    logradouro?: SortOrder
    numero?: SortOrder
    bairro?: SortOrder
    cep?: SortOrder
    telefone?: SortOrder
    email?: SortOrder
    ativo?: SortOrder
    dataCriacao?: SortOrder
    dataAtualizacao?: SortOrder
  }

  export type EmpresaAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type EmpresaMaxOrderByAggregateInput = {
    id?: SortOrder
    razaoSocial?: SortOrder
    nomeFantasia?: SortOrder
    cnpjMatriz?: SortOrder
    inscricaoEstadual?: SortOrder
    cidade?: SortOrder
    estado?: SortOrder
    logradouro?: SortOrder
    numero?: SortOrder
    bairro?: SortOrder
    cep?: SortOrder
    telefone?: SortOrder
    email?: SortOrder
    ativo?: SortOrder
    dataCriacao?: SortOrder
    dataAtualizacao?: SortOrder
  }

  export type EmpresaMinOrderByAggregateInput = {
    id?: SortOrder
    razaoSocial?: SortOrder
    nomeFantasia?: SortOrder
    cnpjMatriz?: SortOrder
    inscricaoEstadual?: SortOrder
    cidade?: SortOrder
    estado?: SortOrder
    logradouro?: SortOrder
    numero?: SortOrder
    bairro?: SortOrder
    cep?: SortOrder
    telefone?: SortOrder
    email?: SortOrder
    ativo?: SortOrder
    dataCriacao?: SortOrder
    dataAtualizacao?: SortOrder
  }

  export type EmpresaSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type IntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type StringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | null
    notIn?: string[] | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type BoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type DateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[]
    notIn?: Date[] | string[]
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type NotasFiscalCabecalhoListRelationFilter = {
    every?: NotasFiscalCabecalhoWhereInput
    some?: NotasFiscalCabecalhoWhereInput
    none?: NotasFiscalCabecalhoWhereInput
  }

  export type NotasFiscalCabecalhoOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ClienteCountOrderByAggregateInput = {
    id?: SortOrder
    nome?: SortOrder
    cpfCnpj?: SortOrder
    cidade?: SortOrder
    estado?: SortOrder
    logradouro?: SortOrder
    numero?: SortOrder
    bairro?: SortOrder
    cep?: SortOrder
    telefone?: SortOrder
  }

  export type ClienteAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type ClienteMaxOrderByAggregateInput = {
    id?: SortOrder
    nome?: SortOrder
    cpfCnpj?: SortOrder
    cidade?: SortOrder
    estado?: SortOrder
    logradouro?: SortOrder
    numero?: SortOrder
    bairro?: SortOrder
    cep?: SortOrder
    telefone?: SortOrder
  }

  export type ClienteMinOrderByAggregateInput = {
    id?: SortOrder
    nome?: SortOrder
    cpfCnpj?: SortOrder
    cidade?: SortOrder
    estado?: SortOrder
    logradouro?: SortOrder
    numero?: SortOrder
    bairro?: SortOrder
    cep?: SortOrder
    telefone?: SortOrder
  }

  export type ClienteSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type EmpresaRelationFilter = {
    is?: EmpresaWhereInput
    isNot?: EmpresaWhereInput
  }

  export type VendedorListRelationFilter = {
    every?: VendedorWhereInput
    some?: VendedorWhereInput
    none?: VendedorWhereInput
  }

  export type RfvParameterSetListRelationFilter = {
    every?: RfvParameterSetWhereInput
    some?: RfvParameterSetWhereInput
    none?: RfvParameterSetWhereInput
  }

  export type MaquinaEstoqueListRelationFilter = {
    every?: MaquinaEstoqueWhereInput
    some?: MaquinaEstoqueWhereInput
    none?: MaquinaEstoqueWhereInput
  }

  export type VendedorOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type RfvParameterSetOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type MaquinaEstoqueOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type FilialCountOrderByAggregateInput = {
    id?: SortOrder
    empresaId?: SortOrder
    nome?: SortOrder
    cnpj?: SortOrder
    cidade?: SortOrder
    estado?: SortOrder
  }

  export type FilialAvgOrderByAggregateInput = {
    id?: SortOrder
    empresaId?: SortOrder
  }

  export type FilialMaxOrderByAggregateInput = {
    id?: SortOrder
    empresaId?: SortOrder
    nome?: SortOrder
    cnpj?: SortOrder
    cidade?: SortOrder
    estado?: SortOrder
  }

  export type FilialMinOrderByAggregateInput = {
    id?: SortOrder
    empresaId?: SortOrder
    nome?: SortOrder
    cnpj?: SortOrder
    cidade?: SortOrder
    estado?: SortOrder
  }

  export type FilialSumOrderByAggregateInput = {
    id?: SortOrder
    empresaId?: SortOrder
  }

  export type IntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type FilialNullableRelationFilter = {
    is?: FilialWhereInput | null
    isNot?: FilialWhereInput | null
  }

  export type VendedorCountOrderByAggregateInput = {
    id?: SortOrder
    nome?: SortOrder
    cpf?: SortOrder
    filialId?: SortOrder
  }

  export type VendedorAvgOrderByAggregateInput = {
    id?: SortOrder
    filialId?: SortOrder
  }

  export type VendedorMaxOrderByAggregateInput = {
    id?: SortOrder
    nome?: SortOrder
    cpf?: SortOrder
    filialId?: SortOrder
  }

  export type VendedorMinOrderByAggregateInput = {
    id?: SortOrder
    nome?: SortOrder
    cpf?: SortOrder
    filialId?: SortOrder
  }

  export type VendedorSumOrderByAggregateInput = {
    id?: SortOrder
    filialId?: SortOrder
  }

  export type IntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type DecimalFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[]
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[]
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
  }

  export type NotaFiscalItemListRelationFilter = {
    every?: NotaFiscalItemWhereInput
    some?: NotaFiscalItemWhereInput
    none?: NotaFiscalItemWhereInput
  }

  export type NotaFiscalItemOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ProdutoCountOrderByAggregateInput = {
    id?: SortOrder
    descricao?: SortOrder
    tipo?: SortOrder
    preco?: SortOrder
  }

  export type ProdutoAvgOrderByAggregateInput = {
    id?: SortOrder
    preco?: SortOrder
  }

  export type ProdutoMaxOrderByAggregateInput = {
    id?: SortOrder
    descricao?: SortOrder
    tipo?: SortOrder
    preco?: SortOrder
  }

  export type ProdutoMinOrderByAggregateInput = {
    id?: SortOrder
    descricao?: SortOrder
    tipo?: SortOrder
    preco?: SortOrder
  }

  export type ProdutoSumOrderByAggregateInput = {
    id?: SortOrder
    preco?: SortOrder
  }

  export type DecimalWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[]
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[]
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalWithAggregatesFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedDecimalFilter<$PrismaModel>
    _sum?: NestedDecimalFilter<$PrismaModel>
    _min?: NestedDecimalFilter<$PrismaModel>
    _max?: NestedDecimalFilter<$PrismaModel>
  }

  export type ProdutoRelationFilter = {
    is?: ProdutoWhereInput
    isNot?: ProdutoWhereInput
  }

  export type MaquinaEstoqueCountOrderByAggregateInput = {
    Chassi?: SortOrder
    produtoId?: SortOrder
    filialId?: SortOrder
    Status?: SortOrder
  }

  export type MaquinaEstoqueAvgOrderByAggregateInput = {
    produtoId?: SortOrder
    filialId?: SortOrder
  }

  export type MaquinaEstoqueMaxOrderByAggregateInput = {
    Chassi?: SortOrder
    produtoId?: SortOrder
    filialId?: SortOrder
    Status?: SortOrder
  }

  export type MaquinaEstoqueMinOrderByAggregateInput = {
    Chassi?: SortOrder
    produtoId?: SortOrder
    filialId?: SortOrder
    Status?: SortOrder
  }

  export type MaquinaEstoqueSumOrderByAggregateInput = {
    produtoId?: SortOrder
    filialId?: SortOrder
  }

  export type ClienteNullableRelationFilter = {
    is?: ClienteWhereInput | null
    isNot?: ClienteWhereInput | null
  }

  export type VendedorNullableRelationFilter = {
    is?: VendedorWhereInput | null
    isNot?: VendedorWhereInput | null
  }

  export type NotasFiscalCabecalhoNumeroNotaFilialIdCompoundUniqueInput = {
    numeroNota: number
    filialId: number
  }

  export type NotasFiscalCabecalhoCountOrderByAggregateInput = {
    id?: SortOrder
    numeroNota?: SortOrder
    dataEmissao?: SortOrder
    valorTotal?: SortOrder
    filialId?: SortOrder
    clienteId?: SortOrder
    vendedorId?: SortOrder
  }

  export type NotasFiscalCabecalhoAvgOrderByAggregateInput = {
    id?: SortOrder
    numeroNota?: SortOrder
    valorTotal?: SortOrder
    filialId?: SortOrder
    clienteId?: SortOrder
    vendedorId?: SortOrder
  }

  export type NotasFiscalCabecalhoMaxOrderByAggregateInput = {
    id?: SortOrder
    numeroNota?: SortOrder
    dataEmissao?: SortOrder
    valorTotal?: SortOrder
    filialId?: SortOrder
    clienteId?: SortOrder
    vendedorId?: SortOrder
  }

  export type NotasFiscalCabecalhoMinOrderByAggregateInput = {
    id?: SortOrder
    numeroNota?: SortOrder
    dataEmissao?: SortOrder
    valorTotal?: SortOrder
    filialId?: SortOrder
    clienteId?: SortOrder
    vendedorId?: SortOrder
  }

  export type NotasFiscalCabecalhoSumOrderByAggregateInput = {
    id?: SortOrder
    numeroNota?: SortOrder
    valorTotal?: SortOrder
    filialId?: SortOrder
    clienteId?: SortOrder
    vendedorId?: SortOrder
  }

  export type MaquinaEstoqueNullableRelationFilter = {
    is?: MaquinaEstoqueWhereInput | null
    isNot?: MaquinaEstoqueWhereInput | null
  }

  export type NotasFiscalCabecalhoRelationFilter = {
    is?: NotasFiscalCabecalhoWhereInput
    isNot?: NotasFiscalCabecalhoWhereInput
  }

  export type NotaFiscalItemCountOrderByAggregateInput = {
    id?: SortOrder
    notaFiscalId?: SortOrder
    produtoId?: SortOrder
    Quantidade?: SortOrder
    valorUnitario?: SortOrder
    valorTotalItem?: SortOrder
    Chassi?: SortOrder
  }

  export type NotaFiscalItemAvgOrderByAggregateInput = {
    id?: SortOrder
    notaFiscalId?: SortOrder
    produtoId?: SortOrder
    Quantidade?: SortOrder
    valorUnitario?: SortOrder
    valorTotalItem?: SortOrder
  }

  export type NotaFiscalItemMaxOrderByAggregateInput = {
    id?: SortOrder
    notaFiscalId?: SortOrder
    produtoId?: SortOrder
    Quantidade?: SortOrder
    valorUnitario?: SortOrder
    valorTotalItem?: SortOrder
    Chassi?: SortOrder
  }

  export type NotaFiscalItemMinOrderByAggregateInput = {
    id?: SortOrder
    notaFiscalId?: SortOrder
    produtoId?: SortOrder
    Quantidade?: SortOrder
    valorUnitario?: SortOrder
    valorTotalItem?: SortOrder
    Chassi?: SortOrder
  }

  export type NotaFiscalItemSumOrderByAggregateInput = {
    id?: SortOrder
    notaFiscalId?: SortOrder
    produtoId?: SortOrder
    Quantidade?: SortOrder
    valorUnitario?: SortOrder
    valorTotalItem?: SortOrder
  }

  export type UserCountOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    password?: SortOrder
    createdAt?: SortOrder
  }

  export type UserAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type UserMaxOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    password?: SortOrder
    createdAt?: SortOrder
  }

  export type UserMinOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    password?: SortOrder
    createdAt?: SortOrder
  }

  export type UserSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type EnumRfvStrategyFilter<$PrismaModel = never> = {
    equals?: $Enums.RfvStrategy | EnumRfvStrategyFieldRefInput<$PrismaModel>
    in?: $Enums.RfvStrategy[]
    notIn?: $Enums.RfvStrategy[]
    not?: NestedEnumRfvStrategyFilter<$PrismaModel> | $Enums.RfvStrategy
  }
  export type JsonFilter<$PrismaModel = never> = 
    | PatchUndefined<
        Either<Required<JsonFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonFilterBase<$PrismaModel>>, 'path'>>

  export type JsonFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue
    lte?: InputJsonValue
    gt?: InputJsonValue
    gte?: InputJsonValue
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type DateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | null
    notIn?: Date[] | string[] | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type EnumCalculationStrategyFilter<$PrismaModel = never> = {
    equals?: $Enums.CalculationStrategy | EnumCalculationStrategyFieldRefInput<$PrismaModel>
    in?: $Enums.CalculationStrategy[]
    notIn?: $Enums.CalculationStrategy[]
    not?: NestedEnumCalculationStrategyFilter<$PrismaModel> | $Enums.CalculationStrategy
  }
  export type JsonNullableFilter<$PrismaModel = never> = 
    | PatchUndefined<
        Either<Required<JsonNullableFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonNullableFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonNullableFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonNullableFilterBase<$PrismaModel>>, 'path'>>

  export type JsonNullableFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue
    lte?: InputJsonValue
    gt?: InputJsonValue
    gte?: InputJsonValue
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type RfvSegmentListRelationFilter = {
    every?: RfvSegmentWhereInput
    some?: RfvSegmentWhereInput
    none?: RfvSegmentWhereInput
  }

  export type RfvSegmentOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type RfvParameterSetCountOrderByAggregateInput = {
    id?: SortOrder
    filialId?: SortOrder
    name?: SortOrder
    strategy?: SortOrder
    windowDays?: SortOrder
    weights?: SortOrder
    ruleRecency?: SortOrder
    ruleFrequency?: SortOrder
    ruleValue?: SortOrder
    effectiveFrom?: SortOrder
    effectiveTo?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    calculationStrategy?: SortOrder
    classRanges?: SortOrder
    conditionalRules?: SortOrder
  }

  export type RfvParameterSetAvgOrderByAggregateInput = {
    id?: SortOrder
    filialId?: SortOrder
    windowDays?: SortOrder
  }

  export type RfvParameterSetMaxOrderByAggregateInput = {
    id?: SortOrder
    filialId?: SortOrder
    name?: SortOrder
    strategy?: SortOrder
    windowDays?: SortOrder
    effectiveFrom?: SortOrder
    effectiveTo?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    calculationStrategy?: SortOrder
  }

  export type RfvParameterSetMinOrderByAggregateInput = {
    id?: SortOrder
    filialId?: SortOrder
    name?: SortOrder
    strategy?: SortOrder
    windowDays?: SortOrder
    effectiveFrom?: SortOrder
    effectiveTo?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    calculationStrategy?: SortOrder
  }

  export type RfvParameterSetSumOrderByAggregateInput = {
    id?: SortOrder
    filialId?: SortOrder
    windowDays?: SortOrder
  }

  export type EnumRfvStrategyWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.RfvStrategy | EnumRfvStrategyFieldRefInput<$PrismaModel>
    in?: $Enums.RfvStrategy[]
    notIn?: $Enums.RfvStrategy[]
    not?: NestedEnumRfvStrategyWithAggregatesFilter<$PrismaModel> | $Enums.RfvStrategy
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumRfvStrategyFilter<$PrismaModel>
    _max?: NestedEnumRfvStrategyFilter<$PrismaModel>
  }
  export type JsonWithAggregatesFilter<$PrismaModel = never> = 
    | PatchUndefined<
        Either<Required<JsonWithAggregatesFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonWithAggregatesFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonWithAggregatesFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonWithAggregatesFilterBase<$PrismaModel>>, 'path'>>

  export type JsonWithAggregatesFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue
    lte?: InputJsonValue
    gt?: InputJsonValue
    gte?: InputJsonValue
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedJsonFilter<$PrismaModel>
    _max?: NestedJsonFilter<$PrismaModel>
  }

  export type DateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | null
    notIn?: Date[] | string[] | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type EnumCalculationStrategyWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.CalculationStrategy | EnumCalculationStrategyFieldRefInput<$PrismaModel>
    in?: $Enums.CalculationStrategy[]
    notIn?: $Enums.CalculationStrategy[]
    not?: NestedEnumCalculationStrategyWithAggregatesFilter<$PrismaModel> | $Enums.CalculationStrategy
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumCalculationStrategyFilter<$PrismaModel>
    _max?: NestedEnumCalculationStrategyFilter<$PrismaModel>
  }
  export type JsonNullableWithAggregatesFilter<$PrismaModel = never> = 
    | PatchUndefined<
        Either<Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, 'path'>>

  export type JsonNullableWithAggregatesFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue
    lte?: InputJsonValue
    gt?: InputJsonValue
    gte?: InputJsonValue
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedJsonNullableFilter<$PrismaModel>
    _max?: NestedJsonNullableFilter<$PrismaModel>
  }

  export type RfvParameterSetRelationFilter = {
    is?: RfvParameterSetWhereInput
    isNot?: RfvParameterSetWhereInput
  }

  export type RfvSegmentCountOrderByAggregateInput = {
    id?: SortOrder
    parameterSetId?: SortOrder
    name?: SortOrder
    rules?: SortOrder
    priority?: SortOrder
  }

  export type RfvSegmentAvgOrderByAggregateInput = {
    id?: SortOrder
    parameterSetId?: SortOrder
    priority?: SortOrder
  }

  export type RfvSegmentMaxOrderByAggregateInput = {
    id?: SortOrder
    parameterSetId?: SortOrder
    name?: SortOrder
    priority?: SortOrder
  }

  export type RfvSegmentMinOrderByAggregateInput = {
    id?: SortOrder
    parameterSetId?: SortOrder
    name?: SortOrder
    priority?: SortOrder
  }

  export type RfvSegmentSumOrderByAggregateInput = {
    id?: SortOrder
    parameterSetId?: SortOrder
    priority?: SortOrder
  }

  export type FilialCreateNestedManyWithoutEmpresaInput = {
    create?: XOR<FilialCreateWithoutEmpresaInput, FilialUncheckedCreateWithoutEmpresaInput> | FilialCreateWithoutEmpresaInput[] | FilialUncheckedCreateWithoutEmpresaInput[]
    connectOrCreate?: FilialCreateOrConnectWithoutEmpresaInput | FilialCreateOrConnectWithoutEmpresaInput[]
    createMany?: FilialCreateManyEmpresaInputEnvelope
    connect?: FilialWhereUniqueInput | FilialWhereUniqueInput[]
  }

  export type FilialUncheckedCreateNestedManyWithoutEmpresaInput = {
    create?: XOR<FilialCreateWithoutEmpresaInput, FilialUncheckedCreateWithoutEmpresaInput> | FilialCreateWithoutEmpresaInput[] | FilialUncheckedCreateWithoutEmpresaInput[]
    connectOrCreate?: FilialCreateOrConnectWithoutEmpresaInput | FilialCreateOrConnectWithoutEmpresaInput[]
    createMany?: FilialCreateManyEmpresaInputEnvelope
    connect?: FilialWhereUniqueInput | FilialWhereUniqueInput[]
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type BoolFieldUpdateOperationsInput = {
    set?: boolean
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type FilialUpdateManyWithoutEmpresaNestedInput = {
    create?: XOR<FilialCreateWithoutEmpresaInput, FilialUncheckedCreateWithoutEmpresaInput> | FilialCreateWithoutEmpresaInput[] | FilialUncheckedCreateWithoutEmpresaInput[]
    connectOrCreate?: FilialCreateOrConnectWithoutEmpresaInput | FilialCreateOrConnectWithoutEmpresaInput[]
    upsert?: FilialUpsertWithWhereUniqueWithoutEmpresaInput | FilialUpsertWithWhereUniqueWithoutEmpresaInput[]
    createMany?: FilialCreateManyEmpresaInputEnvelope
    set?: FilialWhereUniqueInput | FilialWhereUniqueInput[]
    disconnect?: FilialWhereUniqueInput | FilialWhereUniqueInput[]
    delete?: FilialWhereUniqueInput | FilialWhereUniqueInput[]
    connect?: FilialWhereUniqueInput | FilialWhereUniqueInput[]
    update?: FilialUpdateWithWhereUniqueWithoutEmpresaInput | FilialUpdateWithWhereUniqueWithoutEmpresaInput[]
    updateMany?: FilialUpdateManyWithWhereWithoutEmpresaInput | FilialUpdateManyWithWhereWithoutEmpresaInput[]
    deleteMany?: FilialScalarWhereInput | FilialScalarWhereInput[]
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type FilialUncheckedUpdateManyWithoutEmpresaNestedInput = {
    create?: XOR<FilialCreateWithoutEmpresaInput, FilialUncheckedCreateWithoutEmpresaInput> | FilialCreateWithoutEmpresaInput[] | FilialUncheckedCreateWithoutEmpresaInput[]
    connectOrCreate?: FilialCreateOrConnectWithoutEmpresaInput | FilialCreateOrConnectWithoutEmpresaInput[]
    upsert?: FilialUpsertWithWhereUniqueWithoutEmpresaInput | FilialUpsertWithWhereUniqueWithoutEmpresaInput[]
    createMany?: FilialCreateManyEmpresaInputEnvelope
    set?: FilialWhereUniqueInput | FilialWhereUniqueInput[]
    disconnect?: FilialWhereUniqueInput | FilialWhereUniqueInput[]
    delete?: FilialWhereUniqueInput | FilialWhereUniqueInput[]
    connect?: FilialWhereUniqueInput | FilialWhereUniqueInput[]
    update?: FilialUpdateWithWhereUniqueWithoutEmpresaInput | FilialUpdateWithWhereUniqueWithoutEmpresaInput[]
    updateMany?: FilialUpdateManyWithWhereWithoutEmpresaInput | FilialUpdateManyWithWhereWithoutEmpresaInput[]
    deleteMany?: FilialScalarWhereInput | FilialScalarWhereInput[]
  }

  export type NotasFiscalCabecalhoCreateNestedManyWithoutClienteInput = {
    create?: XOR<NotasFiscalCabecalhoCreateWithoutClienteInput, NotasFiscalCabecalhoUncheckedCreateWithoutClienteInput> | NotasFiscalCabecalhoCreateWithoutClienteInput[] | NotasFiscalCabecalhoUncheckedCreateWithoutClienteInput[]
    connectOrCreate?: NotasFiscalCabecalhoCreateOrConnectWithoutClienteInput | NotasFiscalCabecalhoCreateOrConnectWithoutClienteInput[]
    createMany?: NotasFiscalCabecalhoCreateManyClienteInputEnvelope
    connect?: NotasFiscalCabecalhoWhereUniqueInput | NotasFiscalCabecalhoWhereUniqueInput[]
  }

  export type NotasFiscalCabecalhoUncheckedCreateNestedManyWithoutClienteInput = {
    create?: XOR<NotasFiscalCabecalhoCreateWithoutClienteInput, NotasFiscalCabecalhoUncheckedCreateWithoutClienteInput> | NotasFiscalCabecalhoCreateWithoutClienteInput[] | NotasFiscalCabecalhoUncheckedCreateWithoutClienteInput[]
    connectOrCreate?: NotasFiscalCabecalhoCreateOrConnectWithoutClienteInput | NotasFiscalCabecalhoCreateOrConnectWithoutClienteInput[]
    createMany?: NotasFiscalCabecalhoCreateManyClienteInputEnvelope
    connect?: NotasFiscalCabecalhoWhereUniqueInput | NotasFiscalCabecalhoWhereUniqueInput[]
  }

  export type NotasFiscalCabecalhoUpdateManyWithoutClienteNestedInput = {
    create?: XOR<NotasFiscalCabecalhoCreateWithoutClienteInput, NotasFiscalCabecalhoUncheckedCreateWithoutClienteInput> | NotasFiscalCabecalhoCreateWithoutClienteInput[] | NotasFiscalCabecalhoUncheckedCreateWithoutClienteInput[]
    connectOrCreate?: NotasFiscalCabecalhoCreateOrConnectWithoutClienteInput | NotasFiscalCabecalhoCreateOrConnectWithoutClienteInput[]
    upsert?: NotasFiscalCabecalhoUpsertWithWhereUniqueWithoutClienteInput | NotasFiscalCabecalhoUpsertWithWhereUniqueWithoutClienteInput[]
    createMany?: NotasFiscalCabecalhoCreateManyClienteInputEnvelope
    set?: NotasFiscalCabecalhoWhereUniqueInput | NotasFiscalCabecalhoWhereUniqueInput[]
    disconnect?: NotasFiscalCabecalhoWhereUniqueInput | NotasFiscalCabecalhoWhereUniqueInput[]
    delete?: NotasFiscalCabecalhoWhereUniqueInput | NotasFiscalCabecalhoWhereUniqueInput[]
    connect?: NotasFiscalCabecalhoWhereUniqueInput | NotasFiscalCabecalhoWhereUniqueInput[]
    update?: NotasFiscalCabecalhoUpdateWithWhereUniqueWithoutClienteInput | NotasFiscalCabecalhoUpdateWithWhereUniqueWithoutClienteInput[]
    updateMany?: NotasFiscalCabecalhoUpdateManyWithWhereWithoutClienteInput | NotasFiscalCabecalhoUpdateManyWithWhereWithoutClienteInput[]
    deleteMany?: NotasFiscalCabecalhoScalarWhereInput | NotasFiscalCabecalhoScalarWhereInput[]
  }

  export type NotasFiscalCabecalhoUncheckedUpdateManyWithoutClienteNestedInput = {
    create?: XOR<NotasFiscalCabecalhoCreateWithoutClienteInput, NotasFiscalCabecalhoUncheckedCreateWithoutClienteInput> | NotasFiscalCabecalhoCreateWithoutClienteInput[] | NotasFiscalCabecalhoUncheckedCreateWithoutClienteInput[]
    connectOrCreate?: NotasFiscalCabecalhoCreateOrConnectWithoutClienteInput | NotasFiscalCabecalhoCreateOrConnectWithoutClienteInput[]
    upsert?: NotasFiscalCabecalhoUpsertWithWhereUniqueWithoutClienteInput | NotasFiscalCabecalhoUpsertWithWhereUniqueWithoutClienteInput[]
    createMany?: NotasFiscalCabecalhoCreateManyClienteInputEnvelope
    set?: NotasFiscalCabecalhoWhereUniqueInput | NotasFiscalCabecalhoWhereUniqueInput[]
    disconnect?: NotasFiscalCabecalhoWhereUniqueInput | NotasFiscalCabecalhoWhereUniqueInput[]
    delete?: NotasFiscalCabecalhoWhereUniqueInput | NotasFiscalCabecalhoWhereUniqueInput[]
    connect?: NotasFiscalCabecalhoWhereUniqueInput | NotasFiscalCabecalhoWhereUniqueInput[]
    update?: NotasFiscalCabecalhoUpdateWithWhereUniqueWithoutClienteInput | NotasFiscalCabecalhoUpdateWithWhereUniqueWithoutClienteInput[]
    updateMany?: NotasFiscalCabecalhoUpdateManyWithWhereWithoutClienteInput | NotasFiscalCabecalhoUpdateManyWithWhereWithoutClienteInput[]
    deleteMany?: NotasFiscalCabecalhoScalarWhereInput | NotasFiscalCabecalhoScalarWhereInput[]
  }

  export type EmpresaCreateNestedOneWithoutFiliaisInput = {
    create?: XOR<EmpresaCreateWithoutFiliaisInput, EmpresaUncheckedCreateWithoutFiliaisInput>
    connectOrCreate?: EmpresaCreateOrConnectWithoutFiliaisInput
    connect?: EmpresaWhereUniqueInput
  }

  export type NotasFiscalCabecalhoCreateNestedManyWithoutFilialInput = {
    create?: XOR<NotasFiscalCabecalhoCreateWithoutFilialInput, NotasFiscalCabecalhoUncheckedCreateWithoutFilialInput> | NotasFiscalCabecalhoCreateWithoutFilialInput[] | NotasFiscalCabecalhoUncheckedCreateWithoutFilialInput[]
    connectOrCreate?: NotasFiscalCabecalhoCreateOrConnectWithoutFilialInput | NotasFiscalCabecalhoCreateOrConnectWithoutFilialInput[]
    createMany?: NotasFiscalCabecalhoCreateManyFilialInputEnvelope
    connect?: NotasFiscalCabecalhoWhereUniqueInput | NotasFiscalCabecalhoWhereUniqueInput[]
  }

  export type VendedorCreateNestedManyWithoutFilialInput = {
    create?: XOR<VendedorCreateWithoutFilialInput, VendedorUncheckedCreateWithoutFilialInput> | VendedorCreateWithoutFilialInput[] | VendedorUncheckedCreateWithoutFilialInput[]
    connectOrCreate?: VendedorCreateOrConnectWithoutFilialInput | VendedorCreateOrConnectWithoutFilialInput[]
    createMany?: VendedorCreateManyFilialInputEnvelope
    connect?: VendedorWhereUniqueInput | VendedorWhereUniqueInput[]
  }

  export type RfvParameterSetCreateNestedManyWithoutFilialInput = {
    create?: XOR<RfvParameterSetCreateWithoutFilialInput, RfvParameterSetUncheckedCreateWithoutFilialInput> | RfvParameterSetCreateWithoutFilialInput[] | RfvParameterSetUncheckedCreateWithoutFilialInput[]
    connectOrCreate?: RfvParameterSetCreateOrConnectWithoutFilialInput | RfvParameterSetCreateOrConnectWithoutFilialInput[]
    createMany?: RfvParameterSetCreateManyFilialInputEnvelope
    connect?: RfvParameterSetWhereUniqueInput | RfvParameterSetWhereUniqueInput[]
  }

  export type MaquinaEstoqueCreateNestedManyWithoutFilialInput = {
    create?: XOR<MaquinaEstoqueCreateWithoutFilialInput, MaquinaEstoqueUncheckedCreateWithoutFilialInput> | MaquinaEstoqueCreateWithoutFilialInput[] | MaquinaEstoqueUncheckedCreateWithoutFilialInput[]
    connectOrCreate?: MaquinaEstoqueCreateOrConnectWithoutFilialInput | MaquinaEstoqueCreateOrConnectWithoutFilialInput[]
    createMany?: MaquinaEstoqueCreateManyFilialInputEnvelope
    connect?: MaquinaEstoqueWhereUniqueInput | MaquinaEstoqueWhereUniqueInput[]
  }

  export type NotasFiscalCabecalhoUncheckedCreateNestedManyWithoutFilialInput = {
    create?: XOR<NotasFiscalCabecalhoCreateWithoutFilialInput, NotasFiscalCabecalhoUncheckedCreateWithoutFilialInput> | NotasFiscalCabecalhoCreateWithoutFilialInput[] | NotasFiscalCabecalhoUncheckedCreateWithoutFilialInput[]
    connectOrCreate?: NotasFiscalCabecalhoCreateOrConnectWithoutFilialInput | NotasFiscalCabecalhoCreateOrConnectWithoutFilialInput[]
    createMany?: NotasFiscalCabecalhoCreateManyFilialInputEnvelope
    connect?: NotasFiscalCabecalhoWhereUniqueInput | NotasFiscalCabecalhoWhereUniqueInput[]
  }

  export type VendedorUncheckedCreateNestedManyWithoutFilialInput = {
    create?: XOR<VendedorCreateWithoutFilialInput, VendedorUncheckedCreateWithoutFilialInput> | VendedorCreateWithoutFilialInput[] | VendedorUncheckedCreateWithoutFilialInput[]
    connectOrCreate?: VendedorCreateOrConnectWithoutFilialInput | VendedorCreateOrConnectWithoutFilialInput[]
    createMany?: VendedorCreateManyFilialInputEnvelope
    connect?: VendedorWhereUniqueInput | VendedorWhereUniqueInput[]
  }

  export type RfvParameterSetUncheckedCreateNestedManyWithoutFilialInput = {
    create?: XOR<RfvParameterSetCreateWithoutFilialInput, RfvParameterSetUncheckedCreateWithoutFilialInput> | RfvParameterSetCreateWithoutFilialInput[] | RfvParameterSetUncheckedCreateWithoutFilialInput[]
    connectOrCreate?: RfvParameterSetCreateOrConnectWithoutFilialInput | RfvParameterSetCreateOrConnectWithoutFilialInput[]
    createMany?: RfvParameterSetCreateManyFilialInputEnvelope
    connect?: RfvParameterSetWhereUniqueInput | RfvParameterSetWhereUniqueInput[]
  }

  export type MaquinaEstoqueUncheckedCreateNestedManyWithoutFilialInput = {
    create?: XOR<MaquinaEstoqueCreateWithoutFilialInput, MaquinaEstoqueUncheckedCreateWithoutFilialInput> | MaquinaEstoqueCreateWithoutFilialInput[] | MaquinaEstoqueUncheckedCreateWithoutFilialInput[]
    connectOrCreate?: MaquinaEstoqueCreateOrConnectWithoutFilialInput | MaquinaEstoqueCreateOrConnectWithoutFilialInput[]
    createMany?: MaquinaEstoqueCreateManyFilialInputEnvelope
    connect?: MaquinaEstoqueWhereUniqueInput | MaquinaEstoqueWhereUniqueInput[]
  }

  export type EmpresaUpdateOneRequiredWithoutFiliaisNestedInput = {
    create?: XOR<EmpresaCreateWithoutFiliaisInput, EmpresaUncheckedCreateWithoutFiliaisInput>
    connectOrCreate?: EmpresaCreateOrConnectWithoutFiliaisInput
    upsert?: EmpresaUpsertWithoutFiliaisInput
    connect?: EmpresaWhereUniqueInput
    update?: XOR<XOR<EmpresaUpdateToOneWithWhereWithoutFiliaisInput, EmpresaUpdateWithoutFiliaisInput>, EmpresaUncheckedUpdateWithoutFiliaisInput>
  }

  export type NotasFiscalCabecalhoUpdateManyWithoutFilialNestedInput = {
    create?: XOR<NotasFiscalCabecalhoCreateWithoutFilialInput, NotasFiscalCabecalhoUncheckedCreateWithoutFilialInput> | NotasFiscalCabecalhoCreateWithoutFilialInput[] | NotasFiscalCabecalhoUncheckedCreateWithoutFilialInput[]
    connectOrCreate?: NotasFiscalCabecalhoCreateOrConnectWithoutFilialInput | NotasFiscalCabecalhoCreateOrConnectWithoutFilialInput[]
    upsert?: NotasFiscalCabecalhoUpsertWithWhereUniqueWithoutFilialInput | NotasFiscalCabecalhoUpsertWithWhereUniqueWithoutFilialInput[]
    createMany?: NotasFiscalCabecalhoCreateManyFilialInputEnvelope
    set?: NotasFiscalCabecalhoWhereUniqueInput | NotasFiscalCabecalhoWhereUniqueInput[]
    disconnect?: NotasFiscalCabecalhoWhereUniqueInput | NotasFiscalCabecalhoWhereUniqueInput[]
    delete?: NotasFiscalCabecalhoWhereUniqueInput | NotasFiscalCabecalhoWhereUniqueInput[]
    connect?: NotasFiscalCabecalhoWhereUniqueInput | NotasFiscalCabecalhoWhereUniqueInput[]
    update?: NotasFiscalCabecalhoUpdateWithWhereUniqueWithoutFilialInput | NotasFiscalCabecalhoUpdateWithWhereUniqueWithoutFilialInput[]
    updateMany?: NotasFiscalCabecalhoUpdateManyWithWhereWithoutFilialInput | NotasFiscalCabecalhoUpdateManyWithWhereWithoutFilialInput[]
    deleteMany?: NotasFiscalCabecalhoScalarWhereInput | NotasFiscalCabecalhoScalarWhereInput[]
  }

  export type VendedorUpdateManyWithoutFilialNestedInput = {
    create?: XOR<VendedorCreateWithoutFilialInput, VendedorUncheckedCreateWithoutFilialInput> | VendedorCreateWithoutFilialInput[] | VendedorUncheckedCreateWithoutFilialInput[]
    connectOrCreate?: VendedorCreateOrConnectWithoutFilialInput | VendedorCreateOrConnectWithoutFilialInput[]
    upsert?: VendedorUpsertWithWhereUniqueWithoutFilialInput | VendedorUpsertWithWhereUniqueWithoutFilialInput[]
    createMany?: VendedorCreateManyFilialInputEnvelope
    set?: VendedorWhereUniqueInput | VendedorWhereUniqueInput[]
    disconnect?: VendedorWhereUniqueInput | VendedorWhereUniqueInput[]
    delete?: VendedorWhereUniqueInput | VendedorWhereUniqueInput[]
    connect?: VendedorWhereUniqueInput | VendedorWhereUniqueInput[]
    update?: VendedorUpdateWithWhereUniqueWithoutFilialInput | VendedorUpdateWithWhereUniqueWithoutFilialInput[]
    updateMany?: VendedorUpdateManyWithWhereWithoutFilialInput | VendedorUpdateManyWithWhereWithoutFilialInput[]
    deleteMany?: VendedorScalarWhereInput | VendedorScalarWhereInput[]
  }

  export type RfvParameterSetUpdateManyWithoutFilialNestedInput = {
    create?: XOR<RfvParameterSetCreateWithoutFilialInput, RfvParameterSetUncheckedCreateWithoutFilialInput> | RfvParameterSetCreateWithoutFilialInput[] | RfvParameterSetUncheckedCreateWithoutFilialInput[]
    connectOrCreate?: RfvParameterSetCreateOrConnectWithoutFilialInput | RfvParameterSetCreateOrConnectWithoutFilialInput[]
    upsert?: RfvParameterSetUpsertWithWhereUniqueWithoutFilialInput | RfvParameterSetUpsertWithWhereUniqueWithoutFilialInput[]
    createMany?: RfvParameterSetCreateManyFilialInputEnvelope
    set?: RfvParameterSetWhereUniqueInput | RfvParameterSetWhereUniqueInput[]
    disconnect?: RfvParameterSetWhereUniqueInput | RfvParameterSetWhereUniqueInput[]
    delete?: RfvParameterSetWhereUniqueInput | RfvParameterSetWhereUniqueInput[]
    connect?: RfvParameterSetWhereUniqueInput | RfvParameterSetWhereUniqueInput[]
    update?: RfvParameterSetUpdateWithWhereUniqueWithoutFilialInput | RfvParameterSetUpdateWithWhereUniqueWithoutFilialInput[]
    updateMany?: RfvParameterSetUpdateManyWithWhereWithoutFilialInput | RfvParameterSetUpdateManyWithWhereWithoutFilialInput[]
    deleteMany?: RfvParameterSetScalarWhereInput | RfvParameterSetScalarWhereInput[]
  }

  export type MaquinaEstoqueUpdateManyWithoutFilialNestedInput = {
    create?: XOR<MaquinaEstoqueCreateWithoutFilialInput, MaquinaEstoqueUncheckedCreateWithoutFilialInput> | MaquinaEstoqueCreateWithoutFilialInput[] | MaquinaEstoqueUncheckedCreateWithoutFilialInput[]
    connectOrCreate?: MaquinaEstoqueCreateOrConnectWithoutFilialInput | MaquinaEstoqueCreateOrConnectWithoutFilialInput[]
    upsert?: MaquinaEstoqueUpsertWithWhereUniqueWithoutFilialInput | MaquinaEstoqueUpsertWithWhereUniqueWithoutFilialInput[]
    createMany?: MaquinaEstoqueCreateManyFilialInputEnvelope
    set?: MaquinaEstoqueWhereUniqueInput | MaquinaEstoqueWhereUniqueInput[]
    disconnect?: MaquinaEstoqueWhereUniqueInput | MaquinaEstoqueWhereUniqueInput[]
    delete?: MaquinaEstoqueWhereUniqueInput | MaquinaEstoqueWhereUniqueInput[]
    connect?: MaquinaEstoqueWhereUniqueInput | MaquinaEstoqueWhereUniqueInput[]
    update?: MaquinaEstoqueUpdateWithWhereUniqueWithoutFilialInput | MaquinaEstoqueUpdateWithWhereUniqueWithoutFilialInput[]
    updateMany?: MaquinaEstoqueUpdateManyWithWhereWithoutFilialInput | MaquinaEstoqueUpdateManyWithWhereWithoutFilialInput[]
    deleteMany?: MaquinaEstoqueScalarWhereInput | MaquinaEstoqueScalarWhereInput[]
  }

  export type NotasFiscalCabecalhoUncheckedUpdateManyWithoutFilialNestedInput = {
    create?: XOR<NotasFiscalCabecalhoCreateWithoutFilialInput, NotasFiscalCabecalhoUncheckedCreateWithoutFilialInput> | NotasFiscalCabecalhoCreateWithoutFilialInput[] | NotasFiscalCabecalhoUncheckedCreateWithoutFilialInput[]
    connectOrCreate?: NotasFiscalCabecalhoCreateOrConnectWithoutFilialInput | NotasFiscalCabecalhoCreateOrConnectWithoutFilialInput[]
    upsert?: NotasFiscalCabecalhoUpsertWithWhereUniqueWithoutFilialInput | NotasFiscalCabecalhoUpsertWithWhereUniqueWithoutFilialInput[]
    createMany?: NotasFiscalCabecalhoCreateManyFilialInputEnvelope
    set?: NotasFiscalCabecalhoWhereUniqueInput | NotasFiscalCabecalhoWhereUniqueInput[]
    disconnect?: NotasFiscalCabecalhoWhereUniqueInput | NotasFiscalCabecalhoWhereUniqueInput[]
    delete?: NotasFiscalCabecalhoWhereUniqueInput | NotasFiscalCabecalhoWhereUniqueInput[]
    connect?: NotasFiscalCabecalhoWhereUniqueInput | NotasFiscalCabecalhoWhereUniqueInput[]
    update?: NotasFiscalCabecalhoUpdateWithWhereUniqueWithoutFilialInput | NotasFiscalCabecalhoUpdateWithWhereUniqueWithoutFilialInput[]
    updateMany?: NotasFiscalCabecalhoUpdateManyWithWhereWithoutFilialInput | NotasFiscalCabecalhoUpdateManyWithWhereWithoutFilialInput[]
    deleteMany?: NotasFiscalCabecalhoScalarWhereInput | NotasFiscalCabecalhoScalarWhereInput[]
  }

  export type VendedorUncheckedUpdateManyWithoutFilialNestedInput = {
    create?: XOR<VendedorCreateWithoutFilialInput, VendedorUncheckedCreateWithoutFilialInput> | VendedorCreateWithoutFilialInput[] | VendedorUncheckedCreateWithoutFilialInput[]
    connectOrCreate?: VendedorCreateOrConnectWithoutFilialInput | VendedorCreateOrConnectWithoutFilialInput[]
    upsert?: VendedorUpsertWithWhereUniqueWithoutFilialInput | VendedorUpsertWithWhereUniqueWithoutFilialInput[]
    createMany?: VendedorCreateManyFilialInputEnvelope
    set?: VendedorWhereUniqueInput | VendedorWhereUniqueInput[]
    disconnect?: VendedorWhereUniqueInput | VendedorWhereUniqueInput[]
    delete?: VendedorWhereUniqueInput | VendedorWhereUniqueInput[]
    connect?: VendedorWhereUniqueInput | VendedorWhereUniqueInput[]
    update?: VendedorUpdateWithWhereUniqueWithoutFilialInput | VendedorUpdateWithWhereUniqueWithoutFilialInput[]
    updateMany?: VendedorUpdateManyWithWhereWithoutFilialInput | VendedorUpdateManyWithWhereWithoutFilialInput[]
    deleteMany?: VendedorScalarWhereInput | VendedorScalarWhereInput[]
  }

  export type RfvParameterSetUncheckedUpdateManyWithoutFilialNestedInput = {
    create?: XOR<RfvParameterSetCreateWithoutFilialInput, RfvParameterSetUncheckedCreateWithoutFilialInput> | RfvParameterSetCreateWithoutFilialInput[] | RfvParameterSetUncheckedCreateWithoutFilialInput[]
    connectOrCreate?: RfvParameterSetCreateOrConnectWithoutFilialInput | RfvParameterSetCreateOrConnectWithoutFilialInput[]
    upsert?: RfvParameterSetUpsertWithWhereUniqueWithoutFilialInput | RfvParameterSetUpsertWithWhereUniqueWithoutFilialInput[]
    createMany?: RfvParameterSetCreateManyFilialInputEnvelope
    set?: RfvParameterSetWhereUniqueInput | RfvParameterSetWhereUniqueInput[]
    disconnect?: RfvParameterSetWhereUniqueInput | RfvParameterSetWhereUniqueInput[]
    delete?: RfvParameterSetWhereUniqueInput | RfvParameterSetWhereUniqueInput[]
    connect?: RfvParameterSetWhereUniqueInput | RfvParameterSetWhereUniqueInput[]
    update?: RfvParameterSetUpdateWithWhereUniqueWithoutFilialInput | RfvParameterSetUpdateWithWhereUniqueWithoutFilialInput[]
    updateMany?: RfvParameterSetUpdateManyWithWhereWithoutFilialInput | RfvParameterSetUpdateManyWithWhereWithoutFilialInput[]
    deleteMany?: RfvParameterSetScalarWhereInput | RfvParameterSetScalarWhereInput[]
  }

  export type MaquinaEstoqueUncheckedUpdateManyWithoutFilialNestedInput = {
    create?: XOR<MaquinaEstoqueCreateWithoutFilialInput, MaquinaEstoqueUncheckedCreateWithoutFilialInput> | MaquinaEstoqueCreateWithoutFilialInput[] | MaquinaEstoqueUncheckedCreateWithoutFilialInput[]
    connectOrCreate?: MaquinaEstoqueCreateOrConnectWithoutFilialInput | MaquinaEstoqueCreateOrConnectWithoutFilialInput[]
    upsert?: MaquinaEstoqueUpsertWithWhereUniqueWithoutFilialInput | MaquinaEstoqueUpsertWithWhereUniqueWithoutFilialInput[]
    createMany?: MaquinaEstoqueCreateManyFilialInputEnvelope
    set?: MaquinaEstoqueWhereUniqueInput | MaquinaEstoqueWhereUniqueInput[]
    disconnect?: MaquinaEstoqueWhereUniqueInput | MaquinaEstoqueWhereUniqueInput[]
    delete?: MaquinaEstoqueWhereUniqueInput | MaquinaEstoqueWhereUniqueInput[]
    connect?: MaquinaEstoqueWhereUniqueInput | MaquinaEstoqueWhereUniqueInput[]
    update?: MaquinaEstoqueUpdateWithWhereUniqueWithoutFilialInput | MaquinaEstoqueUpdateWithWhereUniqueWithoutFilialInput[]
    updateMany?: MaquinaEstoqueUpdateManyWithWhereWithoutFilialInput | MaquinaEstoqueUpdateManyWithWhereWithoutFilialInput[]
    deleteMany?: MaquinaEstoqueScalarWhereInput | MaquinaEstoqueScalarWhereInput[]
  }

  export type NotasFiscalCabecalhoCreateNestedManyWithoutVendedorInput = {
    create?: XOR<NotasFiscalCabecalhoCreateWithoutVendedorInput, NotasFiscalCabecalhoUncheckedCreateWithoutVendedorInput> | NotasFiscalCabecalhoCreateWithoutVendedorInput[] | NotasFiscalCabecalhoUncheckedCreateWithoutVendedorInput[]
    connectOrCreate?: NotasFiscalCabecalhoCreateOrConnectWithoutVendedorInput | NotasFiscalCabecalhoCreateOrConnectWithoutVendedorInput[]
    createMany?: NotasFiscalCabecalhoCreateManyVendedorInputEnvelope
    connect?: NotasFiscalCabecalhoWhereUniqueInput | NotasFiscalCabecalhoWhereUniqueInput[]
  }

  export type FilialCreateNestedOneWithoutVendedoresInput = {
    create?: XOR<FilialCreateWithoutVendedoresInput, FilialUncheckedCreateWithoutVendedoresInput>
    connectOrCreate?: FilialCreateOrConnectWithoutVendedoresInput
    connect?: FilialWhereUniqueInput
  }

  export type NotasFiscalCabecalhoUncheckedCreateNestedManyWithoutVendedorInput = {
    create?: XOR<NotasFiscalCabecalhoCreateWithoutVendedorInput, NotasFiscalCabecalhoUncheckedCreateWithoutVendedorInput> | NotasFiscalCabecalhoCreateWithoutVendedorInput[] | NotasFiscalCabecalhoUncheckedCreateWithoutVendedorInput[]
    connectOrCreate?: NotasFiscalCabecalhoCreateOrConnectWithoutVendedorInput | NotasFiscalCabecalhoCreateOrConnectWithoutVendedorInput[]
    createMany?: NotasFiscalCabecalhoCreateManyVendedorInputEnvelope
    connect?: NotasFiscalCabecalhoWhereUniqueInput | NotasFiscalCabecalhoWhereUniqueInput[]
  }

  export type NotasFiscalCabecalhoUpdateManyWithoutVendedorNestedInput = {
    create?: XOR<NotasFiscalCabecalhoCreateWithoutVendedorInput, NotasFiscalCabecalhoUncheckedCreateWithoutVendedorInput> | NotasFiscalCabecalhoCreateWithoutVendedorInput[] | NotasFiscalCabecalhoUncheckedCreateWithoutVendedorInput[]
    connectOrCreate?: NotasFiscalCabecalhoCreateOrConnectWithoutVendedorInput | NotasFiscalCabecalhoCreateOrConnectWithoutVendedorInput[]
    upsert?: NotasFiscalCabecalhoUpsertWithWhereUniqueWithoutVendedorInput | NotasFiscalCabecalhoUpsertWithWhereUniqueWithoutVendedorInput[]
    createMany?: NotasFiscalCabecalhoCreateManyVendedorInputEnvelope
    set?: NotasFiscalCabecalhoWhereUniqueInput | NotasFiscalCabecalhoWhereUniqueInput[]
    disconnect?: NotasFiscalCabecalhoWhereUniqueInput | NotasFiscalCabecalhoWhereUniqueInput[]
    delete?: NotasFiscalCabecalhoWhereUniqueInput | NotasFiscalCabecalhoWhereUniqueInput[]
    connect?: NotasFiscalCabecalhoWhereUniqueInput | NotasFiscalCabecalhoWhereUniqueInput[]
    update?: NotasFiscalCabecalhoUpdateWithWhereUniqueWithoutVendedorInput | NotasFiscalCabecalhoUpdateWithWhereUniqueWithoutVendedorInput[]
    updateMany?: NotasFiscalCabecalhoUpdateManyWithWhereWithoutVendedorInput | NotasFiscalCabecalhoUpdateManyWithWhereWithoutVendedorInput[]
    deleteMany?: NotasFiscalCabecalhoScalarWhereInput | NotasFiscalCabecalhoScalarWhereInput[]
  }

  export type FilialUpdateOneWithoutVendedoresNestedInput = {
    create?: XOR<FilialCreateWithoutVendedoresInput, FilialUncheckedCreateWithoutVendedoresInput>
    connectOrCreate?: FilialCreateOrConnectWithoutVendedoresInput
    upsert?: FilialUpsertWithoutVendedoresInput
    disconnect?: FilialWhereInput | boolean
    delete?: FilialWhereInput | boolean
    connect?: FilialWhereUniqueInput
    update?: XOR<XOR<FilialUpdateToOneWithWhereWithoutVendedoresInput, FilialUpdateWithoutVendedoresInput>, FilialUncheckedUpdateWithoutVendedoresInput>
  }

  export type NullableIntFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type NotasFiscalCabecalhoUncheckedUpdateManyWithoutVendedorNestedInput = {
    create?: XOR<NotasFiscalCabecalhoCreateWithoutVendedorInput, NotasFiscalCabecalhoUncheckedCreateWithoutVendedorInput> | NotasFiscalCabecalhoCreateWithoutVendedorInput[] | NotasFiscalCabecalhoUncheckedCreateWithoutVendedorInput[]
    connectOrCreate?: NotasFiscalCabecalhoCreateOrConnectWithoutVendedorInput | NotasFiscalCabecalhoCreateOrConnectWithoutVendedorInput[]
    upsert?: NotasFiscalCabecalhoUpsertWithWhereUniqueWithoutVendedorInput | NotasFiscalCabecalhoUpsertWithWhereUniqueWithoutVendedorInput[]
    createMany?: NotasFiscalCabecalhoCreateManyVendedorInputEnvelope
    set?: NotasFiscalCabecalhoWhereUniqueInput | NotasFiscalCabecalhoWhereUniqueInput[]
    disconnect?: NotasFiscalCabecalhoWhereUniqueInput | NotasFiscalCabecalhoWhereUniqueInput[]
    delete?: NotasFiscalCabecalhoWhereUniqueInput | NotasFiscalCabecalhoWhereUniqueInput[]
    connect?: NotasFiscalCabecalhoWhereUniqueInput | NotasFiscalCabecalhoWhereUniqueInput[]
    update?: NotasFiscalCabecalhoUpdateWithWhereUniqueWithoutVendedorInput | NotasFiscalCabecalhoUpdateWithWhereUniqueWithoutVendedorInput[]
    updateMany?: NotasFiscalCabecalhoUpdateManyWithWhereWithoutVendedorInput | NotasFiscalCabecalhoUpdateManyWithWhereWithoutVendedorInput[]
    deleteMany?: NotasFiscalCabecalhoScalarWhereInput | NotasFiscalCabecalhoScalarWhereInput[]
  }

  export type MaquinaEstoqueCreateNestedManyWithoutProdutoInput = {
    create?: XOR<MaquinaEstoqueCreateWithoutProdutoInput, MaquinaEstoqueUncheckedCreateWithoutProdutoInput> | MaquinaEstoqueCreateWithoutProdutoInput[] | MaquinaEstoqueUncheckedCreateWithoutProdutoInput[]
    connectOrCreate?: MaquinaEstoqueCreateOrConnectWithoutProdutoInput | MaquinaEstoqueCreateOrConnectWithoutProdutoInput[]
    createMany?: MaquinaEstoqueCreateManyProdutoInputEnvelope
    connect?: MaquinaEstoqueWhereUniqueInput | MaquinaEstoqueWhereUniqueInput[]
  }

  export type NotaFiscalItemCreateNestedManyWithoutProdutoInput = {
    create?: XOR<NotaFiscalItemCreateWithoutProdutoInput, NotaFiscalItemUncheckedCreateWithoutProdutoInput> | NotaFiscalItemCreateWithoutProdutoInput[] | NotaFiscalItemUncheckedCreateWithoutProdutoInput[]
    connectOrCreate?: NotaFiscalItemCreateOrConnectWithoutProdutoInput | NotaFiscalItemCreateOrConnectWithoutProdutoInput[]
    createMany?: NotaFiscalItemCreateManyProdutoInputEnvelope
    connect?: NotaFiscalItemWhereUniqueInput | NotaFiscalItemWhereUniqueInput[]
  }

  export type MaquinaEstoqueUncheckedCreateNestedManyWithoutProdutoInput = {
    create?: XOR<MaquinaEstoqueCreateWithoutProdutoInput, MaquinaEstoqueUncheckedCreateWithoutProdutoInput> | MaquinaEstoqueCreateWithoutProdutoInput[] | MaquinaEstoqueUncheckedCreateWithoutProdutoInput[]
    connectOrCreate?: MaquinaEstoqueCreateOrConnectWithoutProdutoInput | MaquinaEstoqueCreateOrConnectWithoutProdutoInput[]
    createMany?: MaquinaEstoqueCreateManyProdutoInputEnvelope
    connect?: MaquinaEstoqueWhereUniqueInput | MaquinaEstoqueWhereUniqueInput[]
  }

  export type NotaFiscalItemUncheckedCreateNestedManyWithoutProdutoInput = {
    create?: XOR<NotaFiscalItemCreateWithoutProdutoInput, NotaFiscalItemUncheckedCreateWithoutProdutoInput> | NotaFiscalItemCreateWithoutProdutoInput[] | NotaFiscalItemUncheckedCreateWithoutProdutoInput[]
    connectOrCreate?: NotaFiscalItemCreateOrConnectWithoutProdutoInput | NotaFiscalItemCreateOrConnectWithoutProdutoInput[]
    createMany?: NotaFiscalItemCreateManyProdutoInputEnvelope
    connect?: NotaFiscalItemWhereUniqueInput | NotaFiscalItemWhereUniqueInput[]
  }

  export type DecimalFieldUpdateOperationsInput = {
    set?: Decimal | DecimalJsLike | number | string
    increment?: Decimal | DecimalJsLike | number | string
    decrement?: Decimal | DecimalJsLike | number | string
    multiply?: Decimal | DecimalJsLike | number | string
    divide?: Decimal | DecimalJsLike | number | string
  }

  export type MaquinaEstoqueUpdateManyWithoutProdutoNestedInput = {
    create?: XOR<MaquinaEstoqueCreateWithoutProdutoInput, MaquinaEstoqueUncheckedCreateWithoutProdutoInput> | MaquinaEstoqueCreateWithoutProdutoInput[] | MaquinaEstoqueUncheckedCreateWithoutProdutoInput[]
    connectOrCreate?: MaquinaEstoqueCreateOrConnectWithoutProdutoInput | MaquinaEstoqueCreateOrConnectWithoutProdutoInput[]
    upsert?: MaquinaEstoqueUpsertWithWhereUniqueWithoutProdutoInput | MaquinaEstoqueUpsertWithWhereUniqueWithoutProdutoInput[]
    createMany?: MaquinaEstoqueCreateManyProdutoInputEnvelope
    set?: MaquinaEstoqueWhereUniqueInput | MaquinaEstoqueWhereUniqueInput[]
    disconnect?: MaquinaEstoqueWhereUniqueInput | MaquinaEstoqueWhereUniqueInput[]
    delete?: MaquinaEstoqueWhereUniqueInput | MaquinaEstoqueWhereUniqueInput[]
    connect?: MaquinaEstoqueWhereUniqueInput | MaquinaEstoqueWhereUniqueInput[]
    update?: MaquinaEstoqueUpdateWithWhereUniqueWithoutProdutoInput | MaquinaEstoqueUpdateWithWhereUniqueWithoutProdutoInput[]
    updateMany?: MaquinaEstoqueUpdateManyWithWhereWithoutProdutoInput | MaquinaEstoqueUpdateManyWithWhereWithoutProdutoInput[]
    deleteMany?: MaquinaEstoqueScalarWhereInput | MaquinaEstoqueScalarWhereInput[]
  }

  export type NotaFiscalItemUpdateManyWithoutProdutoNestedInput = {
    create?: XOR<NotaFiscalItemCreateWithoutProdutoInput, NotaFiscalItemUncheckedCreateWithoutProdutoInput> | NotaFiscalItemCreateWithoutProdutoInput[] | NotaFiscalItemUncheckedCreateWithoutProdutoInput[]
    connectOrCreate?: NotaFiscalItemCreateOrConnectWithoutProdutoInput | NotaFiscalItemCreateOrConnectWithoutProdutoInput[]
    upsert?: NotaFiscalItemUpsertWithWhereUniqueWithoutProdutoInput | NotaFiscalItemUpsertWithWhereUniqueWithoutProdutoInput[]
    createMany?: NotaFiscalItemCreateManyProdutoInputEnvelope
    set?: NotaFiscalItemWhereUniqueInput | NotaFiscalItemWhereUniqueInput[]
    disconnect?: NotaFiscalItemWhereUniqueInput | NotaFiscalItemWhereUniqueInput[]
    delete?: NotaFiscalItemWhereUniqueInput | NotaFiscalItemWhereUniqueInput[]
    connect?: NotaFiscalItemWhereUniqueInput | NotaFiscalItemWhereUniqueInput[]
    update?: NotaFiscalItemUpdateWithWhereUniqueWithoutProdutoInput | NotaFiscalItemUpdateWithWhereUniqueWithoutProdutoInput[]
    updateMany?: NotaFiscalItemUpdateManyWithWhereWithoutProdutoInput | NotaFiscalItemUpdateManyWithWhereWithoutProdutoInput[]
    deleteMany?: NotaFiscalItemScalarWhereInput | NotaFiscalItemScalarWhereInput[]
  }

  export type MaquinaEstoqueUncheckedUpdateManyWithoutProdutoNestedInput = {
    create?: XOR<MaquinaEstoqueCreateWithoutProdutoInput, MaquinaEstoqueUncheckedCreateWithoutProdutoInput> | MaquinaEstoqueCreateWithoutProdutoInput[] | MaquinaEstoqueUncheckedCreateWithoutProdutoInput[]
    connectOrCreate?: MaquinaEstoqueCreateOrConnectWithoutProdutoInput | MaquinaEstoqueCreateOrConnectWithoutProdutoInput[]
    upsert?: MaquinaEstoqueUpsertWithWhereUniqueWithoutProdutoInput | MaquinaEstoqueUpsertWithWhereUniqueWithoutProdutoInput[]
    createMany?: MaquinaEstoqueCreateManyProdutoInputEnvelope
    set?: MaquinaEstoqueWhereUniqueInput | MaquinaEstoqueWhereUniqueInput[]
    disconnect?: MaquinaEstoqueWhereUniqueInput | MaquinaEstoqueWhereUniqueInput[]
    delete?: MaquinaEstoqueWhereUniqueInput | MaquinaEstoqueWhereUniqueInput[]
    connect?: MaquinaEstoqueWhereUniqueInput | MaquinaEstoqueWhereUniqueInput[]
    update?: MaquinaEstoqueUpdateWithWhereUniqueWithoutProdutoInput | MaquinaEstoqueUpdateWithWhereUniqueWithoutProdutoInput[]
    updateMany?: MaquinaEstoqueUpdateManyWithWhereWithoutProdutoInput | MaquinaEstoqueUpdateManyWithWhereWithoutProdutoInput[]
    deleteMany?: MaquinaEstoqueScalarWhereInput | MaquinaEstoqueScalarWhereInput[]
  }

  export type NotaFiscalItemUncheckedUpdateManyWithoutProdutoNestedInput = {
    create?: XOR<NotaFiscalItemCreateWithoutProdutoInput, NotaFiscalItemUncheckedCreateWithoutProdutoInput> | NotaFiscalItemCreateWithoutProdutoInput[] | NotaFiscalItemUncheckedCreateWithoutProdutoInput[]
    connectOrCreate?: NotaFiscalItemCreateOrConnectWithoutProdutoInput | NotaFiscalItemCreateOrConnectWithoutProdutoInput[]
    upsert?: NotaFiscalItemUpsertWithWhereUniqueWithoutProdutoInput | NotaFiscalItemUpsertWithWhereUniqueWithoutProdutoInput[]
    createMany?: NotaFiscalItemCreateManyProdutoInputEnvelope
    set?: NotaFiscalItemWhereUniqueInput | NotaFiscalItemWhereUniqueInput[]
    disconnect?: NotaFiscalItemWhereUniqueInput | NotaFiscalItemWhereUniqueInput[]
    delete?: NotaFiscalItemWhereUniqueInput | NotaFiscalItemWhereUniqueInput[]
    connect?: NotaFiscalItemWhereUniqueInput | NotaFiscalItemWhereUniqueInput[]
    update?: NotaFiscalItemUpdateWithWhereUniqueWithoutProdutoInput | NotaFiscalItemUpdateWithWhereUniqueWithoutProdutoInput[]
    updateMany?: NotaFiscalItemUpdateManyWithWhereWithoutProdutoInput | NotaFiscalItemUpdateManyWithWhereWithoutProdutoInput[]
    deleteMany?: NotaFiscalItemScalarWhereInput | NotaFiscalItemScalarWhereInput[]
  }

  export type ProdutoCreateNestedOneWithoutMaquinasEstoqueInput = {
    create?: XOR<ProdutoCreateWithoutMaquinasEstoqueInput, ProdutoUncheckedCreateWithoutMaquinasEstoqueInput>
    connectOrCreate?: ProdutoCreateOrConnectWithoutMaquinasEstoqueInput
    connect?: ProdutoWhereUniqueInput
  }

  export type FilialCreateNestedOneWithoutMaquinasEstoqueInput = {
    create?: XOR<FilialCreateWithoutMaquinasEstoqueInput, FilialUncheckedCreateWithoutMaquinasEstoqueInput>
    connectOrCreate?: FilialCreateOrConnectWithoutMaquinasEstoqueInput
    connect?: FilialWhereUniqueInput
  }

  export type NotaFiscalItemCreateNestedManyWithoutMaquinas_EstoqueInput = {
    create?: XOR<NotaFiscalItemCreateWithoutMaquinas_EstoqueInput, NotaFiscalItemUncheckedCreateWithoutMaquinas_EstoqueInput> | NotaFiscalItemCreateWithoutMaquinas_EstoqueInput[] | NotaFiscalItemUncheckedCreateWithoutMaquinas_EstoqueInput[]
    connectOrCreate?: NotaFiscalItemCreateOrConnectWithoutMaquinas_EstoqueInput | NotaFiscalItemCreateOrConnectWithoutMaquinas_EstoqueInput[]
    createMany?: NotaFiscalItemCreateManyMaquinas_EstoqueInputEnvelope
    connect?: NotaFiscalItemWhereUniqueInput | NotaFiscalItemWhereUniqueInput[]
  }

  export type NotaFiscalItemUncheckedCreateNestedManyWithoutMaquinas_EstoqueInput = {
    create?: XOR<NotaFiscalItemCreateWithoutMaquinas_EstoqueInput, NotaFiscalItemUncheckedCreateWithoutMaquinas_EstoqueInput> | NotaFiscalItemCreateWithoutMaquinas_EstoqueInput[] | NotaFiscalItemUncheckedCreateWithoutMaquinas_EstoqueInput[]
    connectOrCreate?: NotaFiscalItemCreateOrConnectWithoutMaquinas_EstoqueInput | NotaFiscalItemCreateOrConnectWithoutMaquinas_EstoqueInput[]
    createMany?: NotaFiscalItemCreateManyMaquinas_EstoqueInputEnvelope
    connect?: NotaFiscalItemWhereUniqueInput | NotaFiscalItemWhereUniqueInput[]
  }

  export type ProdutoUpdateOneRequiredWithoutMaquinasEstoqueNestedInput = {
    create?: XOR<ProdutoCreateWithoutMaquinasEstoqueInput, ProdutoUncheckedCreateWithoutMaquinasEstoqueInput>
    connectOrCreate?: ProdutoCreateOrConnectWithoutMaquinasEstoqueInput
    upsert?: ProdutoUpsertWithoutMaquinasEstoqueInput
    connect?: ProdutoWhereUniqueInput
    update?: XOR<XOR<ProdutoUpdateToOneWithWhereWithoutMaquinasEstoqueInput, ProdutoUpdateWithoutMaquinasEstoqueInput>, ProdutoUncheckedUpdateWithoutMaquinasEstoqueInput>
  }

  export type FilialUpdateOneWithoutMaquinasEstoqueNestedInput = {
    create?: XOR<FilialCreateWithoutMaquinasEstoqueInput, FilialUncheckedCreateWithoutMaquinasEstoqueInput>
    connectOrCreate?: FilialCreateOrConnectWithoutMaquinasEstoqueInput
    upsert?: FilialUpsertWithoutMaquinasEstoqueInput
    disconnect?: FilialWhereInput | boolean
    delete?: FilialWhereInput | boolean
    connect?: FilialWhereUniqueInput
    update?: XOR<XOR<FilialUpdateToOneWithWhereWithoutMaquinasEstoqueInput, FilialUpdateWithoutMaquinasEstoqueInput>, FilialUncheckedUpdateWithoutMaquinasEstoqueInput>
  }

  export type NotaFiscalItemUpdateManyWithoutMaquinas_EstoqueNestedInput = {
    create?: XOR<NotaFiscalItemCreateWithoutMaquinas_EstoqueInput, NotaFiscalItemUncheckedCreateWithoutMaquinas_EstoqueInput> | NotaFiscalItemCreateWithoutMaquinas_EstoqueInput[] | NotaFiscalItemUncheckedCreateWithoutMaquinas_EstoqueInput[]
    connectOrCreate?: NotaFiscalItemCreateOrConnectWithoutMaquinas_EstoqueInput | NotaFiscalItemCreateOrConnectWithoutMaquinas_EstoqueInput[]
    upsert?: NotaFiscalItemUpsertWithWhereUniqueWithoutMaquinas_EstoqueInput | NotaFiscalItemUpsertWithWhereUniqueWithoutMaquinas_EstoqueInput[]
    createMany?: NotaFiscalItemCreateManyMaquinas_EstoqueInputEnvelope
    set?: NotaFiscalItemWhereUniqueInput | NotaFiscalItemWhereUniqueInput[]
    disconnect?: NotaFiscalItemWhereUniqueInput | NotaFiscalItemWhereUniqueInput[]
    delete?: NotaFiscalItemWhereUniqueInput | NotaFiscalItemWhereUniqueInput[]
    connect?: NotaFiscalItemWhereUniqueInput | NotaFiscalItemWhereUniqueInput[]
    update?: NotaFiscalItemUpdateWithWhereUniqueWithoutMaquinas_EstoqueInput | NotaFiscalItemUpdateWithWhereUniqueWithoutMaquinas_EstoqueInput[]
    updateMany?: NotaFiscalItemUpdateManyWithWhereWithoutMaquinas_EstoqueInput | NotaFiscalItemUpdateManyWithWhereWithoutMaquinas_EstoqueInput[]
    deleteMany?: NotaFiscalItemScalarWhereInput | NotaFiscalItemScalarWhereInput[]
  }

  export type NotaFiscalItemUncheckedUpdateManyWithoutMaquinas_EstoqueNestedInput = {
    create?: XOR<NotaFiscalItemCreateWithoutMaquinas_EstoqueInput, NotaFiscalItemUncheckedCreateWithoutMaquinas_EstoqueInput> | NotaFiscalItemCreateWithoutMaquinas_EstoqueInput[] | NotaFiscalItemUncheckedCreateWithoutMaquinas_EstoqueInput[]
    connectOrCreate?: NotaFiscalItemCreateOrConnectWithoutMaquinas_EstoqueInput | NotaFiscalItemCreateOrConnectWithoutMaquinas_EstoqueInput[]
    upsert?: NotaFiscalItemUpsertWithWhereUniqueWithoutMaquinas_EstoqueInput | NotaFiscalItemUpsertWithWhereUniqueWithoutMaquinas_EstoqueInput[]
    createMany?: NotaFiscalItemCreateManyMaquinas_EstoqueInputEnvelope
    set?: NotaFiscalItemWhereUniqueInput | NotaFiscalItemWhereUniqueInput[]
    disconnect?: NotaFiscalItemWhereUniqueInput | NotaFiscalItemWhereUniqueInput[]
    delete?: NotaFiscalItemWhereUniqueInput | NotaFiscalItemWhereUniqueInput[]
    connect?: NotaFiscalItemWhereUniqueInput | NotaFiscalItemWhereUniqueInput[]
    update?: NotaFiscalItemUpdateWithWhereUniqueWithoutMaquinas_EstoqueInput | NotaFiscalItemUpdateWithWhereUniqueWithoutMaquinas_EstoqueInput[]
    updateMany?: NotaFiscalItemUpdateManyWithWhereWithoutMaquinas_EstoqueInput | NotaFiscalItemUpdateManyWithWhereWithoutMaquinas_EstoqueInput[]
    deleteMany?: NotaFiscalItemScalarWhereInput | NotaFiscalItemScalarWhereInput[]
  }

  export type FilialCreateNestedOneWithoutNotasFiscaisInput = {
    create?: XOR<FilialCreateWithoutNotasFiscaisInput, FilialUncheckedCreateWithoutNotasFiscaisInput>
    connectOrCreate?: FilialCreateOrConnectWithoutNotasFiscaisInput
    connect?: FilialWhereUniqueInput
  }

  export type ClienteCreateNestedOneWithoutNotasFiscaisInput = {
    create?: XOR<ClienteCreateWithoutNotasFiscaisInput, ClienteUncheckedCreateWithoutNotasFiscaisInput>
    connectOrCreate?: ClienteCreateOrConnectWithoutNotasFiscaisInput
    connect?: ClienteWhereUniqueInput
  }

  export type VendedorCreateNestedOneWithoutNotasFiscaisInput = {
    create?: XOR<VendedorCreateWithoutNotasFiscaisInput, VendedorUncheckedCreateWithoutNotasFiscaisInput>
    connectOrCreate?: VendedorCreateOrConnectWithoutNotasFiscaisInput
    connect?: VendedorWhereUniqueInput
  }

  export type NotaFiscalItemCreateNestedManyWithoutNotaFiscalInput = {
    create?: XOR<NotaFiscalItemCreateWithoutNotaFiscalInput, NotaFiscalItemUncheckedCreateWithoutNotaFiscalInput> | NotaFiscalItemCreateWithoutNotaFiscalInput[] | NotaFiscalItemUncheckedCreateWithoutNotaFiscalInput[]
    connectOrCreate?: NotaFiscalItemCreateOrConnectWithoutNotaFiscalInput | NotaFiscalItemCreateOrConnectWithoutNotaFiscalInput[]
    createMany?: NotaFiscalItemCreateManyNotaFiscalInputEnvelope
    connect?: NotaFiscalItemWhereUniqueInput | NotaFiscalItemWhereUniqueInput[]
  }

  export type NotaFiscalItemUncheckedCreateNestedManyWithoutNotaFiscalInput = {
    create?: XOR<NotaFiscalItemCreateWithoutNotaFiscalInput, NotaFiscalItemUncheckedCreateWithoutNotaFiscalInput> | NotaFiscalItemCreateWithoutNotaFiscalInput[] | NotaFiscalItemUncheckedCreateWithoutNotaFiscalInput[]
    connectOrCreate?: NotaFiscalItemCreateOrConnectWithoutNotaFiscalInput | NotaFiscalItemCreateOrConnectWithoutNotaFiscalInput[]
    createMany?: NotaFiscalItemCreateManyNotaFiscalInputEnvelope
    connect?: NotaFiscalItemWhereUniqueInput | NotaFiscalItemWhereUniqueInput[]
  }

  export type FilialUpdateOneWithoutNotasFiscaisNestedInput = {
    create?: XOR<FilialCreateWithoutNotasFiscaisInput, FilialUncheckedCreateWithoutNotasFiscaisInput>
    connectOrCreate?: FilialCreateOrConnectWithoutNotasFiscaisInput
    upsert?: FilialUpsertWithoutNotasFiscaisInput
    disconnect?: FilialWhereInput | boolean
    delete?: FilialWhereInput | boolean
    connect?: FilialWhereUniqueInput
    update?: XOR<XOR<FilialUpdateToOneWithWhereWithoutNotasFiscaisInput, FilialUpdateWithoutNotasFiscaisInput>, FilialUncheckedUpdateWithoutNotasFiscaisInput>
  }

  export type ClienteUpdateOneWithoutNotasFiscaisNestedInput = {
    create?: XOR<ClienteCreateWithoutNotasFiscaisInput, ClienteUncheckedCreateWithoutNotasFiscaisInput>
    connectOrCreate?: ClienteCreateOrConnectWithoutNotasFiscaisInput
    upsert?: ClienteUpsertWithoutNotasFiscaisInput
    disconnect?: ClienteWhereInput | boolean
    delete?: ClienteWhereInput | boolean
    connect?: ClienteWhereUniqueInput
    update?: XOR<XOR<ClienteUpdateToOneWithWhereWithoutNotasFiscaisInput, ClienteUpdateWithoutNotasFiscaisInput>, ClienteUncheckedUpdateWithoutNotasFiscaisInput>
  }

  export type VendedorUpdateOneWithoutNotasFiscaisNestedInput = {
    create?: XOR<VendedorCreateWithoutNotasFiscaisInput, VendedorUncheckedCreateWithoutNotasFiscaisInput>
    connectOrCreate?: VendedorCreateOrConnectWithoutNotasFiscaisInput
    upsert?: VendedorUpsertWithoutNotasFiscaisInput
    disconnect?: VendedorWhereInput | boolean
    delete?: VendedorWhereInput | boolean
    connect?: VendedorWhereUniqueInput
    update?: XOR<XOR<VendedorUpdateToOneWithWhereWithoutNotasFiscaisInput, VendedorUpdateWithoutNotasFiscaisInput>, VendedorUncheckedUpdateWithoutNotasFiscaisInput>
  }

  export type NotaFiscalItemUpdateManyWithoutNotaFiscalNestedInput = {
    create?: XOR<NotaFiscalItemCreateWithoutNotaFiscalInput, NotaFiscalItemUncheckedCreateWithoutNotaFiscalInput> | NotaFiscalItemCreateWithoutNotaFiscalInput[] | NotaFiscalItemUncheckedCreateWithoutNotaFiscalInput[]
    connectOrCreate?: NotaFiscalItemCreateOrConnectWithoutNotaFiscalInput | NotaFiscalItemCreateOrConnectWithoutNotaFiscalInput[]
    upsert?: NotaFiscalItemUpsertWithWhereUniqueWithoutNotaFiscalInput | NotaFiscalItemUpsertWithWhereUniqueWithoutNotaFiscalInput[]
    createMany?: NotaFiscalItemCreateManyNotaFiscalInputEnvelope
    set?: NotaFiscalItemWhereUniqueInput | NotaFiscalItemWhereUniqueInput[]
    disconnect?: NotaFiscalItemWhereUniqueInput | NotaFiscalItemWhereUniqueInput[]
    delete?: NotaFiscalItemWhereUniqueInput | NotaFiscalItemWhereUniqueInput[]
    connect?: NotaFiscalItemWhereUniqueInput | NotaFiscalItemWhereUniqueInput[]
    update?: NotaFiscalItemUpdateWithWhereUniqueWithoutNotaFiscalInput | NotaFiscalItemUpdateWithWhereUniqueWithoutNotaFiscalInput[]
    updateMany?: NotaFiscalItemUpdateManyWithWhereWithoutNotaFiscalInput | NotaFiscalItemUpdateManyWithWhereWithoutNotaFiscalInput[]
    deleteMany?: NotaFiscalItemScalarWhereInput | NotaFiscalItemScalarWhereInput[]
  }

  export type NotaFiscalItemUncheckedUpdateManyWithoutNotaFiscalNestedInput = {
    create?: XOR<NotaFiscalItemCreateWithoutNotaFiscalInput, NotaFiscalItemUncheckedCreateWithoutNotaFiscalInput> | NotaFiscalItemCreateWithoutNotaFiscalInput[] | NotaFiscalItemUncheckedCreateWithoutNotaFiscalInput[]
    connectOrCreate?: NotaFiscalItemCreateOrConnectWithoutNotaFiscalInput | NotaFiscalItemCreateOrConnectWithoutNotaFiscalInput[]
    upsert?: NotaFiscalItemUpsertWithWhereUniqueWithoutNotaFiscalInput | NotaFiscalItemUpsertWithWhereUniqueWithoutNotaFiscalInput[]
    createMany?: NotaFiscalItemCreateManyNotaFiscalInputEnvelope
    set?: NotaFiscalItemWhereUniqueInput | NotaFiscalItemWhereUniqueInput[]
    disconnect?: NotaFiscalItemWhereUniqueInput | NotaFiscalItemWhereUniqueInput[]
    delete?: NotaFiscalItemWhereUniqueInput | NotaFiscalItemWhereUniqueInput[]
    connect?: NotaFiscalItemWhereUniqueInput | NotaFiscalItemWhereUniqueInput[]
    update?: NotaFiscalItemUpdateWithWhereUniqueWithoutNotaFiscalInput | NotaFiscalItemUpdateWithWhereUniqueWithoutNotaFiscalInput[]
    updateMany?: NotaFiscalItemUpdateManyWithWhereWithoutNotaFiscalInput | NotaFiscalItemUpdateManyWithWhereWithoutNotaFiscalInput[]
    deleteMany?: NotaFiscalItemScalarWhereInput | NotaFiscalItemScalarWhereInput[]
  }

  export type MaquinaEstoqueCreateNestedOneWithoutNotas_Fiscais_ItensInput = {
    create?: XOR<MaquinaEstoqueCreateWithoutNotas_Fiscais_ItensInput, MaquinaEstoqueUncheckedCreateWithoutNotas_Fiscais_ItensInput>
    connectOrCreate?: MaquinaEstoqueCreateOrConnectWithoutNotas_Fiscais_ItensInput
    connect?: MaquinaEstoqueWhereUniqueInput
  }

  export type NotasFiscalCabecalhoCreateNestedOneWithoutItensInput = {
    create?: XOR<NotasFiscalCabecalhoCreateWithoutItensInput, NotasFiscalCabecalhoUncheckedCreateWithoutItensInput>
    connectOrCreate?: NotasFiscalCabecalhoCreateOrConnectWithoutItensInput
    connect?: NotasFiscalCabecalhoWhereUniqueInput
  }

  export type ProdutoCreateNestedOneWithoutNotasFiscaisItensInput = {
    create?: XOR<ProdutoCreateWithoutNotasFiscaisItensInput, ProdutoUncheckedCreateWithoutNotasFiscaisItensInput>
    connectOrCreate?: ProdutoCreateOrConnectWithoutNotasFiscaisItensInput
    connect?: ProdutoWhereUniqueInput
  }

  export type MaquinaEstoqueUpdateOneWithoutNotas_Fiscais_ItensNestedInput = {
    create?: XOR<MaquinaEstoqueCreateWithoutNotas_Fiscais_ItensInput, MaquinaEstoqueUncheckedCreateWithoutNotas_Fiscais_ItensInput>
    connectOrCreate?: MaquinaEstoqueCreateOrConnectWithoutNotas_Fiscais_ItensInput
    upsert?: MaquinaEstoqueUpsertWithoutNotas_Fiscais_ItensInput
    disconnect?: MaquinaEstoqueWhereInput | boolean
    delete?: MaquinaEstoqueWhereInput | boolean
    connect?: MaquinaEstoqueWhereUniqueInput
    update?: XOR<XOR<MaquinaEstoqueUpdateToOneWithWhereWithoutNotas_Fiscais_ItensInput, MaquinaEstoqueUpdateWithoutNotas_Fiscais_ItensInput>, MaquinaEstoqueUncheckedUpdateWithoutNotas_Fiscais_ItensInput>
  }

  export type NotasFiscalCabecalhoUpdateOneRequiredWithoutItensNestedInput = {
    create?: XOR<NotasFiscalCabecalhoCreateWithoutItensInput, NotasFiscalCabecalhoUncheckedCreateWithoutItensInput>
    connectOrCreate?: NotasFiscalCabecalhoCreateOrConnectWithoutItensInput
    upsert?: NotasFiscalCabecalhoUpsertWithoutItensInput
    connect?: NotasFiscalCabecalhoWhereUniqueInput
    update?: XOR<XOR<NotasFiscalCabecalhoUpdateToOneWithWhereWithoutItensInput, NotasFiscalCabecalhoUpdateWithoutItensInput>, NotasFiscalCabecalhoUncheckedUpdateWithoutItensInput>
  }

  export type ProdutoUpdateOneRequiredWithoutNotasFiscaisItensNestedInput = {
    create?: XOR<ProdutoCreateWithoutNotasFiscaisItensInput, ProdutoUncheckedCreateWithoutNotasFiscaisItensInput>
    connectOrCreate?: ProdutoCreateOrConnectWithoutNotasFiscaisItensInput
    upsert?: ProdutoUpsertWithoutNotasFiscaisItensInput
    connect?: ProdutoWhereUniqueInput
    update?: XOR<XOR<ProdutoUpdateToOneWithWhereWithoutNotasFiscaisItensInput, ProdutoUpdateWithoutNotasFiscaisItensInput>, ProdutoUncheckedUpdateWithoutNotasFiscaisItensInput>
  }

  export type FilialCreateNestedOneWithoutRfvParameterSetsInput = {
    create?: XOR<FilialCreateWithoutRfvParameterSetsInput, FilialUncheckedCreateWithoutRfvParameterSetsInput>
    connectOrCreate?: FilialCreateOrConnectWithoutRfvParameterSetsInput
    connect?: FilialWhereUniqueInput
  }

  export type RfvSegmentCreateNestedManyWithoutParameterSetInput = {
    create?: XOR<RfvSegmentCreateWithoutParameterSetInput, RfvSegmentUncheckedCreateWithoutParameterSetInput> | RfvSegmentCreateWithoutParameterSetInput[] | RfvSegmentUncheckedCreateWithoutParameterSetInput[]
    connectOrCreate?: RfvSegmentCreateOrConnectWithoutParameterSetInput | RfvSegmentCreateOrConnectWithoutParameterSetInput[]
    createMany?: RfvSegmentCreateManyParameterSetInputEnvelope
    connect?: RfvSegmentWhereUniqueInput | RfvSegmentWhereUniqueInput[]
  }

  export type RfvSegmentUncheckedCreateNestedManyWithoutParameterSetInput = {
    create?: XOR<RfvSegmentCreateWithoutParameterSetInput, RfvSegmentUncheckedCreateWithoutParameterSetInput> | RfvSegmentCreateWithoutParameterSetInput[] | RfvSegmentUncheckedCreateWithoutParameterSetInput[]
    connectOrCreate?: RfvSegmentCreateOrConnectWithoutParameterSetInput | RfvSegmentCreateOrConnectWithoutParameterSetInput[]
    createMany?: RfvSegmentCreateManyParameterSetInputEnvelope
    connect?: RfvSegmentWhereUniqueInput | RfvSegmentWhereUniqueInput[]
  }

  export type EnumRfvStrategyFieldUpdateOperationsInput = {
    set?: $Enums.RfvStrategy
  }

  export type NullableDateTimeFieldUpdateOperationsInput = {
    set?: Date | string | null
  }

  export type EnumCalculationStrategyFieldUpdateOperationsInput = {
    set?: $Enums.CalculationStrategy
  }

  export type FilialUpdateOneWithoutRfvParameterSetsNestedInput = {
    create?: XOR<FilialCreateWithoutRfvParameterSetsInput, FilialUncheckedCreateWithoutRfvParameterSetsInput>
    connectOrCreate?: FilialCreateOrConnectWithoutRfvParameterSetsInput
    upsert?: FilialUpsertWithoutRfvParameterSetsInput
    disconnect?: FilialWhereInput | boolean
    delete?: FilialWhereInput | boolean
    connect?: FilialWhereUniqueInput
    update?: XOR<XOR<FilialUpdateToOneWithWhereWithoutRfvParameterSetsInput, FilialUpdateWithoutRfvParameterSetsInput>, FilialUncheckedUpdateWithoutRfvParameterSetsInput>
  }

  export type RfvSegmentUpdateManyWithoutParameterSetNestedInput = {
    create?: XOR<RfvSegmentCreateWithoutParameterSetInput, RfvSegmentUncheckedCreateWithoutParameterSetInput> | RfvSegmentCreateWithoutParameterSetInput[] | RfvSegmentUncheckedCreateWithoutParameterSetInput[]
    connectOrCreate?: RfvSegmentCreateOrConnectWithoutParameterSetInput | RfvSegmentCreateOrConnectWithoutParameterSetInput[]
    upsert?: RfvSegmentUpsertWithWhereUniqueWithoutParameterSetInput | RfvSegmentUpsertWithWhereUniqueWithoutParameterSetInput[]
    createMany?: RfvSegmentCreateManyParameterSetInputEnvelope
    set?: RfvSegmentWhereUniqueInput | RfvSegmentWhereUniqueInput[]
    disconnect?: RfvSegmentWhereUniqueInput | RfvSegmentWhereUniqueInput[]
    delete?: RfvSegmentWhereUniqueInput | RfvSegmentWhereUniqueInput[]
    connect?: RfvSegmentWhereUniqueInput | RfvSegmentWhereUniqueInput[]
    update?: RfvSegmentUpdateWithWhereUniqueWithoutParameterSetInput | RfvSegmentUpdateWithWhereUniqueWithoutParameterSetInput[]
    updateMany?: RfvSegmentUpdateManyWithWhereWithoutParameterSetInput | RfvSegmentUpdateManyWithWhereWithoutParameterSetInput[]
    deleteMany?: RfvSegmentScalarWhereInput | RfvSegmentScalarWhereInput[]
  }

  export type RfvSegmentUncheckedUpdateManyWithoutParameterSetNestedInput = {
    create?: XOR<RfvSegmentCreateWithoutParameterSetInput, RfvSegmentUncheckedCreateWithoutParameterSetInput> | RfvSegmentCreateWithoutParameterSetInput[] | RfvSegmentUncheckedCreateWithoutParameterSetInput[]
    connectOrCreate?: RfvSegmentCreateOrConnectWithoutParameterSetInput | RfvSegmentCreateOrConnectWithoutParameterSetInput[]
    upsert?: RfvSegmentUpsertWithWhereUniqueWithoutParameterSetInput | RfvSegmentUpsertWithWhereUniqueWithoutParameterSetInput[]
    createMany?: RfvSegmentCreateManyParameterSetInputEnvelope
    set?: RfvSegmentWhereUniqueInput | RfvSegmentWhereUniqueInput[]
    disconnect?: RfvSegmentWhereUniqueInput | RfvSegmentWhereUniqueInput[]
    delete?: RfvSegmentWhereUniqueInput | RfvSegmentWhereUniqueInput[]
    connect?: RfvSegmentWhereUniqueInput | RfvSegmentWhereUniqueInput[]
    update?: RfvSegmentUpdateWithWhereUniqueWithoutParameterSetInput | RfvSegmentUpdateWithWhereUniqueWithoutParameterSetInput[]
    updateMany?: RfvSegmentUpdateManyWithWhereWithoutParameterSetInput | RfvSegmentUpdateManyWithWhereWithoutParameterSetInput[]
    deleteMany?: RfvSegmentScalarWhereInput | RfvSegmentScalarWhereInput[]
  }

  export type RfvParameterSetCreateNestedOneWithoutSegmentsInput = {
    create?: XOR<RfvParameterSetCreateWithoutSegmentsInput, RfvParameterSetUncheckedCreateWithoutSegmentsInput>
    connectOrCreate?: RfvParameterSetCreateOrConnectWithoutSegmentsInput
    connect?: RfvParameterSetWhereUniqueInput
  }

  export type RfvParameterSetUpdateOneRequiredWithoutSegmentsNestedInput = {
    create?: XOR<RfvParameterSetCreateWithoutSegmentsInput, RfvParameterSetUncheckedCreateWithoutSegmentsInput>
    connectOrCreate?: RfvParameterSetCreateOrConnectWithoutSegmentsInput
    upsert?: RfvParameterSetUpsertWithoutSegmentsInput
    connect?: RfvParameterSetWhereUniqueInput
    update?: XOR<XOR<RfvParameterSetUpdateToOneWithWhereWithoutSegmentsInput, RfvParameterSetUpdateWithoutSegmentsInput>, RfvParameterSetUncheckedUpdateWithoutSegmentsInput>
  }

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type NestedStringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | null
    notIn?: string[] | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type NestedBoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type NestedDateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[]
    notIn?: Date[] | string[]
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type NestedIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedStringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | null
    notIn?: string[] | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type NestedBoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type NestedDateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[]
    notIn?: Date[] | string[]
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type NestedIntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type NestedFloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type NestedDecimalFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[]
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[]
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
  }

  export type NestedDecimalWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[]
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[]
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalWithAggregatesFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedDecimalFilter<$PrismaModel>
    _sum?: NestedDecimalFilter<$PrismaModel>
    _min?: NestedDecimalFilter<$PrismaModel>
    _max?: NestedDecimalFilter<$PrismaModel>
  }

  export type NestedEnumRfvStrategyFilter<$PrismaModel = never> = {
    equals?: $Enums.RfvStrategy | EnumRfvStrategyFieldRefInput<$PrismaModel>
    in?: $Enums.RfvStrategy[]
    notIn?: $Enums.RfvStrategy[]
    not?: NestedEnumRfvStrategyFilter<$PrismaModel> | $Enums.RfvStrategy
  }

  export type NestedDateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | null
    notIn?: Date[] | string[] | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type NestedEnumCalculationStrategyFilter<$PrismaModel = never> = {
    equals?: $Enums.CalculationStrategy | EnumCalculationStrategyFieldRefInput<$PrismaModel>
    in?: $Enums.CalculationStrategy[]
    notIn?: $Enums.CalculationStrategy[]
    not?: NestedEnumCalculationStrategyFilter<$PrismaModel> | $Enums.CalculationStrategy
  }

  export type NestedEnumRfvStrategyWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.RfvStrategy | EnumRfvStrategyFieldRefInput<$PrismaModel>
    in?: $Enums.RfvStrategy[]
    notIn?: $Enums.RfvStrategy[]
    not?: NestedEnumRfvStrategyWithAggregatesFilter<$PrismaModel> | $Enums.RfvStrategy
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumRfvStrategyFilter<$PrismaModel>
    _max?: NestedEnumRfvStrategyFilter<$PrismaModel>
  }
  export type NestedJsonFilter<$PrismaModel = never> = 
    | PatchUndefined<
        Either<Required<NestedJsonFilterBase<$PrismaModel>>, Exclude<keyof Required<NestedJsonFilterBase<$PrismaModel>>, 'path'>>,
        Required<NestedJsonFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<NestedJsonFilterBase<$PrismaModel>>, 'path'>>

  export type NestedJsonFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue
    lte?: InputJsonValue
    gt?: InputJsonValue
    gte?: InputJsonValue
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type NestedDateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | null
    notIn?: Date[] | string[] | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type NestedEnumCalculationStrategyWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.CalculationStrategy | EnumCalculationStrategyFieldRefInput<$PrismaModel>
    in?: $Enums.CalculationStrategy[]
    notIn?: $Enums.CalculationStrategy[]
    not?: NestedEnumCalculationStrategyWithAggregatesFilter<$PrismaModel> | $Enums.CalculationStrategy
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumCalculationStrategyFilter<$PrismaModel>
    _max?: NestedEnumCalculationStrategyFilter<$PrismaModel>
  }
  export type NestedJsonNullableFilter<$PrismaModel = never> = 
    | PatchUndefined<
        Either<Required<NestedJsonNullableFilterBase<$PrismaModel>>, Exclude<keyof Required<NestedJsonNullableFilterBase<$PrismaModel>>, 'path'>>,
        Required<NestedJsonNullableFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<NestedJsonNullableFilterBase<$PrismaModel>>, 'path'>>

  export type NestedJsonNullableFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue
    lte?: InputJsonValue
    gt?: InputJsonValue
    gte?: InputJsonValue
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type FilialCreateWithoutEmpresaInput = {
    nome: string
    cnpj: string
    cidade?: string | null
    estado?: string | null
    notasFiscais?: NotasFiscalCabecalhoCreateNestedManyWithoutFilialInput
    vendedores?: VendedorCreateNestedManyWithoutFilialInput
    rfvParameterSets?: RfvParameterSetCreateNestedManyWithoutFilialInput
    maquinasEstoque?: MaquinaEstoqueCreateNestedManyWithoutFilialInput
  }

  export type FilialUncheckedCreateWithoutEmpresaInput = {
    id?: number
    nome: string
    cnpj: string
    cidade?: string | null
    estado?: string | null
    notasFiscais?: NotasFiscalCabecalhoUncheckedCreateNestedManyWithoutFilialInput
    vendedores?: VendedorUncheckedCreateNestedManyWithoutFilialInput
    rfvParameterSets?: RfvParameterSetUncheckedCreateNestedManyWithoutFilialInput
    maquinasEstoque?: MaquinaEstoqueUncheckedCreateNestedManyWithoutFilialInput
  }

  export type FilialCreateOrConnectWithoutEmpresaInput = {
    where: FilialWhereUniqueInput
    create: XOR<FilialCreateWithoutEmpresaInput, FilialUncheckedCreateWithoutEmpresaInput>
  }

  export type FilialCreateManyEmpresaInputEnvelope = {
    data: FilialCreateManyEmpresaInput | FilialCreateManyEmpresaInput[]
    skipDuplicates?: boolean
  }

  export type FilialUpsertWithWhereUniqueWithoutEmpresaInput = {
    where: FilialWhereUniqueInput
    update: XOR<FilialUpdateWithoutEmpresaInput, FilialUncheckedUpdateWithoutEmpresaInput>
    create: XOR<FilialCreateWithoutEmpresaInput, FilialUncheckedCreateWithoutEmpresaInput>
  }

  export type FilialUpdateWithWhereUniqueWithoutEmpresaInput = {
    where: FilialWhereUniqueInput
    data: XOR<FilialUpdateWithoutEmpresaInput, FilialUncheckedUpdateWithoutEmpresaInput>
  }

  export type FilialUpdateManyWithWhereWithoutEmpresaInput = {
    where: FilialScalarWhereInput
    data: XOR<FilialUpdateManyMutationInput, FilialUncheckedUpdateManyWithoutEmpresaInput>
  }

  export type FilialScalarWhereInput = {
    AND?: FilialScalarWhereInput | FilialScalarWhereInput[]
    OR?: FilialScalarWhereInput[]
    NOT?: FilialScalarWhereInput | FilialScalarWhereInput[]
    id?: IntFilter<"Filial"> | number
    empresaId?: IntFilter<"Filial"> | number
    nome?: StringFilter<"Filial"> | string
    cnpj?: StringFilter<"Filial"> | string
    cidade?: StringNullableFilter<"Filial"> | string | null
    estado?: StringNullableFilter<"Filial"> | string | null
  }

  export type NotasFiscalCabecalhoCreateWithoutClienteInput = {
    numeroNota: number
    dataEmissao: Date | string
    valorTotal: Decimal | DecimalJsLike | number | string
    filial?: FilialCreateNestedOneWithoutNotasFiscaisInput
    vendedor?: VendedorCreateNestedOneWithoutNotasFiscaisInput
    itens?: NotaFiscalItemCreateNestedManyWithoutNotaFiscalInput
  }

  export type NotasFiscalCabecalhoUncheckedCreateWithoutClienteInput = {
    id?: number
    numeroNota: number
    dataEmissao: Date | string
    valorTotal: Decimal | DecimalJsLike | number | string
    filialId?: number | null
    vendedorId?: number | null
    itens?: NotaFiscalItemUncheckedCreateNestedManyWithoutNotaFiscalInput
  }

  export type NotasFiscalCabecalhoCreateOrConnectWithoutClienteInput = {
    where: NotasFiscalCabecalhoWhereUniqueInput
    create: XOR<NotasFiscalCabecalhoCreateWithoutClienteInput, NotasFiscalCabecalhoUncheckedCreateWithoutClienteInput>
  }

  export type NotasFiscalCabecalhoCreateManyClienteInputEnvelope = {
    data: NotasFiscalCabecalhoCreateManyClienteInput | NotasFiscalCabecalhoCreateManyClienteInput[]
    skipDuplicates?: boolean
  }

  export type NotasFiscalCabecalhoUpsertWithWhereUniqueWithoutClienteInput = {
    where: NotasFiscalCabecalhoWhereUniqueInput
    update: XOR<NotasFiscalCabecalhoUpdateWithoutClienteInput, NotasFiscalCabecalhoUncheckedUpdateWithoutClienteInput>
    create: XOR<NotasFiscalCabecalhoCreateWithoutClienteInput, NotasFiscalCabecalhoUncheckedCreateWithoutClienteInput>
  }

  export type NotasFiscalCabecalhoUpdateWithWhereUniqueWithoutClienteInput = {
    where: NotasFiscalCabecalhoWhereUniqueInput
    data: XOR<NotasFiscalCabecalhoUpdateWithoutClienteInput, NotasFiscalCabecalhoUncheckedUpdateWithoutClienteInput>
  }

  export type NotasFiscalCabecalhoUpdateManyWithWhereWithoutClienteInput = {
    where: NotasFiscalCabecalhoScalarWhereInput
    data: XOR<NotasFiscalCabecalhoUpdateManyMutationInput, NotasFiscalCabecalhoUncheckedUpdateManyWithoutClienteInput>
  }

  export type NotasFiscalCabecalhoScalarWhereInput = {
    AND?: NotasFiscalCabecalhoScalarWhereInput | NotasFiscalCabecalhoScalarWhereInput[]
    OR?: NotasFiscalCabecalhoScalarWhereInput[]
    NOT?: NotasFiscalCabecalhoScalarWhereInput | NotasFiscalCabecalhoScalarWhereInput[]
    id?: IntFilter<"NotasFiscalCabecalho"> | number
    numeroNota?: IntFilter<"NotasFiscalCabecalho"> | number
    dataEmissao?: DateTimeFilter<"NotasFiscalCabecalho"> | Date | string
    valorTotal?: DecimalFilter<"NotasFiscalCabecalho"> | Decimal | DecimalJsLike | number | string
    filialId?: IntNullableFilter<"NotasFiscalCabecalho"> | number | null
    clienteId?: IntNullableFilter<"NotasFiscalCabecalho"> | number | null
    vendedorId?: IntNullableFilter<"NotasFiscalCabecalho"> | number | null
  }

  export type EmpresaCreateWithoutFiliaisInput = {
    razaoSocial: string
    nomeFantasia?: string | null
    cnpjMatriz: string
    inscricaoEstadual?: string | null
    cidade?: string | null
    estado?: string | null
    logradouro?: string | null
    numero?: string | null
    bairro?: string | null
    cep?: string | null
    telefone?: string | null
    email?: string | null
    ativo?: boolean
    dataCriacao?: Date | string
    dataAtualizacao?: Date | string
  }

  export type EmpresaUncheckedCreateWithoutFiliaisInput = {
    id?: number
    razaoSocial: string
    nomeFantasia?: string | null
    cnpjMatriz: string
    inscricaoEstadual?: string | null
    cidade?: string | null
    estado?: string | null
    logradouro?: string | null
    numero?: string | null
    bairro?: string | null
    cep?: string | null
    telefone?: string | null
    email?: string | null
    ativo?: boolean
    dataCriacao?: Date | string
    dataAtualizacao?: Date | string
  }

  export type EmpresaCreateOrConnectWithoutFiliaisInput = {
    where: EmpresaWhereUniqueInput
    create: XOR<EmpresaCreateWithoutFiliaisInput, EmpresaUncheckedCreateWithoutFiliaisInput>
  }

  export type NotasFiscalCabecalhoCreateWithoutFilialInput = {
    numeroNota: number
    dataEmissao: Date | string
    valorTotal: Decimal | DecimalJsLike | number | string
    cliente?: ClienteCreateNestedOneWithoutNotasFiscaisInput
    vendedor?: VendedorCreateNestedOneWithoutNotasFiscaisInput
    itens?: NotaFiscalItemCreateNestedManyWithoutNotaFiscalInput
  }

  export type NotasFiscalCabecalhoUncheckedCreateWithoutFilialInput = {
    id?: number
    numeroNota: number
    dataEmissao: Date | string
    valorTotal: Decimal | DecimalJsLike | number | string
    clienteId?: number | null
    vendedorId?: number | null
    itens?: NotaFiscalItemUncheckedCreateNestedManyWithoutNotaFiscalInput
  }

  export type NotasFiscalCabecalhoCreateOrConnectWithoutFilialInput = {
    where: NotasFiscalCabecalhoWhereUniqueInput
    create: XOR<NotasFiscalCabecalhoCreateWithoutFilialInput, NotasFiscalCabecalhoUncheckedCreateWithoutFilialInput>
  }

  export type NotasFiscalCabecalhoCreateManyFilialInputEnvelope = {
    data: NotasFiscalCabecalhoCreateManyFilialInput | NotasFiscalCabecalhoCreateManyFilialInput[]
    skipDuplicates?: boolean
  }

  export type VendedorCreateWithoutFilialInput = {
    nome: string
    cpf: string
    notasFiscais?: NotasFiscalCabecalhoCreateNestedManyWithoutVendedorInput
  }

  export type VendedorUncheckedCreateWithoutFilialInput = {
    id?: number
    nome: string
    cpf: string
    notasFiscais?: NotasFiscalCabecalhoUncheckedCreateNestedManyWithoutVendedorInput
  }

  export type VendedorCreateOrConnectWithoutFilialInput = {
    where: VendedorWhereUniqueInput
    create: XOR<VendedorCreateWithoutFilialInput, VendedorUncheckedCreateWithoutFilialInput>
  }

  export type VendedorCreateManyFilialInputEnvelope = {
    data: VendedorCreateManyFilialInput | VendedorCreateManyFilialInput[]
    skipDuplicates?: boolean
  }

  export type RfvParameterSetCreateWithoutFilialInput = {
    name: string
    strategy?: $Enums.RfvStrategy
    windowDays?: number
    weights: JsonNullValueInput | InputJsonValue
    ruleRecency: JsonNullValueInput | InputJsonValue
    ruleFrequency: JsonNullValueInput | InputJsonValue
    ruleValue: JsonNullValueInput | InputJsonValue
    effectiveFrom: Date | string
    effectiveTo?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    calculationStrategy?: $Enums.CalculationStrategy
    classRanges?: NullableJsonNullValueInput | InputJsonValue
    conditionalRules?: NullableJsonNullValueInput | InputJsonValue
    segments?: RfvSegmentCreateNestedManyWithoutParameterSetInput
  }

  export type RfvParameterSetUncheckedCreateWithoutFilialInput = {
    id?: number
    name: string
    strategy?: $Enums.RfvStrategy
    windowDays?: number
    weights: JsonNullValueInput | InputJsonValue
    ruleRecency: JsonNullValueInput | InputJsonValue
    ruleFrequency: JsonNullValueInput | InputJsonValue
    ruleValue: JsonNullValueInput | InputJsonValue
    effectiveFrom: Date | string
    effectiveTo?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    calculationStrategy?: $Enums.CalculationStrategy
    classRanges?: NullableJsonNullValueInput | InputJsonValue
    conditionalRules?: NullableJsonNullValueInput | InputJsonValue
    segments?: RfvSegmentUncheckedCreateNestedManyWithoutParameterSetInput
  }

  export type RfvParameterSetCreateOrConnectWithoutFilialInput = {
    where: RfvParameterSetWhereUniqueInput
    create: XOR<RfvParameterSetCreateWithoutFilialInput, RfvParameterSetUncheckedCreateWithoutFilialInput>
  }

  export type RfvParameterSetCreateManyFilialInputEnvelope = {
    data: RfvParameterSetCreateManyFilialInput | RfvParameterSetCreateManyFilialInput[]
    skipDuplicates?: boolean
  }

  export type MaquinaEstoqueCreateWithoutFilialInput = {
    Chassi: string
    Status?: string | null
    produto: ProdutoCreateNestedOneWithoutMaquinasEstoqueInput
    Notas_Fiscais_Itens?: NotaFiscalItemCreateNestedManyWithoutMaquinas_EstoqueInput
  }

  export type MaquinaEstoqueUncheckedCreateWithoutFilialInput = {
    Chassi: string
    produtoId: number
    Status?: string | null
    Notas_Fiscais_Itens?: NotaFiscalItemUncheckedCreateNestedManyWithoutMaquinas_EstoqueInput
  }

  export type MaquinaEstoqueCreateOrConnectWithoutFilialInput = {
    where: MaquinaEstoqueWhereUniqueInput
    create: XOR<MaquinaEstoqueCreateWithoutFilialInput, MaquinaEstoqueUncheckedCreateWithoutFilialInput>
  }

  export type MaquinaEstoqueCreateManyFilialInputEnvelope = {
    data: MaquinaEstoqueCreateManyFilialInput | MaquinaEstoqueCreateManyFilialInput[]
    skipDuplicates?: boolean
  }

  export type EmpresaUpsertWithoutFiliaisInput = {
    update: XOR<EmpresaUpdateWithoutFiliaisInput, EmpresaUncheckedUpdateWithoutFiliaisInput>
    create: XOR<EmpresaCreateWithoutFiliaisInput, EmpresaUncheckedCreateWithoutFiliaisInput>
    where?: EmpresaWhereInput
  }

  export type EmpresaUpdateToOneWithWhereWithoutFiliaisInput = {
    where?: EmpresaWhereInput
    data: XOR<EmpresaUpdateWithoutFiliaisInput, EmpresaUncheckedUpdateWithoutFiliaisInput>
  }

  export type EmpresaUpdateWithoutFiliaisInput = {
    razaoSocial?: StringFieldUpdateOperationsInput | string
    nomeFantasia?: NullableStringFieldUpdateOperationsInput | string | null
    cnpjMatriz?: StringFieldUpdateOperationsInput | string
    inscricaoEstadual?: NullableStringFieldUpdateOperationsInput | string | null
    cidade?: NullableStringFieldUpdateOperationsInput | string | null
    estado?: NullableStringFieldUpdateOperationsInput | string | null
    logradouro?: NullableStringFieldUpdateOperationsInput | string | null
    numero?: NullableStringFieldUpdateOperationsInput | string | null
    bairro?: NullableStringFieldUpdateOperationsInput | string | null
    cep?: NullableStringFieldUpdateOperationsInput | string | null
    telefone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    ativo?: BoolFieldUpdateOperationsInput | boolean
    dataCriacao?: DateTimeFieldUpdateOperationsInput | Date | string
    dataAtualizacao?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EmpresaUncheckedUpdateWithoutFiliaisInput = {
    id?: IntFieldUpdateOperationsInput | number
    razaoSocial?: StringFieldUpdateOperationsInput | string
    nomeFantasia?: NullableStringFieldUpdateOperationsInput | string | null
    cnpjMatriz?: StringFieldUpdateOperationsInput | string
    inscricaoEstadual?: NullableStringFieldUpdateOperationsInput | string | null
    cidade?: NullableStringFieldUpdateOperationsInput | string | null
    estado?: NullableStringFieldUpdateOperationsInput | string | null
    logradouro?: NullableStringFieldUpdateOperationsInput | string | null
    numero?: NullableStringFieldUpdateOperationsInput | string | null
    bairro?: NullableStringFieldUpdateOperationsInput | string | null
    cep?: NullableStringFieldUpdateOperationsInput | string | null
    telefone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    ativo?: BoolFieldUpdateOperationsInput | boolean
    dataCriacao?: DateTimeFieldUpdateOperationsInput | Date | string
    dataAtualizacao?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotasFiscalCabecalhoUpsertWithWhereUniqueWithoutFilialInput = {
    where: NotasFiscalCabecalhoWhereUniqueInput
    update: XOR<NotasFiscalCabecalhoUpdateWithoutFilialInput, NotasFiscalCabecalhoUncheckedUpdateWithoutFilialInput>
    create: XOR<NotasFiscalCabecalhoCreateWithoutFilialInput, NotasFiscalCabecalhoUncheckedCreateWithoutFilialInput>
  }

  export type NotasFiscalCabecalhoUpdateWithWhereUniqueWithoutFilialInput = {
    where: NotasFiscalCabecalhoWhereUniqueInput
    data: XOR<NotasFiscalCabecalhoUpdateWithoutFilialInput, NotasFiscalCabecalhoUncheckedUpdateWithoutFilialInput>
  }

  export type NotasFiscalCabecalhoUpdateManyWithWhereWithoutFilialInput = {
    where: NotasFiscalCabecalhoScalarWhereInput
    data: XOR<NotasFiscalCabecalhoUpdateManyMutationInput, NotasFiscalCabecalhoUncheckedUpdateManyWithoutFilialInput>
  }

  export type VendedorUpsertWithWhereUniqueWithoutFilialInput = {
    where: VendedorWhereUniqueInput
    update: XOR<VendedorUpdateWithoutFilialInput, VendedorUncheckedUpdateWithoutFilialInput>
    create: XOR<VendedorCreateWithoutFilialInput, VendedorUncheckedCreateWithoutFilialInput>
  }

  export type VendedorUpdateWithWhereUniqueWithoutFilialInput = {
    where: VendedorWhereUniqueInput
    data: XOR<VendedorUpdateWithoutFilialInput, VendedorUncheckedUpdateWithoutFilialInput>
  }

  export type VendedorUpdateManyWithWhereWithoutFilialInput = {
    where: VendedorScalarWhereInput
    data: XOR<VendedorUpdateManyMutationInput, VendedorUncheckedUpdateManyWithoutFilialInput>
  }

  export type VendedorScalarWhereInput = {
    AND?: VendedorScalarWhereInput | VendedorScalarWhereInput[]
    OR?: VendedorScalarWhereInput[]
    NOT?: VendedorScalarWhereInput | VendedorScalarWhereInput[]
    id?: IntFilter<"Vendedor"> | number
    nome?: StringFilter<"Vendedor"> | string
    cpf?: StringFilter<"Vendedor"> | string
    filialId?: IntNullableFilter<"Vendedor"> | number | null
  }

  export type RfvParameterSetUpsertWithWhereUniqueWithoutFilialInput = {
    where: RfvParameterSetWhereUniqueInput
    update: XOR<RfvParameterSetUpdateWithoutFilialInput, RfvParameterSetUncheckedUpdateWithoutFilialInput>
    create: XOR<RfvParameterSetCreateWithoutFilialInput, RfvParameterSetUncheckedCreateWithoutFilialInput>
  }

  export type RfvParameterSetUpdateWithWhereUniqueWithoutFilialInput = {
    where: RfvParameterSetWhereUniqueInput
    data: XOR<RfvParameterSetUpdateWithoutFilialInput, RfvParameterSetUncheckedUpdateWithoutFilialInput>
  }

  export type RfvParameterSetUpdateManyWithWhereWithoutFilialInput = {
    where: RfvParameterSetScalarWhereInput
    data: XOR<RfvParameterSetUpdateManyMutationInput, RfvParameterSetUncheckedUpdateManyWithoutFilialInput>
  }

  export type RfvParameterSetScalarWhereInput = {
    AND?: RfvParameterSetScalarWhereInput | RfvParameterSetScalarWhereInput[]
    OR?: RfvParameterSetScalarWhereInput[]
    NOT?: RfvParameterSetScalarWhereInput | RfvParameterSetScalarWhereInput[]
    id?: IntFilter<"RfvParameterSet"> | number
    filialId?: IntNullableFilter<"RfvParameterSet"> | number | null
    name?: StringFilter<"RfvParameterSet"> | string
    strategy?: EnumRfvStrategyFilter<"RfvParameterSet"> | $Enums.RfvStrategy
    windowDays?: IntFilter<"RfvParameterSet"> | number
    weights?: JsonFilter<"RfvParameterSet">
    ruleRecency?: JsonFilter<"RfvParameterSet">
    ruleFrequency?: JsonFilter<"RfvParameterSet">
    ruleValue?: JsonFilter<"RfvParameterSet">
    effectiveFrom?: DateTimeFilter<"RfvParameterSet"> | Date | string
    effectiveTo?: DateTimeNullableFilter<"RfvParameterSet"> | Date | string | null
    createdAt?: DateTimeFilter<"RfvParameterSet"> | Date | string
    updatedAt?: DateTimeFilter<"RfvParameterSet"> | Date | string
    calculationStrategy?: EnumCalculationStrategyFilter<"RfvParameterSet"> | $Enums.CalculationStrategy
    classRanges?: JsonNullableFilter<"RfvParameterSet">
    conditionalRules?: JsonNullableFilter<"RfvParameterSet">
  }

  export type MaquinaEstoqueUpsertWithWhereUniqueWithoutFilialInput = {
    where: MaquinaEstoqueWhereUniqueInput
    update: XOR<MaquinaEstoqueUpdateWithoutFilialInput, MaquinaEstoqueUncheckedUpdateWithoutFilialInput>
    create: XOR<MaquinaEstoqueCreateWithoutFilialInput, MaquinaEstoqueUncheckedCreateWithoutFilialInput>
  }

  export type MaquinaEstoqueUpdateWithWhereUniqueWithoutFilialInput = {
    where: MaquinaEstoqueWhereUniqueInput
    data: XOR<MaquinaEstoqueUpdateWithoutFilialInput, MaquinaEstoqueUncheckedUpdateWithoutFilialInput>
  }

  export type MaquinaEstoqueUpdateManyWithWhereWithoutFilialInput = {
    where: MaquinaEstoqueScalarWhereInput
    data: XOR<MaquinaEstoqueUpdateManyMutationInput, MaquinaEstoqueUncheckedUpdateManyWithoutFilialInput>
  }

  export type MaquinaEstoqueScalarWhereInput = {
    AND?: MaquinaEstoqueScalarWhereInput | MaquinaEstoqueScalarWhereInput[]
    OR?: MaquinaEstoqueScalarWhereInput[]
    NOT?: MaquinaEstoqueScalarWhereInput | MaquinaEstoqueScalarWhereInput[]
    Chassi?: StringFilter<"MaquinaEstoque"> | string
    produtoId?: IntFilter<"MaquinaEstoque"> | number
    filialId?: IntNullableFilter<"MaquinaEstoque"> | number | null
    Status?: StringNullableFilter<"MaquinaEstoque"> | string | null
  }

  export type NotasFiscalCabecalhoCreateWithoutVendedorInput = {
    numeroNota: number
    dataEmissao: Date | string
    valorTotal: Decimal | DecimalJsLike | number | string
    filial?: FilialCreateNestedOneWithoutNotasFiscaisInput
    cliente?: ClienteCreateNestedOneWithoutNotasFiscaisInput
    itens?: NotaFiscalItemCreateNestedManyWithoutNotaFiscalInput
  }

  export type NotasFiscalCabecalhoUncheckedCreateWithoutVendedorInput = {
    id?: number
    numeroNota: number
    dataEmissao: Date | string
    valorTotal: Decimal | DecimalJsLike | number | string
    filialId?: number | null
    clienteId?: number | null
    itens?: NotaFiscalItemUncheckedCreateNestedManyWithoutNotaFiscalInput
  }

  export type NotasFiscalCabecalhoCreateOrConnectWithoutVendedorInput = {
    where: NotasFiscalCabecalhoWhereUniqueInput
    create: XOR<NotasFiscalCabecalhoCreateWithoutVendedorInput, NotasFiscalCabecalhoUncheckedCreateWithoutVendedorInput>
  }

  export type NotasFiscalCabecalhoCreateManyVendedorInputEnvelope = {
    data: NotasFiscalCabecalhoCreateManyVendedorInput | NotasFiscalCabecalhoCreateManyVendedorInput[]
    skipDuplicates?: boolean
  }

  export type FilialCreateWithoutVendedoresInput = {
    nome: string
    cnpj: string
    cidade?: string | null
    estado?: string | null
    empresa: EmpresaCreateNestedOneWithoutFiliaisInput
    notasFiscais?: NotasFiscalCabecalhoCreateNestedManyWithoutFilialInput
    rfvParameterSets?: RfvParameterSetCreateNestedManyWithoutFilialInput
    maquinasEstoque?: MaquinaEstoqueCreateNestedManyWithoutFilialInput
  }

  export type FilialUncheckedCreateWithoutVendedoresInput = {
    id?: number
    empresaId: number
    nome: string
    cnpj: string
    cidade?: string | null
    estado?: string | null
    notasFiscais?: NotasFiscalCabecalhoUncheckedCreateNestedManyWithoutFilialInput
    rfvParameterSets?: RfvParameterSetUncheckedCreateNestedManyWithoutFilialInput
    maquinasEstoque?: MaquinaEstoqueUncheckedCreateNestedManyWithoutFilialInput
  }

  export type FilialCreateOrConnectWithoutVendedoresInput = {
    where: FilialWhereUniqueInput
    create: XOR<FilialCreateWithoutVendedoresInput, FilialUncheckedCreateWithoutVendedoresInput>
  }

  export type NotasFiscalCabecalhoUpsertWithWhereUniqueWithoutVendedorInput = {
    where: NotasFiscalCabecalhoWhereUniqueInput
    update: XOR<NotasFiscalCabecalhoUpdateWithoutVendedorInput, NotasFiscalCabecalhoUncheckedUpdateWithoutVendedorInput>
    create: XOR<NotasFiscalCabecalhoCreateWithoutVendedorInput, NotasFiscalCabecalhoUncheckedCreateWithoutVendedorInput>
  }

  export type NotasFiscalCabecalhoUpdateWithWhereUniqueWithoutVendedorInput = {
    where: NotasFiscalCabecalhoWhereUniqueInput
    data: XOR<NotasFiscalCabecalhoUpdateWithoutVendedorInput, NotasFiscalCabecalhoUncheckedUpdateWithoutVendedorInput>
  }

  export type NotasFiscalCabecalhoUpdateManyWithWhereWithoutVendedorInput = {
    where: NotasFiscalCabecalhoScalarWhereInput
    data: XOR<NotasFiscalCabecalhoUpdateManyMutationInput, NotasFiscalCabecalhoUncheckedUpdateManyWithoutVendedorInput>
  }

  export type FilialUpsertWithoutVendedoresInput = {
    update: XOR<FilialUpdateWithoutVendedoresInput, FilialUncheckedUpdateWithoutVendedoresInput>
    create: XOR<FilialCreateWithoutVendedoresInput, FilialUncheckedCreateWithoutVendedoresInput>
    where?: FilialWhereInput
  }

  export type FilialUpdateToOneWithWhereWithoutVendedoresInput = {
    where?: FilialWhereInput
    data: XOR<FilialUpdateWithoutVendedoresInput, FilialUncheckedUpdateWithoutVendedoresInput>
  }

  export type FilialUpdateWithoutVendedoresInput = {
    nome?: StringFieldUpdateOperationsInput | string
    cnpj?: StringFieldUpdateOperationsInput | string
    cidade?: NullableStringFieldUpdateOperationsInput | string | null
    estado?: NullableStringFieldUpdateOperationsInput | string | null
    empresa?: EmpresaUpdateOneRequiredWithoutFiliaisNestedInput
    notasFiscais?: NotasFiscalCabecalhoUpdateManyWithoutFilialNestedInput
    rfvParameterSets?: RfvParameterSetUpdateManyWithoutFilialNestedInput
    maquinasEstoque?: MaquinaEstoqueUpdateManyWithoutFilialNestedInput
  }

  export type FilialUncheckedUpdateWithoutVendedoresInput = {
    id?: IntFieldUpdateOperationsInput | number
    empresaId?: IntFieldUpdateOperationsInput | number
    nome?: StringFieldUpdateOperationsInput | string
    cnpj?: StringFieldUpdateOperationsInput | string
    cidade?: NullableStringFieldUpdateOperationsInput | string | null
    estado?: NullableStringFieldUpdateOperationsInput | string | null
    notasFiscais?: NotasFiscalCabecalhoUncheckedUpdateManyWithoutFilialNestedInput
    rfvParameterSets?: RfvParameterSetUncheckedUpdateManyWithoutFilialNestedInput
    maquinasEstoque?: MaquinaEstoqueUncheckedUpdateManyWithoutFilialNestedInput
  }

  export type MaquinaEstoqueCreateWithoutProdutoInput = {
    Chassi: string
    Status?: string | null
    filial?: FilialCreateNestedOneWithoutMaquinasEstoqueInput
    Notas_Fiscais_Itens?: NotaFiscalItemCreateNestedManyWithoutMaquinas_EstoqueInput
  }

  export type MaquinaEstoqueUncheckedCreateWithoutProdutoInput = {
    Chassi: string
    filialId?: number | null
    Status?: string | null
    Notas_Fiscais_Itens?: NotaFiscalItemUncheckedCreateNestedManyWithoutMaquinas_EstoqueInput
  }

  export type MaquinaEstoqueCreateOrConnectWithoutProdutoInput = {
    where: MaquinaEstoqueWhereUniqueInput
    create: XOR<MaquinaEstoqueCreateWithoutProdutoInput, MaquinaEstoqueUncheckedCreateWithoutProdutoInput>
  }

  export type MaquinaEstoqueCreateManyProdutoInputEnvelope = {
    data: MaquinaEstoqueCreateManyProdutoInput | MaquinaEstoqueCreateManyProdutoInput[]
    skipDuplicates?: boolean
  }

  export type NotaFiscalItemCreateWithoutProdutoInput = {
    Quantidade: Decimal | DecimalJsLike | number | string
    valorUnitario: Decimal | DecimalJsLike | number | string
    valorTotalItem: Decimal | DecimalJsLike | number | string
    Maquinas_Estoque?: MaquinaEstoqueCreateNestedOneWithoutNotas_Fiscais_ItensInput
    notaFiscal: NotasFiscalCabecalhoCreateNestedOneWithoutItensInput
  }

  export type NotaFiscalItemUncheckedCreateWithoutProdutoInput = {
    id?: number
    notaFiscalId: number
    Quantidade: Decimal | DecimalJsLike | number | string
    valorUnitario: Decimal | DecimalJsLike | number | string
    valorTotalItem: Decimal | DecimalJsLike | number | string
    Chassi?: string | null
  }

  export type NotaFiscalItemCreateOrConnectWithoutProdutoInput = {
    where: NotaFiscalItemWhereUniqueInput
    create: XOR<NotaFiscalItemCreateWithoutProdutoInput, NotaFiscalItemUncheckedCreateWithoutProdutoInput>
  }

  export type NotaFiscalItemCreateManyProdutoInputEnvelope = {
    data: NotaFiscalItemCreateManyProdutoInput | NotaFiscalItemCreateManyProdutoInput[]
    skipDuplicates?: boolean
  }

  export type MaquinaEstoqueUpsertWithWhereUniqueWithoutProdutoInput = {
    where: MaquinaEstoqueWhereUniqueInput
    update: XOR<MaquinaEstoqueUpdateWithoutProdutoInput, MaquinaEstoqueUncheckedUpdateWithoutProdutoInput>
    create: XOR<MaquinaEstoqueCreateWithoutProdutoInput, MaquinaEstoqueUncheckedCreateWithoutProdutoInput>
  }

  export type MaquinaEstoqueUpdateWithWhereUniqueWithoutProdutoInput = {
    where: MaquinaEstoqueWhereUniqueInput
    data: XOR<MaquinaEstoqueUpdateWithoutProdutoInput, MaquinaEstoqueUncheckedUpdateWithoutProdutoInput>
  }

  export type MaquinaEstoqueUpdateManyWithWhereWithoutProdutoInput = {
    where: MaquinaEstoqueScalarWhereInput
    data: XOR<MaquinaEstoqueUpdateManyMutationInput, MaquinaEstoqueUncheckedUpdateManyWithoutProdutoInput>
  }

  export type NotaFiscalItemUpsertWithWhereUniqueWithoutProdutoInput = {
    where: NotaFiscalItemWhereUniqueInput
    update: XOR<NotaFiscalItemUpdateWithoutProdutoInput, NotaFiscalItemUncheckedUpdateWithoutProdutoInput>
    create: XOR<NotaFiscalItemCreateWithoutProdutoInput, NotaFiscalItemUncheckedCreateWithoutProdutoInput>
  }

  export type NotaFiscalItemUpdateWithWhereUniqueWithoutProdutoInput = {
    where: NotaFiscalItemWhereUniqueInput
    data: XOR<NotaFiscalItemUpdateWithoutProdutoInput, NotaFiscalItemUncheckedUpdateWithoutProdutoInput>
  }

  export type NotaFiscalItemUpdateManyWithWhereWithoutProdutoInput = {
    where: NotaFiscalItemScalarWhereInput
    data: XOR<NotaFiscalItemUpdateManyMutationInput, NotaFiscalItemUncheckedUpdateManyWithoutProdutoInput>
  }

  export type NotaFiscalItemScalarWhereInput = {
    AND?: NotaFiscalItemScalarWhereInput | NotaFiscalItemScalarWhereInput[]
    OR?: NotaFiscalItemScalarWhereInput[]
    NOT?: NotaFiscalItemScalarWhereInput | NotaFiscalItemScalarWhereInput[]
    id?: IntFilter<"NotaFiscalItem"> | number
    notaFiscalId?: IntFilter<"NotaFiscalItem"> | number
    produtoId?: IntFilter<"NotaFiscalItem"> | number
    Quantidade?: DecimalFilter<"NotaFiscalItem"> | Decimal | DecimalJsLike | number | string
    valorUnitario?: DecimalFilter<"NotaFiscalItem"> | Decimal | DecimalJsLike | number | string
    valorTotalItem?: DecimalFilter<"NotaFiscalItem"> | Decimal | DecimalJsLike | number | string
    Chassi?: StringNullableFilter<"NotaFiscalItem"> | string | null
  }

  export type ProdutoCreateWithoutMaquinasEstoqueInput = {
    descricao: string
    tipo: string
    preco: Decimal | DecimalJsLike | number | string
    notasFiscaisItens?: NotaFiscalItemCreateNestedManyWithoutProdutoInput
  }

  export type ProdutoUncheckedCreateWithoutMaquinasEstoqueInput = {
    id?: number
    descricao: string
    tipo: string
    preco: Decimal | DecimalJsLike | number | string
    notasFiscaisItens?: NotaFiscalItemUncheckedCreateNestedManyWithoutProdutoInput
  }

  export type ProdutoCreateOrConnectWithoutMaquinasEstoqueInput = {
    where: ProdutoWhereUniqueInput
    create: XOR<ProdutoCreateWithoutMaquinasEstoqueInput, ProdutoUncheckedCreateWithoutMaquinasEstoqueInput>
  }

  export type FilialCreateWithoutMaquinasEstoqueInput = {
    nome: string
    cnpj: string
    cidade?: string | null
    estado?: string | null
    empresa: EmpresaCreateNestedOneWithoutFiliaisInput
    notasFiscais?: NotasFiscalCabecalhoCreateNestedManyWithoutFilialInput
    vendedores?: VendedorCreateNestedManyWithoutFilialInput
    rfvParameterSets?: RfvParameterSetCreateNestedManyWithoutFilialInput
  }

  export type FilialUncheckedCreateWithoutMaquinasEstoqueInput = {
    id?: number
    empresaId: number
    nome: string
    cnpj: string
    cidade?: string | null
    estado?: string | null
    notasFiscais?: NotasFiscalCabecalhoUncheckedCreateNestedManyWithoutFilialInput
    vendedores?: VendedorUncheckedCreateNestedManyWithoutFilialInput
    rfvParameterSets?: RfvParameterSetUncheckedCreateNestedManyWithoutFilialInput
  }

  export type FilialCreateOrConnectWithoutMaquinasEstoqueInput = {
    where: FilialWhereUniqueInput
    create: XOR<FilialCreateWithoutMaquinasEstoqueInput, FilialUncheckedCreateWithoutMaquinasEstoqueInput>
  }

  export type NotaFiscalItemCreateWithoutMaquinas_EstoqueInput = {
    Quantidade: Decimal | DecimalJsLike | number | string
    valorUnitario: Decimal | DecimalJsLike | number | string
    valorTotalItem: Decimal | DecimalJsLike | number | string
    notaFiscal: NotasFiscalCabecalhoCreateNestedOneWithoutItensInput
    produto: ProdutoCreateNestedOneWithoutNotasFiscaisItensInput
  }

  export type NotaFiscalItemUncheckedCreateWithoutMaquinas_EstoqueInput = {
    id?: number
    notaFiscalId: number
    produtoId: number
    Quantidade: Decimal | DecimalJsLike | number | string
    valorUnitario: Decimal | DecimalJsLike | number | string
    valorTotalItem: Decimal | DecimalJsLike | number | string
  }

  export type NotaFiscalItemCreateOrConnectWithoutMaquinas_EstoqueInput = {
    where: NotaFiscalItemWhereUniqueInput
    create: XOR<NotaFiscalItemCreateWithoutMaquinas_EstoqueInput, NotaFiscalItemUncheckedCreateWithoutMaquinas_EstoqueInput>
  }

  export type NotaFiscalItemCreateManyMaquinas_EstoqueInputEnvelope = {
    data: NotaFiscalItemCreateManyMaquinas_EstoqueInput | NotaFiscalItemCreateManyMaquinas_EstoqueInput[]
    skipDuplicates?: boolean
  }

  export type ProdutoUpsertWithoutMaquinasEstoqueInput = {
    update: XOR<ProdutoUpdateWithoutMaquinasEstoqueInput, ProdutoUncheckedUpdateWithoutMaquinasEstoqueInput>
    create: XOR<ProdutoCreateWithoutMaquinasEstoqueInput, ProdutoUncheckedCreateWithoutMaquinasEstoqueInput>
    where?: ProdutoWhereInput
  }

  export type ProdutoUpdateToOneWithWhereWithoutMaquinasEstoqueInput = {
    where?: ProdutoWhereInput
    data: XOR<ProdutoUpdateWithoutMaquinasEstoqueInput, ProdutoUncheckedUpdateWithoutMaquinasEstoqueInput>
  }

  export type ProdutoUpdateWithoutMaquinasEstoqueInput = {
    descricao?: StringFieldUpdateOperationsInput | string
    tipo?: StringFieldUpdateOperationsInput | string
    preco?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    notasFiscaisItens?: NotaFiscalItemUpdateManyWithoutProdutoNestedInput
  }

  export type ProdutoUncheckedUpdateWithoutMaquinasEstoqueInput = {
    id?: IntFieldUpdateOperationsInput | number
    descricao?: StringFieldUpdateOperationsInput | string
    tipo?: StringFieldUpdateOperationsInput | string
    preco?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    notasFiscaisItens?: NotaFiscalItemUncheckedUpdateManyWithoutProdutoNestedInput
  }

  export type FilialUpsertWithoutMaquinasEstoqueInput = {
    update: XOR<FilialUpdateWithoutMaquinasEstoqueInput, FilialUncheckedUpdateWithoutMaquinasEstoqueInput>
    create: XOR<FilialCreateWithoutMaquinasEstoqueInput, FilialUncheckedCreateWithoutMaquinasEstoqueInput>
    where?: FilialWhereInput
  }

  export type FilialUpdateToOneWithWhereWithoutMaquinasEstoqueInput = {
    where?: FilialWhereInput
    data: XOR<FilialUpdateWithoutMaquinasEstoqueInput, FilialUncheckedUpdateWithoutMaquinasEstoqueInput>
  }

  export type FilialUpdateWithoutMaquinasEstoqueInput = {
    nome?: StringFieldUpdateOperationsInput | string
    cnpj?: StringFieldUpdateOperationsInput | string
    cidade?: NullableStringFieldUpdateOperationsInput | string | null
    estado?: NullableStringFieldUpdateOperationsInput | string | null
    empresa?: EmpresaUpdateOneRequiredWithoutFiliaisNestedInput
    notasFiscais?: NotasFiscalCabecalhoUpdateManyWithoutFilialNestedInput
    vendedores?: VendedorUpdateManyWithoutFilialNestedInput
    rfvParameterSets?: RfvParameterSetUpdateManyWithoutFilialNestedInput
  }

  export type FilialUncheckedUpdateWithoutMaquinasEstoqueInput = {
    id?: IntFieldUpdateOperationsInput | number
    empresaId?: IntFieldUpdateOperationsInput | number
    nome?: StringFieldUpdateOperationsInput | string
    cnpj?: StringFieldUpdateOperationsInput | string
    cidade?: NullableStringFieldUpdateOperationsInput | string | null
    estado?: NullableStringFieldUpdateOperationsInput | string | null
    notasFiscais?: NotasFiscalCabecalhoUncheckedUpdateManyWithoutFilialNestedInput
    vendedores?: VendedorUncheckedUpdateManyWithoutFilialNestedInput
    rfvParameterSets?: RfvParameterSetUncheckedUpdateManyWithoutFilialNestedInput
  }

  export type NotaFiscalItemUpsertWithWhereUniqueWithoutMaquinas_EstoqueInput = {
    where: NotaFiscalItemWhereUniqueInput
    update: XOR<NotaFiscalItemUpdateWithoutMaquinas_EstoqueInput, NotaFiscalItemUncheckedUpdateWithoutMaquinas_EstoqueInput>
    create: XOR<NotaFiscalItemCreateWithoutMaquinas_EstoqueInput, NotaFiscalItemUncheckedCreateWithoutMaquinas_EstoqueInput>
  }

  export type NotaFiscalItemUpdateWithWhereUniqueWithoutMaquinas_EstoqueInput = {
    where: NotaFiscalItemWhereUniqueInput
    data: XOR<NotaFiscalItemUpdateWithoutMaquinas_EstoqueInput, NotaFiscalItemUncheckedUpdateWithoutMaquinas_EstoqueInput>
  }

  export type NotaFiscalItemUpdateManyWithWhereWithoutMaquinas_EstoqueInput = {
    where: NotaFiscalItemScalarWhereInput
    data: XOR<NotaFiscalItemUpdateManyMutationInput, NotaFiscalItemUncheckedUpdateManyWithoutMaquinas_EstoqueInput>
  }

  export type FilialCreateWithoutNotasFiscaisInput = {
    nome: string
    cnpj: string
    cidade?: string | null
    estado?: string | null
    empresa: EmpresaCreateNestedOneWithoutFiliaisInput
    vendedores?: VendedorCreateNestedManyWithoutFilialInput
    rfvParameterSets?: RfvParameterSetCreateNestedManyWithoutFilialInput
    maquinasEstoque?: MaquinaEstoqueCreateNestedManyWithoutFilialInput
  }

  export type FilialUncheckedCreateWithoutNotasFiscaisInput = {
    id?: number
    empresaId: number
    nome: string
    cnpj: string
    cidade?: string | null
    estado?: string | null
    vendedores?: VendedorUncheckedCreateNestedManyWithoutFilialInput
    rfvParameterSets?: RfvParameterSetUncheckedCreateNestedManyWithoutFilialInput
    maquinasEstoque?: MaquinaEstoqueUncheckedCreateNestedManyWithoutFilialInput
  }

  export type FilialCreateOrConnectWithoutNotasFiscaisInput = {
    where: FilialWhereUniqueInput
    create: XOR<FilialCreateWithoutNotasFiscaisInput, FilialUncheckedCreateWithoutNotasFiscaisInput>
  }

  export type ClienteCreateWithoutNotasFiscaisInput = {
    nome: string
    cpfCnpj: string
    cidade?: string | null
    estado?: string | null
    logradouro?: string | null
    numero?: string | null
    bairro?: string | null
    cep?: string | null
    telefone?: string | null
  }

  export type ClienteUncheckedCreateWithoutNotasFiscaisInput = {
    id?: number
    nome: string
    cpfCnpj: string
    cidade?: string | null
    estado?: string | null
    logradouro?: string | null
    numero?: string | null
    bairro?: string | null
    cep?: string | null
    telefone?: string | null
  }

  export type ClienteCreateOrConnectWithoutNotasFiscaisInput = {
    where: ClienteWhereUniqueInput
    create: XOR<ClienteCreateWithoutNotasFiscaisInput, ClienteUncheckedCreateWithoutNotasFiscaisInput>
  }

  export type VendedorCreateWithoutNotasFiscaisInput = {
    nome: string
    cpf: string
    filial?: FilialCreateNestedOneWithoutVendedoresInput
  }

  export type VendedorUncheckedCreateWithoutNotasFiscaisInput = {
    id?: number
    nome: string
    cpf: string
    filialId?: number | null
  }

  export type VendedorCreateOrConnectWithoutNotasFiscaisInput = {
    where: VendedorWhereUniqueInput
    create: XOR<VendedorCreateWithoutNotasFiscaisInput, VendedorUncheckedCreateWithoutNotasFiscaisInput>
  }

  export type NotaFiscalItemCreateWithoutNotaFiscalInput = {
    Quantidade: Decimal | DecimalJsLike | number | string
    valorUnitario: Decimal | DecimalJsLike | number | string
    valorTotalItem: Decimal | DecimalJsLike | number | string
    Maquinas_Estoque?: MaquinaEstoqueCreateNestedOneWithoutNotas_Fiscais_ItensInput
    produto: ProdutoCreateNestedOneWithoutNotasFiscaisItensInput
  }

  export type NotaFiscalItemUncheckedCreateWithoutNotaFiscalInput = {
    id?: number
    produtoId: number
    Quantidade: Decimal | DecimalJsLike | number | string
    valorUnitario: Decimal | DecimalJsLike | number | string
    valorTotalItem: Decimal | DecimalJsLike | number | string
    Chassi?: string | null
  }

  export type NotaFiscalItemCreateOrConnectWithoutNotaFiscalInput = {
    where: NotaFiscalItemWhereUniqueInput
    create: XOR<NotaFiscalItemCreateWithoutNotaFiscalInput, NotaFiscalItemUncheckedCreateWithoutNotaFiscalInput>
  }

  export type NotaFiscalItemCreateManyNotaFiscalInputEnvelope = {
    data: NotaFiscalItemCreateManyNotaFiscalInput | NotaFiscalItemCreateManyNotaFiscalInput[]
    skipDuplicates?: boolean
  }

  export type FilialUpsertWithoutNotasFiscaisInput = {
    update: XOR<FilialUpdateWithoutNotasFiscaisInput, FilialUncheckedUpdateWithoutNotasFiscaisInput>
    create: XOR<FilialCreateWithoutNotasFiscaisInput, FilialUncheckedCreateWithoutNotasFiscaisInput>
    where?: FilialWhereInput
  }

  export type FilialUpdateToOneWithWhereWithoutNotasFiscaisInput = {
    where?: FilialWhereInput
    data: XOR<FilialUpdateWithoutNotasFiscaisInput, FilialUncheckedUpdateWithoutNotasFiscaisInput>
  }

  export type FilialUpdateWithoutNotasFiscaisInput = {
    nome?: StringFieldUpdateOperationsInput | string
    cnpj?: StringFieldUpdateOperationsInput | string
    cidade?: NullableStringFieldUpdateOperationsInput | string | null
    estado?: NullableStringFieldUpdateOperationsInput | string | null
    empresa?: EmpresaUpdateOneRequiredWithoutFiliaisNestedInput
    vendedores?: VendedorUpdateManyWithoutFilialNestedInput
    rfvParameterSets?: RfvParameterSetUpdateManyWithoutFilialNestedInput
    maquinasEstoque?: MaquinaEstoqueUpdateManyWithoutFilialNestedInput
  }

  export type FilialUncheckedUpdateWithoutNotasFiscaisInput = {
    id?: IntFieldUpdateOperationsInput | number
    empresaId?: IntFieldUpdateOperationsInput | number
    nome?: StringFieldUpdateOperationsInput | string
    cnpj?: StringFieldUpdateOperationsInput | string
    cidade?: NullableStringFieldUpdateOperationsInput | string | null
    estado?: NullableStringFieldUpdateOperationsInput | string | null
    vendedores?: VendedorUncheckedUpdateManyWithoutFilialNestedInput
    rfvParameterSets?: RfvParameterSetUncheckedUpdateManyWithoutFilialNestedInput
    maquinasEstoque?: MaquinaEstoqueUncheckedUpdateManyWithoutFilialNestedInput
  }

  export type ClienteUpsertWithoutNotasFiscaisInput = {
    update: XOR<ClienteUpdateWithoutNotasFiscaisInput, ClienteUncheckedUpdateWithoutNotasFiscaisInput>
    create: XOR<ClienteCreateWithoutNotasFiscaisInput, ClienteUncheckedCreateWithoutNotasFiscaisInput>
    where?: ClienteWhereInput
  }

  export type ClienteUpdateToOneWithWhereWithoutNotasFiscaisInput = {
    where?: ClienteWhereInput
    data: XOR<ClienteUpdateWithoutNotasFiscaisInput, ClienteUncheckedUpdateWithoutNotasFiscaisInput>
  }

  export type ClienteUpdateWithoutNotasFiscaisInput = {
    nome?: StringFieldUpdateOperationsInput | string
    cpfCnpj?: StringFieldUpdateOperationsInput | string
    cidade?: NullableStringFieldUpdateOperationsInput | string | null
    estado?: NullableStringFieldUpdateOperationsInput | string | null
    logradouro?: NullableStringFieldUpdateOperationsInput | string | null
    numero?: NullableStringFieldUpdateOperationsInput | string | null
    bairro?: NullableStringFieldUpdateOperationsInput | string | null
    cep?: NullableStringFieldUpdateOperationsInput | string | null
    telefone?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ClienteUncheckedUpdateWithoutNotasFiscaisInput = {
    id?: IntFieldUpdateOperationsInput | number
    nome?: StringFieldUpdateOperationsInput | string
    cpfCnpj?: StringFieldUpdateOperationsInput | string
    cidade?: NullableStringFieldUpdateOperationsInput | string | null
    estado?: NullableStringFieldUpdateOperationsInput | string | null
    logradouro?: NullableStringFieldUpdateOperationsInput | string | null
    numero?: NullableStringFieldUpdateOperationsInput | string | null
    bairro?: NullableStringFieldUpdateOperationsInput | string | null
    cep?: NullableStringFieldUpdateOperationsInput | string | null
    telefone?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type VendedorUpsertWithoutNotasFiscaisInput = {
    update: XOR<VendedorUpdateWithoutNotasFiscaisInput, VendedorUncheckedUpdateWithoutNotasFiscaisInput>
    create: XOR<VendedorCreateWithoutNotasFiscaisInput, VendedorUncheckedCreateWithoutNotasFiscaisInput>
    where?: VendedorWhereInput
  }

  export type VendedorUpdateToOneWithWhereWithoutNotasFiscaisInput = {
    where?: VendedorWhereInput
    data: XOR<VendedorUpdateWithoutNotasFiscaisInput, VendedorUncheckedUpdateWithoutNotasFiscaisInput>
  }

  export type VendedorUpdateWithoutNotasFiscaisInput = {
    nome?: StringFieldUpdateOperationsInput | string
    cpf?: StringFieldUpdateOperationsInput | string
    filial?: FilialUpdateOneWithoutVendedoresNestedInput
  }

  export type VendedorUncheckedUpdateWithoutNotasFiscaisInput = {
    id?: IntFieldUpdateOperationsInput | number
    nome?: StringFieldUpdateOperationsInput | string
    cpf?: StringFieldUpdateOperationsInput | string
    filialId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type NotaFiscalItemUpsertWithWhereUniqueWithoutNotaFiscalInput = {
    where: NotaFiscalItemWhereUniqueInput
    update: XOR<NotaFiscalItemUpdateWithoutNotaFiscalInput, NotaFiscalItemUncheckedUpdateWithoutNotaFiscalInput>
    create: XOR<NotaFiscalItemCreateWithoutNotaFiscalInput, NotaFiscalItemUncheckedCreateWithoutNotaFiscalInput>
  }

  export type NotaFiscalItemUpdateWithWhereUniqueWithoutNotaFiscalInput = {
    where: NotaFiscalItemWhereUniqueInput
    data: XOR<NotaFiscalItemUpdateWithoutNotaFiscalInput, NotaFiscalItemUncheckedUpdateWithoutNotaFiscalInput>
  }

  export type NotaFiscalItemUpdateManyWithWhereWithoutNotaFiscalInput = {
    where: NotaFiscalItemScalarWhereInput
    data: XOR<NotaFiscalItemUpdateManyMutationInput, NotaFiscalItemUncheckedUpdateManyWithoutNotaFiscalInput>
  }

  export type MaquinaEstoqueCreateWithoutNotas_Fiscais_ItensInput = {
    Chassi: string
    Status?: string | null
    produto: ProdutoCreateNestedOneWithoutMaquinasEstoqueInput
    filial?: FilialCreateNestedOneWithoutMaquinasEstoqueInput
  }

  export type MaquinaEstoqueUncheckedCreateWithoutNotas_Fiscais_ItensInput = {
    Chassi: string
    produtoId: number
    filialId?: number | null
    Status?: string | null
  }

  export type MaquinaEstoqueCreateOrConnectWithoutNotas_Fiscais_ItensInput = {
    where: MaquinaEstoqueWhereUniqueInput
    create: XOR<MaquinaEstoqueCreateWithoutNotas_Fiscais_ItensInput, MaquinaEstoqueUncheckedCreateWithoutNotas_Fiscais_ItensInput>
  }

  export type NotasFiscalCabecalhoCreateWithoutItensInput = {
    numeroNota: number
    dataEmissao: Date | string
    valorTotal: Decimal | DecimalJsLike | number | string
    filial?: FilialCreateNestedOneWithoutNotasFiscaisInput
    cliente?: ClienteCreateNestedOneWithoutNotasFiscaisInput
    vendedor?: VendedorCreateNestedOneWithoutNotasFiscaisInput
  }

  export type NotasFiscalCabecalhoUncheckedCreateWithoutItensInput = {
    id?: number
    numeroNota: number
    dataEmissao: Date | string
    valorTotal: Decimal | DecimalJsLike | number | string
    filialId?: number | null
    clienteId?: number | null
    vendedorId?: number | null
  }

  export type NotasFiscalCabecalhoCreateOrConnectWithoutItensInput = {
    where: NotasFiscalCabecalhoWhereUniqueInput
    create: XOR<NotasFiscalCabecalhoCreateWithoutItensInput, NotasFiscalCabecalhoUncheckedCreateWithoutItensInput>
  }

  export type ProdutoCreateWithoutNotasFiscaisItensInput = {
    descricao: string
    tipo: string
    preco: Decimal | DecimalJsLike | number | string
    maquinasEstoque?: MaquinaEstoqueCreateNestedManyWithoutProdutoInput
  }

  export type ProdutoUncheckedCreateWithoutNotasFiscaisItensInput = {
    id?: number
    descricao: string
    tipo: string
    preco: Decimal | DecimalJsLike | number | string
    maquinasEstoque?: MaquinaEstoqueUncheckedCreateNestedManyWithoutProdutoInput
  }

  export type ProdutoCreateOrConnectWithoutNotasFiscaisItensInput = {
    where: ProdutoWhereUniqueInput
    create: XOR<ProdutoCreateWithoutNotasFiscaisItensInput, ProdutoUncheckedCreateWithoutNotasFiscaisItensInput>
  }

  export type MaquinaEstoqueUpsertWithoutNotas_Fiscais_ItensInput = {
    update: XOR<MaquinaEstoqueUpdateWithoutNotas_Fiscais_ItensInput, MaquinaEstoqueUncheckedUpdateWithoutNotas_Fiscais_ItensInput>
    create: XOR<MaquinaEstoqueCreateWithoutNotas_Fiscais_ItensInput, MaquinaEstoqueUncheckedCreateWithoutNotas_Fiscais_ItensInput>
    where?: MaquinaEstoqueWhereInput
  }

  export type MaquinaEstoqueUpdateToOneWithWhereWithoutNotas_Fiscais_ItensInput = {
    where?: MaquinaEstoqueWhereInput
    data: XOR<MaquinaEstoqueUpdateWithoutNotas_Fiscais_ItensInput, MaquinaEstoqueUncheckedUpdateWithoutNotas_Fiscais_ItensInput>
  }

  export type MaquinaEstoqueUpdateWithoutNotas_Fiscais_ItensInput = {
    Chassi?: StringFieldUpdateOperationsInput | string
    Status?: NullableStringFieldUpdateOperationsInput | string | null
    produto?: ProdutoUpdateOneRequiredWithoutMaquinasEstoqueNestedInput
    filial?: FilialUpdateOneWithoutMaquinasEstoqueNestedInput
  }

  export type MaquinaEstoqueUncheckedUpdateWithoutNotas_Fiscais_ItensInput = {
    Chassi?: StringFieldUpdateOperationsInput | string
    produtoId?: IntFieldUpdateOperationsInput | number
    filialId?: NullableIntFieldUpdateOperationsInput | number | null
    Status?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type NotasFiscalCabecalhoUpsertWithoutItensInput = {
    update: XOR<NotasFiscalCabecalhoUpdateWithoutItensInput, NotasFiscalCabecalhoUncheckedUpdateWithoutItensInput>
    create: XOR<NotasFiscalCabecalhoCreateWithoutItensInput, NotasFiscalCabecalhoUncheckedCreateWithoutItensInput>
    where?: NotasFiscalCabecalhoWhereInput
  }

  export type NotasFiscalCabecalhoUpdateToOneWithWhereWithoutItensInput = {
    where?: NotasFiscalCabecalhoWhereInput
    data: XOR<NotasFiscalCabecalhoUpdateWithoutItensInput, NotasFiscalCabecalhoUncheckedUpdateWithoutItensInput>
  }

  export type NotasFiscalCabecalhoUpdateWithoutItensInput = {
    numeroNota?: IntFieldUpdateOperationsInput | number
    dataEmissao?: DateTimeFieldUpdateOperationsInput | Date | string
    valorTotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    filial?: FilialUpdateOneWithoutNotasFiscaisNestedInput
    cliente?: ClienteUpdateOneWithoutNotasFiscaisNestedInput
    vendedor?: VendedorUpdateOneWithoutNotasFiscaisNestedInput
  }

  export type NotasFiscalCabecalhoUncheckedUpdateWithoutItensInput = {
    id?: IntFieldUpdateOperationsInput | number
    numeroNota?: IntFieldUpdateOperationsInput | number
    dataEmissao?: DateTimeFieldUpdateOperationsInput | Date | string
    valorTotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    filialId?: NullableIntFieldUpdateOperationsInput | number | null
    clienteId?: NullableIntFieldUpdateOperationsInput | number | null
    vendedorId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type ProdutoUpsertWithoutNotasFiscaisItensInput = {
    update: XOR<ProdutoUpdateWithoutNotasFiscaisItensInput, ProdutoUncheckedUpdateWithoutNotasFiscaisItensInput>
    create: XOR<ProdutoCreateWithoutNotasFiscaisItensInput, ProdutoUncheckedCreateWithoutNotasFiscaisItensInput>
    where?: ProdutoWhereInput
  }

  export type ProdutoUpdateToOneWithWhereWithoutNotasFiscaisItensInput = {
    where?: ProdutoWhereInput
    data: XOR<ProdutoUpdateWithoutNotasFiscaisItensInput, ProdutoUncheckedUpdateWithoutNotasFiscaisItensInput>
  }

  export type ProdutoUpdateWithoutNotasFiscaisItensInput = {
    descricao?: StringFieldUpdateOperationsInput | string
    tipo?: StringFieldUpdateOperationsInput | string
    preco?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    maquinasEstoque?: MaquinaEstoqueUpdateManyWithoutProdutoNestedInput
  }

  export type ProdutoUncheckedUpdateWithoutNotasFiscaisItensInput = {
    id?: IntFieldUpdateOperationsInput | number
    descricao?: StringFieldUpdateOperationsInput | string
    tipo?: StringFieldUpdateOperationsInput | string
    preco?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    maquinasEstoque?: MaquinaEstoqueUncheckedUpdateManyWithoutProdutoNestedInput
  }

  export type FilialCreateWithoutRfvParameterSetsInput = {
    nome: string
    cnpj: string
    cidade?: string | null
    estado?: string | null
    empresa: EmpresaCreateNestedOneWithoutFiliaisInput
    notasFiscais?: NotasFiscalCabecalhoCreateNestedManyWithoutFilialInput
    vendedores?: VendedorCreateNestedManyWithoutFilialInput
    maquinasEstoque?: MaquinaEstoqueCreateNestedManyWithoutFilialInput
  }

  export type FilialUncheckedCreateWithoutRfvParameterSetsInput = {
    id?: number
    empresaId: number
    nome: string
    cnpj: string
    cidade?: string | null
    estado?: string | null
    notasFiscais?: NotasFiscalCabecalhoUncheckedCreateNestedManyWithoutFilialInput
    vendedores?: VendedorUncheckedCreateNestedManyWithoutFilialInput
    maquinasEstoque?: MaquinaEstoqueUncheckedCreateNestedManyWithoutFilialInput
  }

  export type FilialCreateOrConnectWithoutRfvParameterSetsInput = {
    where: FilialWhereUniqueInput
    create: XOR<FilialCreateWithoutRfvParameterSetsInput, FilialUncheckedCreateWithoutRfvParameterSetsInput>
  }

  export type RfvSegmentCreateWithoutParameterSetInput = {
    name: string
    rules: JsonNullValueInput | InputJsonValue
    priority?: number
  }

  export type RfvSegmentUncheckedCreateWithoutParameterSetInput = {
    id?: number
    name: string
    rules: JsonNullValueInput | InputJsonValue
    priority?: number
  }

  export type RfvSegmentCreateOrConnectWithoutParameterSetInput = {
    where: RfvSegmentWhereUniqueInput
    create: XOR<RfvSegmentCreateWithoutParameterSetInput, RfvSegmentUncheckedCreateWithoutParameterSetInput>
  }

  export type RfvSegmentCreateManyParameterSetInputEnvelope = {
    data: RfvSegmentCreateManyParameterSetInput | RfvSegmentCreateManyParameterSetInput[]
    skipDuplicates?: boolean
  }

  export type FilialUpsertWithoutRfvParameterSetsInput = {
    update: XOR<FilialUpdateWithoutRfvParameterSetsInput, FilialUncheckedUpdateWithoutRfvParameterSetsInput>
    create: XOR<FilialCreateWithoutRfvParameterSetsInput, FilialUncheckedCreateWithoutRfvParameterSetsInput>
    where?: FilialWhereInput
  }

  export type FilialUpdateToOneWithWhereWithoutRfvParameterSetsInput = {
    where?: FilialWhereInput
    data: XOR<FilialUpdateWithoutRfvParameterSetsInput, FilialUncheckedUpdateWithoutRfvParameterSetsInput>
  }

  export type FilialUpdateWithoutRfvParameterSetsInput = {
    nome?: StringFieldUpdateOperationsInput | string
    cnpj?: StringFieldUpdateOperationsInput | string
    cidade?: NullableStringFieldUpdateOperationsInput | string | null
    estado?: NullableStringFieldUpdateOperationsInput | string | null
    empresa?: EmpresaUpdateOneRequiredWithoutFiliaisNestedInput
    notasFiscais?: NotasFiscalCabecalhoUpdateManyWithoutFilialNestedInput
    vendedores?: VendedorUpdateManyWithoutFilialNestedInput
    maquinasEstoque?: MaquinaEstoqueUpdateManyWithoutFilialNestedInput
  }

  export type FilialUncheckedUpdateWithoutRfvParameterSetsInput = {
    id?: IntFieldUpdateOperationsInput | number
    empresaId?: IntFieldUpdateOperationsInput | number
    nome?: StringFieldUpdateOperationsInput | string
    cnpj?: StringFieldUpdateOperationsInput | string
    cidade?: NullableStringFieldUpdateOperationsInput | string | null
    estado?: NullableStringFieldUpdateOperationsInput | string | null
    notasFiscais?: NotasFiscalCabecalhoUncheckedUpdateManyWithoutFilialNestedInput
    vendedores?: VendedorUncheckedUpdateManyWithoutFilialNestedInput
    maquinasEstoque?: MaquinaEstoqueUncheckedUpdateManyWithoutFilialNestedInput
  }

  export type RfvSegmentUpsertWithWhereUniqueWithoutParameterSetInput = {
    where: RfvSegmentWhereUniqueInput
    update: XOR<RfvSegmentUpdateWithoutParameterSetInput, RfvSegmentUncheckedUpdateWithoutParameterSetInput>
    create: XOR<RfvSegmentCreateWithoutParameterSetInput, RfvSegmentUncheckedCreateWithoutParameterSetInput>
  }

  export type RfvSegmentUpdateWithWhereUniqueWithoutParameterSetInput = {
    where: RfvSegmentWhereUniqueInput
    data: XOR<RfvSegmentUpdateWithoutParameterSetInput, RfvSegmentUncheckedUpdateWithoutParameterSetInput>
  }

  export type RfvSegmentUpdateManyWithWhereWithoutParameterSetInput = {
    where: RfvSegmentScalarWhereInput
    data: XOR<RfvSegmentUpdateManyMutationInput, RfvSegmentUncheckedUpdateManyWithoutParameterSetInput>
  }

  export type RfvSegmentScalarWhereInput = {
    AND?: RfvSegmentScalarWhereInput | RfvSegmentScalarWhereInput[]
    OR?: RfvSegmentScalarWhereInput[]
    NOT?: RfvSegmentScalarWhereInput | RfvSegmentScalarWhereInput[]
    id?: IntFilter<"RfvSegment"> | number
    parameterSetId?: IntFilter<"RfvSegment"> | number
    name?: StringFilter<"RfvSegment"> | string
    rules?: JsonFilter<"RfvSegment">
    priority?: IntFilter<"RfvSegment"> | number
  }

  export type RfvParameterSetCreateWithoutSegmentsInput = {
    name: string
    strategy?: $Enums.RfvStrategy
    windowDays?: number
    weights: JsonNullValueInput | InputJsonValue
    ruleRecency: JsonNullValueInput | InputJsonValue
    ruleFrequency: JsonNullValueInput | InputJsonValue
    ruleValue: JsonNullValueInput | InputJsonValue
    effectiveFrom: Date | string
    effectiveTo?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    calculationStrategy?: $Enums.CalculationStrategy
    classRanges?: NullableJsonNullValueInput | InputJsonValue
    conditionalRules?: NullableJsonNullValueInput | InputJsonValue
    filial?: FilialCreateNestedOneWithoutRfvParameterSetsInput
  }

  export type RfvParameterSetUncheckedCreateWithoutSegmentsInput = {
    id?: number
    filialId?: number | null
    name: string
    strategy?: $Enums.RfvStrategy
    windowDays?: number
    weights: JsonNullValueInput | InputJsonValue
    ruleRecency: JsonNullValueInput | InputJsonValue
    ruleFrequency: JsonNullValueInput | InputJsonValue
    ruleValue: JsonNullValueInput | InputJsonValue
    effectiveFrom: Date | string
    effectiveTo?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    calculationStrategy?: $Enums.CalculationStrategy
    classRanges?: NullableJsonNullValueInput | InputJsonValue
    conditionalRules?: NullableJsonNullValueInput | InputJsonValue
  }

  export type RfvParameterSetCreateOrConnectWithoutSegmentsInput = {
    where: RfvParameterSetWhereUniqueInput
    create: XOR<RfvParameterSetCreateWithoutSegmentsInput, RfvParameterSetUncheckedCreateWithoutSegmentsInput>
  }

  export type RfvParameterSetUpsertWithoutSegmentsInput = {
    update: XOR<RfvParameterSetUpdateWithoutSegmentsInput, RfvParameterSetUncheckedUpdateWithoutSegmentsInput>
    create: XOR<RfvParameterSetCreateWithoutSegmentsInput, RfvParameterSetUncheckedCreateWithoutSegmentsInput>
    where?: RfvParameterSetWhereInput
  }

  export type RfvParameterSetUpdateToOneWithWhereWithoutSegmentsInput = {
    where?: RfvParameterSetWhereInput
    data: XOR<RfvParameterSetUpdateWithoutSegmentsInput, RfvParameterSetUncheckedUpdateWithoutSegmentsInput>
  }

  export type RfvParameterSetUpdateWithoutSegmentsInput = {
    name?: StringFieldUpdateOperationsInput | string
    strategy?: EnumRfvStrategyFieldUpdateOperationsInput | $Enums.RfvStrategy
    windowDays?: IntFieldUpdateOperationsInput | number
    weights?: JsonNullValueInput | InputJsonValue
    ruleRecency?: JsonNullValueInput | InputJsonValue
    ruleFrequency?: JsonNullValueInput | InputJsonValue
    ruleValue?: JsonNullValueInput | InputJsonValue
    effectiveFrom?: DateTimeFieldUpdateOperationsInput | Date | string
    effectiveTo?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    calculationStrategy?: EnumCalculationStrategyFieldUpdateOperationsInput | $Enums.CalculationStrategy
    classRanges?: NullableJsonNullValueInput | InputJsonValue
    conditionalRules?: NullableJsonNullValueInput | InputJsonValue
    filial?: FilialUpdateOneWithoutRfvParameterSetsNestedInput
  }

  export type RfvParameterSetUncheckedUpdateWithoutSegmentsInput = {
    id?: IntFieldUpdateOperationsInput | number
    filialId?: NullableIntFieldUpdateOperationsInput | number | null
    name?: StringFieldUpdateOperationsInput | string
    strategy?: EnumRfvStrategyFieldUpdateOperationsInput | $Enums.RfvStrategy
    windowDays?: IntFieldUpdateOperationsInput | number
    weights?: JsonNullValueInput | InputJsonValue
    ruleRecency?: JsonNullValueInput | InputJsonValue
    ruleFrequency?: JsonNullValueInput | InputJsonValue
    ruleValue?: JsonNullValueInput | InputJsonValue
    effectiveFrom?: DateTimeFieldUpdateOperationsInput | Date | string
    effectiveTo?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    calculationStrategy?: EnumCalculationStrategyFieldUpdateOperationsInput | $Enums.CalculationStrategy
    classRanges?: NullableJsonNullValueInput | InputJsonValue
    conditionalRules?: NullableJsonNullValueInput | InputJsonValue
  }

  export type FilialCreateManyEmpresaInput = {
    id?: number
    nome: string
    cnpj: string
    cidade?: string | null
    estado?: string | null
  }

  export type FilialUpdateWithoutEmpresaInput = {
    nome?: StringFieldUpdateOperationsInput | string
    cnpj?: StringFieldUpdateOperationsInput | string
    cidade?: NullableStringFieldUpdateOperationsInput | string | null
    estado?: NullableStringFieldUpdateOperationsInput | string | null
    notasFiscais?: NotasFiscalCabecalhoUpdateManyWithoutFilialNestedInput
    vendedores?: VendedorUpdateManyWithoutFilialNestedInput
    rfvParameterSets?: RfvParameterSetUpdateManyWithoutFilialNestedInput
    maquinasEstoque?: MaquinaEstoqueUpdateManyWithoutFilialNestedInput
  }

  export type FilialUncheckedUpdateWithoutEmpresaInput = {
    id?: IntFieldUpdateOperationsInput | number
    nome?: StringFieldUpdateOperationsInput | string
    cnpj?: StringFieldUpdateOperationsInput | string
    cidade?: NullableStringFieldUpdateOperationsInput | string | null
    estado?: NullableStringFieldUpdateOperationsInput | string | null
    notasFiscais?: NotasFiscalCabecalhoUncheckedUpdateManyWithoutFilialNestedInput
    vendedores?: VendedorUncheckedUpdateManyWithoutFilialNestedInput
    rfvParameterSets?: RfvParameterSetUncheckedUpdateManyWithoutFilialNestedInput
    maquinasEstoque?: MaquinaEstoqueUncheckedUpdateManyWithoutFilialNestedInput
  }

  export type FilialUncheckedUpdateManyWithoutEmpresaInput = {
    id?: IntFieldUpdateOperationsInput | number
    nome?: StringFieldUpdateOperationsInput | string
    cnpj?: StringFieldUpdateOperationsInput | string
    cidade?: NullableStringFieldUpdateOperationsInput | string | null
    estado?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type NotasFiscalCabecalhoCreateManyClienteInput = {
    id?: number
    numeroNota: number
    dataEmissao: Date | string
    valorTotal: Decimal | DecimalJsLike | number | string
    filialId?: number | null
    vendedorId?: number | null
  }

  export type NotasFiscalCabecalhoUpdateWithoutClienteInput = {
    numeroNota?: IntFieldUpdateOperationsInput | number
    dataEmissao?: DateTimeFieldUpdateOperationsInput | Date | string
    valorTotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    filial?: FilialUpdateOneWithoutNotasFiscaisNestedInput
    vendedor?: VendedorUpdateOneWithoutNotasFiscaisNestedInput
    itens?: NotaFiscalItemUpdateManyWithoutNotaFiscalNestedInput
  }

  export type NotasFiscalCabecalhoUncheckedUpdateWithoutClienteInput = {
    id?: IntFieldUpdateOperationsInput | number
    numeroNota?: IntFieldUpdateOperationsInput | number
    dataEmissao?: DateTimeFieldUpdateOperationsInput | Date | string
    valorTotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    filialId?: NullableIntFieldUpdateOperationsInput | number | null
    vendedorId?: NullableIntFieldUpdateOperationsInput | number | null
    itens?: NotaFiscalItemUncheckedUpdateManyWithoutNotaFiscalNestedInput
  }

  export type NotasFiscalCabecalhoUncheckedUpdateManyWithoutClienteInput = {
    id?: IntFieldUpdateOperationsInput | number
    numeroNota?: IntFieldUpdateOperationsInput | number
    dataEmissao?: DateTimeFieldUpdateOperationsInput | Date | string
    valorTotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    filialId?: NullableIntFieldUpdateOperationsInput | number | null
    vendedorId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type NotasFiscalCabecalhoCreateManyFilialInput = {
    id?: number
    numeroNota: number
    dataEmissao: Date | string
    valorTotal: Decimal | DecimalJsLike | number | string
    clienteId?: number | null
    vendedorId?: number | null
  }

  export type VendedorCreateManyFilialInput = {
    id?: number
    nome: string
    cpf: string
  }

  export type RfvParameterSetCreateManyFilialInput = {
    id?: number
    name: string
    strategy?: $Enums.RfvStrategy
    windowDays?: number
    weights: JsonNullValueInput | InputJsonValue
    ruleRecency: JsonNullValueInput | InputJsonValue
    ruleFrequency: JsonNullValueInput | InputJsonValue
    ruleValue: JsonNullValueInput | InputJsonValue
    effectiveFrom: Date | string
    effectiveTo?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    calculationStrategy?: $Enums.CalculationStrategy
    classRanges?: NullableJsonNullValueInput | InputJsonValue
    conditionalRules?: NullableJsonNullValueInput | InputJsonValue
  }

  export type MaquinaEstoqueCreateManyFilialInput = {
    Chassi: string
    produtoId: number
    Status?: string | null
  }

  export type NotasFiscalCabecalhoUpdateWithoutFilialInput = {
    numeroNota?: IntFieldUpdateOperationsInput | number
    dataEmissao?: DateTimeFieldUpdateOperationsInput | Date | string
    valorTotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    cliente?: ClienteUpdateOneWithoutNotasFiscaisNestedInput
    vendedor?: VendedorUpdateOneWithoutNotasFiscaisNestedInput
    itens?: NotaFiscalItemUpdateManyWithoutNotaFiscalNestedInput
  }

  export type NotasFiscalCabecalhoUncheckedUpdateWithoutFilialInput = {
    id?: IntFieldUpdateOperationsInput | number
    numeroNota?: IntFieldUpdateOperationsInput | number
    dataEmissao?: DateTimeFieldUpdateOperationsInput | Date | string
    valorTotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    clienteId?: NullableIntFieldUpdateOperationsInput | number | null
    vendedorId?: NullableIntFieldUpdateOperationsInput | number | null
    itens?: NotaFiscalItemUncheckedUpdateManyWithoutNotaFiscalNestedInput
  }

  export type NotasFiscalCabecalhoUncheckedUpdateManyWithoutFilialInput = {
    id?: IntFieldUpdateOperationsInput | number
    numeroNota?: IntFieldUpdateOperationsInput | number
    dataEmissao?: DateTimeFieldUpdateOperationsInput | Date | string
    valorTotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    clienteId?: NullableIntFieldUpdateOperationsInput | number | null
    vendedorId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type VendedorUpdateWithoutFilialInput = {
    nome?: StringFieldUpdateOperationsInput | string
    cpf?: StringFieldUpdateOperationsInput | string
    notasFiscais?: NotasFiscalCabecalhoUpdateManyWithoutVendedorNestedInput
  }

  export type VendedorUncheckedUpdateWithoutFilialInput = {
    id?: IntFieldUpdateOperationsInput | number
    nome?: StringFieldUpdateOperationsInput | string
    cpf?: StringFieldUpdateOperationsInput | string
    notasFiscais?: NotasFiscalCabecalhoUncheckedUpdateManyWithoutVendedorNestedInput
  }

  export type VendedorUncheckedUpdateManyWithoutFilialInput = {
    id?: IntFieldUpdateOperationsInput | number
    nome?: StringFieldUpdateOperationsInput | string
    cpf?: StringFieldUpdateOperationsInput | string
  }

  export type RfvParameterSetUpdateWithoutFilialInput = {
    name?: StringFieldUpdateOperationsInput | string
    strategy?: EnumRfvStrategyFieldUpdateOperationsInput | $Enums.RfvStrategy
    windowDays?: IntFieldUpdateOperationsInput | number
    weights?: JsonNullValueInput | InputJsonValue
    ruleRecency?: JsonNullValueInput | InputJsonValue
    ruleFrequency?: JsonNullValueInput | InputJsonValue
    ruleValue?: JsonNullValueInput | InputJsonValue
    effectiveFrom?: DateTimeFieldUpdateOperationsInput | Date | string
    effectiveTo?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    calculationStrategy?: EnumCalculationStrategyFieldUpdateOperationsInput | $Enums.CalculationStrategy
    classRanges?: NullableJsonNullValueInput | InputJsonValue
    conditionalRules?: NullableJsonNullValueInput | InputJsonValue
    segments?: RfvSegmentUpdateManyWithoutParameterSetNestedInput
  }

  export type RfvParameterSetUncheckedUpdateWithoutFilialInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    strategy?: EnumRfvStrategyFieldUpdateOperationsInput | $Enums.RfvStrategy
    windowDays?: IntFieldUpdateOperationsInput | number
    weights?: JsonNullValueInput | InputJsonValue
    ruleRecency?: JsonNullValueInput | InputJsonValue
    ruleFrequency?: JsonNullValueInput | InputJsonValue
    ruleValue?: JsonNullValueInput | InputJsonValue
    effectiveFrom?: DateTimeFieldUpdateOperationsInput | Date | string
    effectiveTo?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    calculationStrategy?: EnumCalculationStrategyFieldUpdateOperationsInput | $Enums.CalculationStrategy
    classRanges?: NullableJsonNullValueInput | InputJsonValue
    conditionalRules?: NullableJsonNullValueInput | InputJsonValue
    segments?: RfvSegmentUncheckedUpdateManyWithoutParameterSetNestedInput
  }

  export type RfvParameterSetUncheckedUpdateManyWithoutFilialInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    strategy?: EnumRfvStrategyFieldUpdateOperationsInput | $Enums.RfvStrategy
    windowDays?: IntFieldUpdateOperationsInput | number
    weights?: JsonNullValueInput | InputJsonValue
    ruleRecency?: JsonNullValueInput | InputJsonValue
    ruleFrequency?: JsonNullValueInput | InputJsonValue
    ruleValue?: JsonNullValueInput | InputJsonValue
    effectiveFrom?: DateTimeFieldUpdateOperationsInput | Date | string
    effectiveTo?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    calculationStrategy?: EnumCalculationStrategyFieldUpdateOperationsInput | $Enums.CalculationStrategy
    classRanges?: NullableJsonNullValueInput | InputJsonValue
    conditionalRules?: NullableJsonNullValueInput | InputJsonValue
  }

  export type MaquinaEstoqueUpdateWithoutFilialInput = {
    Chassi?: StringFieldUpdateOperationsInput | string
    Status?: NullableStringFieldUpdateOperationsInput | string | null
    produto?: ProdutoUpdateOneRequiredWithoutMaquinasEstoqueNestedInput
    Notas_Fiscais_Itens?: NotaFiscalItemUpdateManyWithoutMaquinas_EstoqueNestedInput
  }

  export type MaquinaEstoqueUncheckedUpdateWithoutFilialInput = {
    Chassi?: StringFieldUpdateOperationsInput | string
    produtoId?: IntFieldUpdateOperationsInput | number
    Status?: NullableStringFieldUpdateOperationsInput | string | null
    Notas_Fiscais_Itens?: NotaFiscalItemUncheckedUpdateManyWithoutMaquinas_EstoqueNestedInput
  }

  export type MaquinaEstoqueUncheckedUpdateManyWithoutFilialInput = {
    Chassi?: StringFieldUpdateOperationsInput | string
    produtoId?: IntFieldUpdateOperationsInput | number
    Status?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type NotasFiscalCabecalhoCreateManyVendedorInput = {
    id?: number
    numeroNota: number
    dataEmissao: Date | string
    valorTotal: Decimal | DecimalJsLike | number | string
    filialId?: number | null
    clienteId?: number | null
  }

  export type NotasFiscalCabecalhoUpdateWithoutVendedorInput = {
    numeroNota?: IntFieldUpdateOperationsInput | number
    dataEmissao?: DateTimeFieldUpdateOperationsInput | Date | string
    valorTotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    filial?: FilialUpdateOneWithoutNotasFiscaisNestedInput
    cliente?: ClienteUpdateOneWithoutNotasFiscaisNestedInput
    itens?: NotaFiscalItemUpdateManyWithoutNotaFiscalNestedInput
  }

  export type NotasFiscalCabecalhoUncheckedUpdateWithoutVendedorInput = {
    id?: IntFieldUpdateOperationsInput | number
    numeroNota?: IntFieldUpdateOperationsInput | number
    dataEmissao?: DateTimeFieldUpdateOperationsInput | Date | string
    valorTotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    filialId?: NullableIntFieldUpdateOperationsInput | number | null
    clienteId?: NullableIntFieldUpdateOperationsInput | number | null
    itens?: NotaFiscalItemUncheckedUpdateManyWithoutNotaFiscalNestedInput
  }

  export type NotasFiscalCabecalhoUncheckedUpdateManyWithoutVendedorInput = {
    id?: IntFieldUpdateOperationsInput | number
    numeroNota?: IntFieldUpdateOperationsInput | number
    dataEmissao?: DateTimeFieldUpdateOperationsInput | Date | string
    valorTotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    filialId?: NullableIntFieldUpdateOperationsInput | number | null
    clienteId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type MaquinaEstoqueCreateManyProdutoInput = {
    Chassi: string
    filialId?: number | null
    Status?: string | null
  }

  export type NotaFiscalItemCreateManyProdutoInput = {
    id?: number
    notaFiscalId: number
    Quantidade: Decimal | DecimalJsLike | number | string
    valorUnitario: Decimal | DecimalJsLike | number | string
    valorTotalItem: Decimal | DecimalJsLike | number | string
    Chassi?: string | null
  }

  export type MaquinaEstoqueUpdateWithoutProdutoInput = {
    Chassi?: StringFieldUpdateOperationsInput | string
    Status?: NullableStringFieldUpdateOperationsInput | string | null
    filial?: FilialUpdateOneWithoutMaquinasEstoqueNestedInput
    Notas_Fiscais_Itens?: NotaFiscalItemUpdateManyWithoutMaquinas_EstoqueNestedInput
  }

  export type MaquinaEstoqueUncheckedUpdateWithoutProdutoInput = {
    Chassi?: StringFieldUpdateOperationsInput | string
    filialId?: NullableIntFieldUpdateOperationsInput | number | null
    Status?: NullableStringFieldUpdateOperationsInput | string | null
    Notas_Fiscais_Itens?: NotaFiscalItemUncheckedUpdateManyWithoutMaquinas_EstoqueNestedInput
  }

  export type MaquinaEstoqueUncheckedUpdateManyWithoutProdutoInput = {
    Chassi?: StringFieldUpdateOperationsInput | string
    filialId?: NullableIntFieldUpdateOperationsInput | number | null
    Status?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type NotaFiscalItemUpdateWithoutProdutoInput = {
    Quantidade?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    valorUnitario?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    valorTotalItem?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    Maquinas_Estoque?: MaquinaEstoqueUpdateOneWithoutNotas_Fiscais_ItensNestedInput
    notaFiscal?: NotasFiscalCabecalhoUpdateOneRequiredWithoutItensNestedInput
  }

  export type NotaFiscalItemUncheckedUpdateWithoutProdutoInput = {
    id?: IntFieldUpdateOperationsInput | number
    notaFiscalId?: IntFieldUpdateOperationsInput | number
    Quantidade?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    valorUnitario?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    valorTotalItem?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    Chassi?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type NotaFiscalItemUncheckedUpdateManyWithoutProdutoInput = {
    id?: IntFieldUpdateOperationsInput | number
    notaFiscalId?: IntFieldUpdateOperationsInput | number
    Quantidade?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    valorUnitario?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    valorTotalItem?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    Chassi?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type NotaFiscalItemCreateManyMaquinas_EstoqueInput = {
    id?: number
    notaFiscalId: number
    produtoId: number
    Quantidade: Decimal | DecimalJsLike | number | string
    valorUnitario: Decimal | DecimalJsLike | number | string
    valorTotalItem: Decimal | DecimalJsLike | number | string
  }

  export type NotaFiscalItemUpdateWithoutMaquinas_EstoqueInput = {
    Quantidade?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    valorUnitario?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    valorTotalItem?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    notaFiscal?: NotasFiscalCabecalhoUpdateOneRequiredWithoutItensNestedInput
    produto?: ProdutoUpdateOneRequiredWithoutNotasFiscaisItensNestedInput
  }

  export type NotaFiscalItemUncheckedUpdateWithoutMaquinas_EstoqueInput = {
    id?: IntFieldUpdateOperationsInput | number
    notaFiscalId?: IntFieldUpdateOperationsInput | number
    produtoId?: IntFieldUpdateOperationsInput | number
    Quantidade?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    valorUnitario?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    valorTotalItem?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
  }

  export type NotaFiscalItemUncheckedUpdateManyWithoutMaquinas_EstoqueInput = {
    id?: IntFieldUpdateOperationsInput | number
    notaFiscalId?: IntFieldUpdateOperationsInput | number
    produtoId?: IntFieldUpdateOperationsInput | number
    Quantidade?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    valorUnitario?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    valorTotalItem?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
  }

  export type NotaFiscalItemCreateManyNotaFiscalInput = {
    id?: number
    produtoId: number
    Quantidade: Decimal | DecimalJsLike | number | string
    valorUnitario: Decimal | DecimalJsLike | number | string
    valorTotalItem: Decimal | DecimalJsLike | number | string
    Chassi?: string | null
  }

  export type NotaFiscalItemUpdateWithoutNotaFiscalInput = {
    Quantidade?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    valorUnitario?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    valorTotalItem?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    Maquinas_Estoque?: MaquinaEstoqueUpdateOneWithoutNotas_Fiscais_ItensNestedInput
    produto?: ProdutoUpdateOneRequiredWithoutNotasFiscaisItensNestedInput
  }

  export type NotaFiscalItemUncheckedUpdateWithoutNotaFiscalInput = {
    id?: IntFieldUpdateOperationsInput | number
    produtoId?: IntFieldUpdateOperationsInput | number
    Quantidade?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    valorUnitario?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    valorTotalItem?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    Chassi?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type NotaFiscalItemUncheckedUpdateManyWithoutNotaFiscalInput = {
    id?: IntFieldUpdateOperationsInput | number
    produtoId?: IntFieldUpdateOperationsInput | number
    Quantidade?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    valorUnitario?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    valorTotalItem?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    Chassi?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type RfvSegmentCreateManyParameterSetInput = {
    id?: number
    name: string
    rules: JsonNullValueInput | InputJsonValue
    priority?: number
  }

  export type RfvSegmentUpdateWithoutParameterSetInput = {
    name?: StringFieldUpdateOperationsInput | string
    rules?: JsonNullValueInput | InputJsonValue
    priority?: IntFieldUpdateOperationsInput | number
  }

  export type RfvSegmentUncheckedUpdateWithoutParameterSetInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    rules?: JsonNullValueInput | InputJsonValue
    priority?: IntFieldUpdateOperationsInput | number
  }

  export type RfvSegmentUncheckedUpdateManyWithoutParameterSetInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    rules?: JsonNullValueInput | InputJsonValue
    priority?: IntFieldUpdateOperationsInput | number
  }



  /**
   * Aliases for legacy arg types
   */
    /**
     * @deprecated Use EmpresaCountOutputTypeDefaultArgs instead
     */
    export type EmpresaCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = EmpresaCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ClienteCountOutputTypeDefaultArgs instead
     */
    export type ClienteCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ClienteCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use FilialCountOutputTypeDefaultArgs instead
     */
    export type FilialCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = FilialCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use VendedorCountOutputTypeDefaultArgs instead
     */
    export type VendedorCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = VendedorCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ProdutoCountOutputTypeDefaultArgs instead
     */
    export type ProdutoCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ProdutoCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use MaquinaEstoqueCountOutputTypeDefaultArgs instead
     */
    export type MaquinaEstoqueCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = MaquinaEstoqueCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use NotasFiscalCabecalhoCountOutputTypeDefaultArgs instead
     */
    export type NotasFiscalCabecalhoCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = NotasFiscalCabecalhoCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use RfvParameterSetCountOutputTypeDefaultArgs instead
     */
    export type RfvParameterSetCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = RfvParameterSetCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use EmpresaDefaultArgs instead
     */
    export type EmpresaArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = EmpresaDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ClienteDefaultArgs instead
     */
    export type ClienteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ClienteDefaultArgs<ExtArgs>
    /**
     * @deprecated Use FilialDefaultArgs instead
     */
    export type FilialArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = FilialDefaultArgs<ExtArgs>
    /**
     * @deprecated Use VendedorDefaultArgs instead
     */
    export type VendedorArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = VendedorDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ProdutoDefaultArgs instead
     */
    export type ProdutoArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ProdutoDefaultArgs<ExtArgs>
    /**
     * @deprecated Use MaquinaEstoqueDefaultArgs instead
     */
    export type MaquinaEstoqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = MaquinaEstoqueDefaultArgs<ExtArgs>
    /**
     * @deprecated Use NotasFiscalCabecalhoDefaultArgs instead
     */
    export type NotasFiscalCabecalhoArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = NotasFiscalCabecalhoDefaultArgs<ExtArgs>
    /**
     * @deprecated Use NotaFiscalItemDefaultArgs instead
     */
    export type NotaFiscalItemArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = NotaFiscalItemDefaultArgs<ExtArgs>
    /**
     * @deprecated Use UserDefaultArgs instead
     */
    export type UserArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = UserDefaultArgs<ExtArgs>
    /**
     * @deprecated Use RfvParameterSetDefaultArgs instead
     */
    export type RfvParameterSetArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = RfvParameterSetDefaultArgs<ExtArgs>
    /**
     * @deprecated Use RfvSegmentDefaultArgs instead
     */
    export type RfvSegmentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = RfvSegmentDefaultArgs<ExtArgs>

  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}